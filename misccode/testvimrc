
if !exists("autocommands_loaded")
  let autocommands_loaded = 1
 
	" Return to the line and column of last edited position
	" autocmd BufReadPost * if line("'\"") | exe "normal '\"" | endif
	autocmd BufReadPost [^vimxfer_ses] if line("'\"") | exe "normal '\"" | endif

  " Move cursor to filename for gf
	" autocmd BufReadPost /tmp/.loc exe "normal $"
	autocmd BufReadPost *.plsql echo 'ok'

  " Handle my ~/bin/sasrun script files
  au BufRead tmpsas.*.log,tmpsas.*.lst map q :qa!<CR>
  au BufRead tmpsas.*.log,tmpsas.*.lst echo '.vimrc: q to exit all'
  au BufRead /cygdrive/c/temp/query.out map q :qa!<CR>
  au BufRead /cygdrive/c/temp/query.out echo '.vimrc: q to exit'

  " au BufNewFile,BufRead,BufEnter *.sas map ;; :call setline('.', Commentout(getline('.'), 'sas'))<CR>
  au BufNewFile,BufRead,BufEnter *.sas map ;c 0Di  *  Created: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter *.sas map ;m 0Di  * Modified: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter *.sas map ,m yy0I***<ESC>p
  " Define pairs to allow the 'bounce on %' plugin to work.  Case insensitive.  No spaces between pairs!
  au BufNewFile,BufRead,BufEnter *.sas let b:match_words = '\<do\>:\<end\>,\<data\s\+\w\+:\<run\;,%macro.*\;:\<mend\>.*\;,\<sql.*;:\<quit;'
  " Filter SAS Log for error-like lines (and lines that should be errors) only
  au BufNewFile,BufRead,BufEnter *.log nnoremap <silent> <F8> :g!/^ERROR:\\\|^WARNING:\\\|lines were truncated\\\|^NOTE: Invalid data for\\\|^NOTE: Variable/d<CR>
  " au BufNewFile,BufRead,BufEnter *.sas,*.log map ;e /^ERROR:/<CR>
  au BufNewFile,BufRead,BufEnter *.sas,*.log map ;e /^ERROR\\\|^WARNING:/<CR>
  " au BufNewFile,BufRead,BufEnter *.log set guifont=Consolas:h8
	au BufRead,BufNewFile *.plsql,*.pkg,*.pck,*.spc,*.prc,*.fnc set filetype=plsql
  au BufNewFile,BufRead,BufEnter *.plsql,*.pck,*.prc,*.fnc let b:match_words = '\<begin\>:\<end\>,\<loop\>:\<end loop\>'

  " TOGGLE. Delete the yearly warning lines
  """au BufRead *.log :g/^WARNING: The Base Product\|installation repres/d
  """au BufRead *.log :g/^WARNING: Your system is scheduled to expire on/d
  """au BufRead *.log :g/Please contact your SAS/d
  """au BufRead *.log :g/information.  The SAS System will no longer function on or after that/d
  """au BufRead *.log :g/representative to have it renewed/d

  au BufNewFile,BufRead,BufEnter *.pl nmap ,p :!perl -c %<CR>
  au BufNewFile,BufRead,BufEnter *.pl nmap ;z :!echo && echo && perl %<CR>
  " Alternate help files via 'K'.  Default s/b set above as keywordprg=man
  au BufNewFile,BufRead,BufEnter *.p[lm] set keywordprg=perldoc\ -f
  au BufNewFile,BufRead,BufEnter *.pl map ,3 :s:^###::g<CR>:se nohls<CR>
  " if has ('unix') && version > 599
    " au BufWritePost *.pl silent !chmod a+x <afile>
  " endif
"""  au BufNewFile,BufRead,BufEnter *.pl,*.pm map ;; :call setline('.', Commentout(getline('.'), 'perl'))<CR>
  " end Perl

  " TODO use &ft instead of python, need function?
  au BufNewFile,BufRead,BufEnter *.py nmap ;z :!echo && echo && python %<CR>

  " au FileType sh set fileformat=unix
  au BufWritePost *.sh silent !chmod a+x <afile>
  au FileType basic map ,m yy0I'''<ESC>p
  au FileType basic map ;s :s:^:''':<CR>
  au BufNewFile,BufRead,BufEnter *.c,*.cpp,*.h map ;c 0Di//  Created: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter *.c,*.cpp,*.h map ;m 0Di// Modified: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter *.c,*.cpp,*.h map ,m yy0I///<ESC>p
"""  au FileType sh map ;; :call setline('.', Commentout(getline('.'), 'default'))<CR>
  " Default Vim make is for C, this handles C++
  au BufNewFile,BufRead,BufEnter *.cpp set makeprg=g++\ -Wall\ %
  au BufNewFile,BufRead,BufEnter *.c nmap ;z :!gcc %<CR>\|:echon 'compiled a.exe via ;z map'<CR>
"""  au FileType javascript map ;; :call setline('.', Commentout(getline('.'), 'cpp'))<CR>
"""  au BufNewFile,BufRead,BufEnter *.htm*,*xsl* map ;; :call setline('.', Commentout(getline('.'), 'html'))<CR>
  au BufNewFile,BufRead,BufEnter *.htm* map ,m yy0I///<ESC>p
  au BufNewFile,BufRead,BufEnter *.asp,*.bas let s:VBnotend = '\%(\<end\s\+\)\@<!'
  au BufNewFile,BufRead,BufEnter *.asp,*.bas let b:match_words = s:VBnotend . '\<if\>:\<end\s\+if\>'
  " Automatically flow text
  au BufReadPre,FileReadPre *.email set formatoptions=a

  " au BufNewFile,BufRead,BufEnter *vimperatorrc* source ~/code/misccode/vimperator.vim

	" Conveniences for my custom searching code e.g. ~/code/perl/bgrep or ~/code/misccode/prj
  au BufNewFile,BufEnter */tmp/*.grep source ~/code/misccode/bgrep.vim
  au BufNewFile,BufEnter */tmp/*.grep map <CR> <C-W>f :set winheight=9999<CR>/<C-R>/<CR>
  au BufNewFile,BufEnter */tmp/*.grep,*/tmp/prj.out map q :q<CR>
  au BufNewFile,BufEnter */tmp/*.grep,*/tmp/prj.out echon '.vimrc: <CR> to select file, q to quit'

  " Don't wrap these
  au BufRead,BufEnter *.htm*,*.cgi,*/tmp/bash*,afiedt.buf set tw=0 wm=0

  au BufRead,BufEnter *.sql,afiedt.buf iab LI limit 10
  au BufRead,BufEnter *.sql,afiedt.buf iab OB order by 1
  au BufRead,BufEnter *.sql,afiedt.buf iab SF select * from
  au BufRead,BufEnter *.sql,afiedt.buf iab SC select count(*) from
  au BufRead,BufEnter *.sql,afiedt.buf iab WH where

  " See  set cinwords  above.
"""  au BufNewFile,BufRead,BufEnter *.c,*.cpp,*.pl,*.pm,*.sas set smartindent
  " Fix not-so-smartindent comment outdenting:  TODO ignored, can't use
  " >> to shift lines starting with '#'
"""  au BufNewFile,BufRead,BufEnter *.c,*.cpp,*.pl,*.pm,*.sas inoremap # X#
  " Remove trailing blank lines so they don't get '>' quoted.
  " TODO need to remove blank > lines instead of blank lines
  """autocmd BufRead mutt-*[0-9],.followup,.article,.letter :1,$!sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba'
  " end ~/bin/bgrep

  " We never edit these files so simplify exiting:
  au BufEnter $VIMRUNTIME/doc/*.txt nnoremap q :q<CR>
  au BufLeave $VIMRUNTIME/doc/*.txt unmap q

  " Set to empty to default to Vim's help:
  au BufNewFile,BufRead,BufEnter *.vim,.vimrc,*.htm,*.html,*_vimrc set keywordprg=
  au FileType HELP set keywordprg=

  au BufNewFile,BufRead,BufEnter .vimrc,_vimrc*,*.vim,_vimperatorrc map ;c 0Di"  Created: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter .vimrc,_vimrc*,*.vim,_vimperatorrc map ;m 0Di" Modified: <C-R>=strftime("%a %d %b %Y %H:%M:%S")<CR> (Bob Heckel)<ESC>0
  au BufNewFile,BufRead,BufEnter .vimrc,_vimrc*,*.vim,_vimperatorrc map ,m yy0I"""<ESC>p
"""  au BufNewFile,BufRead,BufEnter .bashrc,_bashrc* map ;; :call setline('.', Commentout(getline('.'), 'bash'))<CR>
  au BufNewFile,BufRead,BufEnter *.vim nmap ;z :source %<CR>

  " MS Office
  au BufReadPre *.doc set ro
  au BufReadPre *.doc set hlsearch!
  au BufReadPre *.doc nnoremap q :q!<CR>
  au BufReadPost *.doc echon '.vimrc: q mapped to :q!'
  " TODO check for existence of antiword, otherwise use cygstart
  au BufReadPost *.doc %!antiword "%"

  augroup Binary
    au!
    au BufReadPre  *.exe let &bin=1
    au BufReadPost *.exe if &bin | %!xxd
    au BufReadPost *.exe set ft=xxd | endif
    au BufWritePre *.exe if &bin | %!xxd -r
    au BufWritePre *.exe endif
    au BufWritePost *.exe if &bin | %!xxd
    au BufWritePost *.exe set nomod | endif
  augroup END

  "TODO handle Cygwin paths
  " au BufRead *.pdf silent execute "!explorer" . shellescape(expand("%:p")) . " &>/dev/null &" | buffer# | bdelete# | redraw! | syntax on

  " This block must be placed near end of au commands for syntax coloring to
  " be disabled.
  if &diff
    " Don't interfere with diff's syntax
    au BufNewFile,BufRead,BufEnter * syntax off
    " Always maximize gvim when using vimdiff
    au GUIEnter * simalt ~x
    """set guifont=Andale_Mono:h7
    " TODO gtk
    set guifont=Consolas:h7
  endif

  au BufRead *.xml map <F3> :silent 1,$!xmllint --format --recover - 2>/dev/null

  au BufEnter oneliners,.vimrc,_vimrc,.bashrc,_bashrc set foldmethod=marker

  au BufEnter .vimrc echo ".vimrc: $MYVIMRC:" $MYVIMRC

  au BufRead,BufEnter *.txt set wrap

  " We'll never need to edit a tarball or QuickFix list
  au FileType TAR,QF map q :q<CR>

  " Act like gvim when a file was changed behind our back:
  au WinEnter * checktime

  " Always edit git commit messages at position 1L,1C
  au FileType GITCOMMIT :1

  au BufNewFile,BufRead *.md   set syntax=markdown

  " Without this, NetRW loses its place when returning to the tree (use buffer n because mz is taken by netrw):
	au BufLeave NetrwTreeListing mn
	au BufEnter NetrwTreeListing `n

  " TODO
  " au BufNewFile,BufEnter *.py set tabstop=4

  " Enterprise Guide files
  au BufReadCmd *.egp call zip#Browse(expand("<amatch>"))

  " See my .bashrc function ses()
  au BufReadCmd /tmp/bash-fc* nmap ;r :call ReadFromFile(VTMP, '.vimxfer_ses')<CR>
  au BufEnter /tmp/bash-fc* set ff=unix

  " au BufNewFile,BufRead,BufEnter *.log set noswapfile | set hlsearch | source c:/cygwin64/home/bob.heckel/code/sas/saslog.vim
  au BufNewFile,BufRead,BufEnter *.log set noswapfile | set hlsearch | source $HOME/code/sas/saslog.vim
  " au BufNewFile,BufRead,BufEnter *.log set noswapfile | set hlsearch | source $VIMRUNTIME\syntax\saslog.vim

  "_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  "
	" TODO move to ~/.vimrc.project or something
  " Temporary project-specific hacks to normalize messy problem-spaces:

  
  if has('gui')
    " Maximize window upon opening
    " au GUIEnter *.log simalt ~x
    " Run SAS on current .sas file:
    au BufNewFile,BufRead,BufEnter *.sas nmap ;z :!c:/Progra~1/SASIns~1/SAS/V8/sas.exe -sysin %<CR>:args %:r.lst %:r.log<CR>
  else
    " Run my execute SAS shell script in a terminal:
    " au BufNewFile,BufRead,BufEnter *.sas nmap ;z :!~/code/sas/sasrun %:p<CR>
    au BufNewFile,BufRead,BufEnter *.sas nmap ;z :!~/code/sas/sasrun2 "%:p"<CR>
  endif
  "_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

endif  " ! autocommands_loaded

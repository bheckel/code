<HTML>
<HEAD>
   <TITLE>99 Bottles of Beer on the Wall (A-C)</TITLE>
   <META NAME="Author" CONTENT="Tim Robinson">
</HEAD>
<BODY BACKGROUND="greenbar.gif" TEXT=#000000 BGCOLOR="#ffff00" LINK="#ff0000" VLINK="#007000" ALINK="#0077FF">
<UL>
<H2><A NAME="cpp">C++</A></H2>
<PRE>
// C++ version of 99 Bottles of beer
// programmer: Tim Robinson timtroyr@ionet.net
#include &lt;fstream.h&gt;

int main()
    {
    int bottles = 99;
    while ( bottles &gt; 0 )
        {
        cout &lt;&lt; bottles &lt;&lt; " bottle(s) of beer on the wall," &lt;&lt; endl;
        cout &lt;&lt; bottles &lt;&lt; " bottle(s) of beer." &lt;&lt; endl;
        cout &lt;&lt; "Take one down, pass it around," &lt;&lt; endl;
        cout &lt;&lt; --bottles &lt;&lt; " bottle(s) of beer on the wall." &lt;&lt; endl;
        }
    return 0;
    }
</PRE>
<P>
<i>This is how C++ is supposed to be used.</i>
<P>
<PRE>
// C++ version of 99 Bottles of Beer, object oriented paradigm
// programmer: Tim Robinson timtroyr@ionet.net
#include &lt;fstream.h>

enum Bottle { BeerBottle };

class Shelf {
    unsigned BottlesLeft;
public:
    Shelf( unsigned bottlesbought )
        : BottlesLeft( bottlesbought )
        {}
    void TakeOneDown()
        {
        if (!BottlesLeft)
            throw BeerBottle;
        BottlesLeft--;
        }
    operator int () { return BottlesLeft; }
    };

int main( int, char ** )
    {
    Shelf Beer(99);
    try {
        for (;;) {
            char *plural = (int)Beer !=1 ? "s" : "";
            cout &lt;&lt; (int)Beer &lt;&lt; " bottle" &lt;&lt; plural
                 &lt;&lt; " of beer on the wall," &lt;&lt; endl;
            cout &lt;&lt; (int)Beer &lt;&lt; " bottle" &lt;&lt; plural
                 &lt;&lt; " of beer," &lt;&lt; endl;
            Beer.TakeOneDown();
            cout &lt;&lt; "Take one down, pass it around," &lt;&lt; endl;
            plural = (int)Beer !=1 ? "s":"";
            cout &lt;&lt; (int)Beer &lt;&lt; " bottle" &lt;&lt; plural
                 &lt;&lt; " of beer on the wall." &lt;&lt; endl;
            }
        }
    catch ( Bottle ) {
        cout &lt;&lt; "Go to the store and buy some more," &lt;&lt; endl;
        cout &lt;&lt; "99 bottles of beer on the wall." &lt;&lt; endl;
        }
    return 0;
    }
</PRE>
<i>And one more version that may be called "abuse" by some, but here it is:</i>
<PRE>
// 99 bottles of beer, C++ template 'meta-programming' version
// By Arion Lei (philipl@cs.ust.hk)

#include &lt;iostream.h&gt;

template&lt;int I&gt;
class Loop {
public:
  static inline void f () {
    cout &lt;&lt; I &lt;&lt; " bottles of beer on the wall," &lt;&lt; endl
         &lt;&lt; I &lt;&lt; " bottles of beer." &lt;&lt; endl
         &lt;&lt; "Take one down, pass it around," &lt;&lt; endl
         &lt;&lt; I-1 &lt;&lt; " bottles of beer on the wall." &lt;&lt; endl;
    Loop&lt;I-1&gt;::f();
  } 
};

class Loop&lt;0&gt; {
public:
  static inline void f () {
    cout &lt;&lt; "Go to the store and buy some more," &lt;&lt; endl
         &lt;&lt; "99 bottles of beer on the wall." &lt;&lt; endl;
  }
};


int main () {
  Loop&lt;3&gt;::f();
  return 0;
}

</PRE>
<HR>
<H2><A NAME="cobol">COBOL</A></H2>
<PRE>
 IDENTIFICATION DIVISION.
 PROGRAM-ID.BOTTLES_OF_BEER.
 AUTHOR.DONALD FRASER.
*
 ENVIRONMENT DIVISION.
 CONFIGURATION SECTION.
 SOURCE-COMPUTER. VAX.
 OBJECT-COMPUTER. VAX.
*
 INPUT-OUTPUT SECTION.
 FILE-CONTROL.
        SELECT OUTPUT-FILE
                ASSIGN TO BEERS_ON_THE_WALL.
*
 DATA DIVISION.
 FILE SECTION.
 FD OUTPUT-FILE
        LABEL RECORDS ARE OMITTED.
 01 BEERS-OUT                                   PIC X(133).
*
 WORKING-STORAGE SECTION.
 01 FLAGS-COUNTERS-ACCUMULATORS.
        05 FLAGS.
                10 E-O-F                                PIC 9.
                        88 END-OF-FILE                VALUE 1.
        05 COUNTERS.
                10 BOTTLES                      PIC 999
                                                VALUE 0.
 01 RECORD-OUT.
        05 LINE1.
                10 NUMBER-OF-BEERS-1                    PIC ZZ9.
                10                                      PIC X(28)
                                VALUE "BOTTLES OF BEER IN THE WALL ".
                10                                                        PIC
X
                                VALUE ",".
                        10 NUMBER-OF-BEERS-2            PIC ZZ9.
                10                                                        PIC
X.
                10                                      PIC X(17)
                                VALUE "BOTTLES OF BEER.".
        05 LINE2.
                10                                              PIC X(34)
                                VALUE "TAKE ONE DOWN AND PASS IT ARROUND ".
                10 NUMBER-OF-BEERS-3            PIC ZZ9.
                10                                      PIC X.
                10                                      PIC X(28)
                                VALUE "BOTTLES OF BEER IN THE WALL".
*
 PROCEDURE DIVISION.
 DRIVER-MODULE.
      PERFORM INITIALIZATION.
      PERFORM PROCESS UNTIL END-OF-FILE.
      PERFORM TERMINATION.
      STOP RUN.
*
 INITIALIZATION.
        OPEN OUTPUT OUTPUT-FILE.
        ADD 100 TO BOTTLES.
*
 PROCESS.
         IF BOTTLES = 0 THEN
                COMPUTE E-O-F = 1
        ELSE PERFORM WRITE-ROUTINE
        END-IF.
*
 TERMINATION.
        CLOSE OUTPUT-FILE.
*
 WRITE-ROUTINE.
          MOVE BOTTLES TO NUMBER-OF-BEERS-1, NUMBER-OF-BEERS-2.
         COMPUTE BOTTLES = BOTTLES - 1.
         WRITE BEERS-OUT FROM LINE1.
         MOVE BOTTLES TO NUMBER-OF-BEERS-3.
        WRITE BEERS-OUT FROM LINE2.

</PRE>
<HR>
<H2><A NAME="c">C</A></H2>
<PRE>
/*
 * 99 bottles of beer in ansi c
 *
 * by Bill Wein: bearheart@bearnet.com
 *
 */

#define MAXBEER (99)

void chug(int beers);

main()
{
register beers;

for(beers = MAXBEER; beers; chug(beers--))
  puts("");

puts("\nTime to buy more beer!\n");

exit(0);
}

void chug(register beers)
{
char howmany[8], *s;

s = beers != 1 ? "s" : "";
printf("%d bottle%s of beer on the wall,\n", beers, s);
printf("%d bottle%s of beeeeer . . . ,\n", beers, s);
printf("Take one down, pass it around,\n");

if(--beers) sprintf(howmany, "%d", beers); else strcpy(howmany, "No more");
s = beers != 1 ? "s" : "";
printf("%s bottle%s of beer on the wall.\n", howmany, s);
}
</PRE>
<HR>
<H2><A NAME="ada">Ada</A></H2>
<PRE>
/* Ada version of 99 Bottles of Beer */
with TEXT_IO; use TEXT_IO;

procedure BOTTLES is
 package INT_IO is new INTEGER_IO (INTEGER);
 use INT_IO;

 COUNT : INTEGER := 99;

begin
    while COUNT &gt; 0 loop
        PUT (COUNT,WIDTH=>0);  PUT_LINE (" bottles of beer on the wall,");
        PUT (COUNT,WIDTH=>0);  PUT_LINE (" bottles of beer.");
        PUT_LINE ("Take one down and pass it around.");
        COUNT := COUNT - 1;
        if COUNT = 0 then
           PUT_LINE("No bottles of beer on the wall!");
        else
           PUT (COUNT,WIDTH=>0);  PUT_LINE (" bottles of beer on the wall.");
        end if;
        NEW_LINE;
    end loop;
end BOTTLES;
</PRE>
<i>I hesitate to include the following code, but it's what Ada was created for.</i>
<PRE>
-- Just for amusement, here's a multi-tasking version.
-- Ten customers enter bar to sing and drink.  Bartender serializes
-- access to 'take one down' to avoid fights
-- contributed by tmoran@bix.com
with Text_IO;
procedure Bar is

  Out_Of_Beer : Exception;

  protected Bartender is
    function Count return Integer;
    procedure Take_One_Down;
  private
    Remaining : Integer range 0 .. 99 := 99;
  end Bartender;

  protected body Bartender is
    function Count return Integer is
    begin return Remaining; end Count;

    procedure Take_One_Down is
    begin
      if Remaining = 0 then raise Out_Of_Beer;
      else Remaining := Remaining - 1;
      end if;
    end Take_One_Down;
  end Bartender;

  type Names is (Charles, Ada, John, Grace, Donald,
                 Edsger, Niklaus, Seymour, Fred, Harlan);

  task type Customers is
    entry Enter_Bar(Who : in Names);
  end Customers;

  Customer_List : array(Names) of Customers;

  task body Customers is
    Me : Names;
    procedure Sing_And_Drink(Singer_ID : in String) is
      procedure Sing(S : in String) renames Text_IO.Put_Line;
    begin
      loop
        declare
          Bottle_Part : constant String
            := Integer'image(Bartender.Count) & " bottles of beer";
        begin
          Sing(Bottle_Part & " on the wall" & Singer_ID);
          Sing(Bottle_Part & Singer_ID);
        end;
        Sing(" Take one down and pass it arround" & Singer_ID);
        Bartender.Take_One_Down;
        delay 10.0;  -- allow ten seconds to gulp one down
      end loop;
    exception
      when Out_Of_Beer => Sing("no more beer!" & Singer_ID);
    end Sing_And_Drink;
  begin -- customer task
    accept Enter_Bar(Who : in Names) do
      Me := Who;
    end Enter_Bar;
    Sing_And_Drink(" - " & Names'image(Me));
  end Customers;

begin -- operating bar

  for Person in Customer_List'range loop
    Customer_List(Person).Enter_Bar(Person);
    delay 2.0; -- allow two seconds between customers entering bar
  end loop;

end Bar;
</PRE>
<HR>
<H2><A NAME="cshell">C-Shell</A></H2>
<PRE>

#!/bin/csh

#
# C-Shell script version of 99 Bottles of Beer
#

set i = 100

while ($i &gt; 0)

  echo -n $i " bottles of beer on the wall"
  echo $i " bottles of beer......"

   set i = `expr $i - 1`

  echo -n "take one down pass it around, " $i
  echo "bottles of beer on the wall"

end
</PRE>
<P>
<i>--- A noteworthy alternative</i>
<P>
<PRE>
#!/bin/csh
# Version #2.1 C-Shell version of 99 Bottles of Beer
#
# overhauled 1997-19-3 by Ken Bateman (kbateman@esinet.net)
#
foreach i (9 8 7 6 5 4 3 2 1 " ")
  foreach j (9 8 7 6 5 4 3 2 1 0)
  if ( $i$j != "99" ) echo $i$j " bottles of beer on the wall"
  echo -n $i$j "bottles of beer on the wall, "
  echo $i$j "bottles of beer"
  echo -n "Take one down, pass it around..."
  end
end
echo "no more bottles of beer on the wall"
echo "No more bottles of beer on the wall, no more bottles of beer"
echo "Go to the store, buy some more,"
echo "99 bottles of beer on the wall"
#end of script
</PRE>
<HR>
<H2><A NAME="awk">AWK</A></H2>
<PRE>
#!/usr/bin/awk -f
#   awk version of 99 bottles of beer
#   by Whitey (whitey@netcom.com) - 06/05/95

BEGIN { 
   for(i = 99; i &gt; 0; i--) {
      print s = bottle(i), "on the wall,", s ","
      print "take one down, pass it around,"
      print bottle(i - 1), "on the wall."
   }
}

function bottle(n) {
   return sprintf("%s bottle%s of beer", n ? n : "no more", n - 1 ? "s" : "")
}
</PRE>
<HR>
<H2><A NAME="bourne">Bourne Shell</A></H2>
<PRE>
#!/bin/sh
# Bourne shell version of 99 Bottles
# Craig J Copi - copi@oddjob.uchicago.edu
#
if [ $# -eq 1 ]; then
	beers=$1
else
	beers=99
fi

s="s"

while [ $beers -gt 0 ]; do
	echo "$beers bottle$s of beer on the wall,"
	echo "$beers bottle$s of beer,"
	echo "take one down, pass it around,"
	beers=`expr $beers - 1`
	if [ $beers -ne 0 ]; then
		test $beers -eq 1 && s=""
		echo "$beers bottle$s of beer on the wall."
	else
		echo "no bottles of beer on the wall."
	fi
	echo
done

echo
echo "Time to buy some more beer . . . ."
</PRE>
<HR>
<H2><A NAME="commonlisp">Common Lisp</A></H2>
<PRE>
;; Bottles by Rebecca Walpole (walpolr@cs.orst.edu)
;; tested in Austin Kyoto Common Lisp version 1.615
;; Note: the ~p takes care of plurals.
;;
(defun bottles (n)
 "Prints the lyrics to '99 Bottles of Beer'"
(if (&lt; n 1)
    (format t "~%Time to go to the store.~%")
    (progn (format t "~% ~a bottle~:p of beer on the wall." n)
           (format t "~% ~a bottle~:p of beer." n)
           (format t "~% Take one down, pass it around.")
           (format t "~% ~a bottle~:p of beer on the wall.~%" (- n 1))
           (bottles (- n 1))
	   )
  )
)

(bottles 99)
</PRE>
<HR>
<H2><A NAME="aml">AML</A></H2>
<PRE>
/* AML (Arc Macro Language) version of 99 bottles of beer on the wall
/* Author prefers anonymity B-)
/*
 
&do number = 9 &to 1 &by -1
   /* handle the one bottle cases
   &if %number% = 1 &then
      &set noun1 = bottle
   &else 
      &set noun1 = bottles
   &if %number% = 2 &then
      &set noun2 = bottle
   &else 
      &set noun2 = bottles
 
   &type \%number% %noun1% of beer on the wall,
   &type %number% %noun1% of beer,
   &type Take one down, pass it around,
   &type [calc %number% - 1] %noun2% of beer on the wall
&end
&return
</PRE>
<HR>
<H2><A NAME="beta">Beta</A></H2>
<i><a href=http://www.mjolner.dk>Click</a> for information.</i>
<PRE>
ORIGIN '~beta/basiclib/v1.4/betaenv';
--- program: descriptor ---
(* 99 bottles in BETA. Ole Villumsen, October 27, 1995. *)
(# putBottles: (# no: @integer;
               enter no
               do (if no//1 then '1 bottle' -> putLine;
                  else no -> putInt; ' bottles' -> putText;
                  if);
               #);
do (for i:99 repeat
     100-i -> putBottles; ' of beer on the wall,' -> putLine;
     100-i -> putBottles; ' of beer.' -> putLine;
     'Take one down, pass it around,' -> putLine;
     99-1 -> putBottles; ' of beer on the wall.' -> putLine; newLine;
   for)
#)
</PRE>
<HR>
<H2><A NAME="clipper">Clipper</A></H2>
<PRE>
/* Tim Nason, 27 Oct 95 */

procedure beer
local nBeers := 99
    while .t.
        ?
        ? alltrim( str( nBeers ) ) + ' bottle' + iif( nBeers = 1, '', 's' ) + ;
             ' of beer on the wall.'
        ? alltrim( str( nBeers ) ) + ' bottle' + iif( nBeers-- = 1, '', 's' ) + ;
                ' of beer.'
        if nBeers &lt; 0
            ? "Go to the store and buy some more."
            nBeers := 99
            ? '99 bottles of beer on the wall.'
        else        
            ? 'Take one down, pass it around,'
            ? alltrim( str( nBeers ) ) + ' bottles of beer on the wall.'
        endif
    enddo
return
</PRE>
<HR>
<H2><A NAME="algol60">Algol 60</A></H2>
<PRE>
BEGIN
  FILE TERM(KIND=REMOTE,MYUSE=OUT);
  EBCDIC ARRAY OUTLINE[0:72];
  PROCEDURE BOTTLECOUNT(I,P);
  VALUE I; INTEGER I;
  POINTER P;
  BEGIN
    REPLACE P:P BY I FOR * DIGITS, " bottle",
        IF I NEQ 1 THEN "s " ELSE " ";
  END;
  POINTER OP;
  INTEGER BOTTLES;
  BOTTLES := 99;
  FOR BOTTLES := 99 STEP -1 UNTIL 1 DO BEGIN
    OP := OUTLINE;
    BOTTLECOUNT(BOTTLES,OP);
    REPLACE OP:OP BY "of beer on the wall,";
    WRITE(TERM,&lt;A72&gt;,OUTLINE);
    OP := OUTLINE;
    BOTTLECOUNT(BOTTLES,OP);
    REPLACE OP:OP BY "of beer,";
    WRITE(TERM,&lt;A72&gt;,OUTLINE);
    WRITE(TERM,<"You take one down and pass it around,">);
    OP := OUTLINE;
    BOTTLECOUNT(BOTTLES-1,OP);
    REPLACE OP:OP BY "of beer on the wall.";
    WRITE(TERM,&lt;A72&gt;,OUTLINE);
  END FOR;
END.

</PRE>
<HR>
<H2><A NAME="algol68">Algol 68</A></H2>
<PRE>
# 99 Bottles of Beer                         #
# by Otto Stolz &lt;Otto.Stolz@Uni-Konstanz.de&gt; #
( PROC width = (INT x) INT: (x>9 | 2 | 1)
; FOR i FROM 99 BY -1 TO 1
  DO  printf ( ( $ 2l n(width(i))d
                 , x "bottle" b("","s") x "of beer on the wall,"
                 , x n(width(i))d
                 , x "bottle" b("","s") x "of beer."
                 , l "Take one down, pass it around,"
                 , x n(width(i-1))d
                 , x "bottle" b("","s") x "of beer."
                 $
               , i  , i=1
               , i  , i=1
               , i-1, i=2
             ) )
  OD
)
</PRE>
<HR>
<H2><A NAME="apple">Apple Script</A></H2>
<PRE>
-- AppleScript version of "99 Bottles of Beer"
-- by Kristopher Johnson  kdj@mindspring.com

to createBottleString for aNumberOfBottles
    if aNumberOfBottles is 0 then
        return "No more bottles"
    else if aNumberOfBottles is 1 then
        return "1 more bottle"
    else
        return (aNumberOfBottles as string) & " bottles"
    end if
end createBottleString

set lyrics to ""
repeat with numberOfBottles from 99 to 1 by -1
    set bottleString to (createBottleString for numberOfBottles)
    set lyrics to lyrics & bottleString & " of beer on the wall, " & bottleString & " of beer.  " & return
    set lyrics to lyrics & "Take one down and pass it around, " & return
    set lyrics to lyrics & (createBottleString for (numberOfBottles - 1)) & " of beer on the wall.  " & return
end repeat
set lyrics to lyrics & "No more bottles of beer on the wall, no more bottles of beer." & return
set lyrics to lyrics & "Go to the store and buy some more." & return
set lyrics to lyrics & "99 bottles of beer on the wall."
return lyrics

</PRE>
<HR>
<H2><A NAME="apl">APL</A></H2>
<IMG src=apl.gif>
<HR>
<H2><A NAME="apl2">APL2</A></H2>
<IMG src=apl2.gif>
<HR>
<H2><A NAME="bcpl">BCPL</A></H2>
<PRE>
// BCPL version of 99 Bottles of Beer.
// hacked by Akira KIDA &lt;SDI00379@niftyserve.or.jp&gt;

GET "LIBHDR"

MANIFEST $(
    BOTTLES = 99
$)

LET START() BE $(
    LET BEERS(N, S) BE $(
        TEST N = 0 THEN WRITEF("No more bottles")
                   ELSE WRITEF("%N bottle%S", N, (N = 1) -> "", "s")
        WRITEF(" of beer%S", S)
    $)

    FOR I = BOTTLES TO 1 BY -1 DO $(
            BEERS(I, " on the wall, ")
            BEERS(I, ".*NTake one down, pass it around.*N")
            BEERS(I - 1, " on the wall.*N")
    $)
    FINISH
$)
</PRE>
<HR>
<H2><A NAME="concurrent">Concurrent Clean</A></H2>
<PRE>
//language Concurrent Clean - lazy pure functional
// Author: Jan Krynicky (jkry3025@comenius.mff.cuni.cz)
module beer
import StdEnv

//run with console and no constructors (don't want to make windows, menu ...)
Start = genbeer 99
 where
  genbeer 0 = ["No more bottles of beer on the wall.\n", //We are all drunk enough.
               "No more bottles of beer.\n",             //so sad!
               "Go to the store and buy some more.\n"    //If you can fin it.
              : genbeer 99]                              
              //Go on, let's drink forever.
  genbeer n = [sn+++" Bottle(s) of beer on the wall, "
               +++ sn +++ " bottle(s) of beer.\n",
               "Take one down and pass it around.\n",
               toString(n-1)+++ " bottle(s) of beer on the wall."
              :genbeer (n-1)]
   where
    ns = toString(n)

//end
</PRE>
<HR>
<H2><A NAME="caml">CAML</A></H2>
<I><a href=http://pauillac.inria.fr/caml/distrib-caml-light.html>More Informatin</a></i>
<PRE>
(* Caml Light version of 99 bottles of beer *)
(* Written by Bow-Yaw Wang (bywang@saul.cis.upenn.edu) *)
let rec bottles =
  function 1 -> print_string "1 bottle of beer on the wall, 1 bottle of beer\n";
                print_string "Take one down, pass it around,\n";
                print_string "no more bottles of beer on the wall\n"
         | n -> print_int n;
                print_string " bottles of beer on the wall, ";
                print_int n;
                print_string " bottles of beer\n";
                print_string "Take one down and pass it around,\n";
                print_int (n-1);
                print_string " bottles of beer on the wall\n";
                bottles (n-1)
in
   bottles 99;;
</PRE>
<HR>
<H2><A NAME="clu">CLU</A></H2>
<I></i>
<PRE>
% 99 bottles of beer in CLU by dcurtis@lcs.mit.edu

start_up = proc()
   po: stream := stream$primary_output()
   for i: int in int$from_to_by(99, 1, -1) do
      if i = 1 then
         stream$putl(po, int$unparse(i) || " bottle of beer on the wall")
         stream$putl(po, int$unparse(i) || " bottle of beer...")
      else
         stream$putl(po, int$unparse(i) || " bottles of beer on the wall")
         stream$putl(po, int$unparse(i) || " bottles of beer...")
      end
      stream$putl(po, "Take one down, pass it around...")
      end
   stream$putl(po, "\nTime to get more beer!")
   end start_up
</PRE>
<HR>
<H2><A NAME="clips">CLIPS</A></H2>
<i>Clips is available for Mac, Windows, Unix, and perhaps a few others.
Developed by NASA, and used as a language for AI and Knowledge Based Systems.</i>
<PRE>
;Written by Bill Ensinger (Bill222E@aol.com) on Saturday February 24, 1996
;8:00 - 9:41 pm Eastern Standard time at Taylor University.
;All praise to God; note that we just pass the beer, but don't drink!

(deftemplate beer
  (field ninetynine))

(deffacts bottles
  (beer (ninetynine 99)))


(defrule Bottlesninetynine ""
  (beer (ninetynine ?bottlenum))
  ?fl <- (beer (ninetynine ?bottlenum))
  (test (> ?bottlenum 2))
  =>
  (printout t ?bottlenum " bottles of beer on the wall," t)
  (printout t ?bottlenum " bottles of beer." t)
  (printout t "Take one down, pass it around," t)
  (printout t (- ?bottlenum 1) " bottles of beer on the wall." t)
  (printout t " " t)
  (modify ?fl (ninetynine =(- ?bottlenum 1)))
)
(defrule Bottlestwo ""
  (beer (ninetynine 2))
  ?fl <- (beer (ninetynine ?bottlenum))
  =>
  (printout t ?bottlenum " bottles of beer on the wall," t)
  (printout t ?bottlenum " bottles of beer." t)
  (printout t "Take one down, pass it around," t)
  (printout t (- ?bottlenum 1) " bottle of beer on the wall." t)
  (printout t " " t)
  (modify ?fl (ninetynine =(- ?bottlenum 1)))
)

(defrule Bottlesone ""
  (beer (ninetynine 1))
  ?fl <- (beer (ninetynine ?bottlenum))
  =>
  (printout t ?bottlenum " bottle of beer on the wall," t)
  (printout t ?bottlenum " bottle of beer." t)
  (printout t "Take one down, pass it around," t)
  (printout t "No more bottles of beer on the wall!" t)
)
</PRE>
<HR>
<H2><A NAME="amiga">Amiga Shell Script</A></H2>
<I>The original Amiga Shell script before REXX took over.</i>
<PRE>
.key num_bottles

set count <num_bottles$99>
set bword "bottles"

LAB LOOP

    echo $count $bword "of beer on the wall."
    echo $count $bword "of beer."
    echo "Take one down, pass it around."
    set count `eval $count - 1`
    if $count eq 1
       set bword "bottle"
    else
       set bword "bottles"
    endif
    echo $count $bword "of beer."
    echo ""

if $count gt 0
   skip LOOP BACK
endif
</PRE>
<HR>
<H2><A NAME="comal">COMAL</A></H2>
<I>Common Algorithmic Language.</i>
<PRE>
0010  // bottles of beer
0020
0030  FOR x# := 99 TO 1 STEP -1 DO
0040     bottles(x#, TRUE)
0050     bottles(x#, FALSE)
0060     PRINT "Take one down, pass it around."
0070     bottles(x#-1, FALSE)
0080  ENDFOR num
0090
0100  END
0110
0120  PROC bottles(num#, wall) CLOSED
0130     PRINT num#;
0140
0150     text$ := "bottle"
0160
0170     IF num# <> 1 THEN
0180        text$ := text$ + "s"
0190     ENDIF
0200
0210     PRINT text$," of beer";
0220
0230     IF wall = TRUE
0240        PRINT "on the wall";
0250     ENDIF
0260
0270     PRINT "."
0280  ENDPROC bottles
</PRE>
<HR>
<H2><A NAME="bourneagain">Bourne Again Shell</A></H2>
<I>The only possible explanation for the existence of
this shell in addition to the <A HREF=#bourne>Bourne shell</a>
is that programmers have no lives... if this web page wasn't
already proof.
</i>
<PRE>
#!/bin/bash
# Bourne Again shell version of 99 Bottles
# Dave Plonka - plonka@carroll1.cc.edu

typeset -i n=99
typeset bottles=bottles
typeset no

while [ 0 != $[ n ] ]
do
   echo "${n?} ${bottles?} of beer on the wall,"
   echo "${n?} ${bottles?} of beer,"
   echo "take one down, pass it around,"
   n=n-1
   case ${n?} in
   0)
      no=no
      bottles=${bottles%s}s
      ;;
   1)
      bottles=${bottles%s}
      ;;
   esac
   echo "${no:-${n}} ${bottles?} of beer on the wall."
   echo
done

exit
</PRE>
<HR>
<H2><A NAME="bs">BS</A></H2>
<i>Appears to be a combination of <a href=#basic>Basic</a>
and <a href=#snobol>Snobol</a> with a little <a href=#c>C</a> thrown in.</i>
<PRE>
#!/usr/bin/bs
# bs version of 99 Bottles
# Dave Plonka - plonka@carroll1.cc.edu
# Thu Aug  8 1996

fun sing(n, end) s
   s = ("s", "")[ match(n, "^1$") ]
   put = format(format(format("%s bottle%%s of beer%%%%s", n), s), end)
nuf

for n = 99, n, put = ""
   sing(format("%-0.0f", n), " on the wall,")
   sing(format("%-0.0f", n), ",")
   put = "take one down, pass it around,"
   --n
   sing((format("%-0.0f", n), "no")[ 0 == n ], " on the wall.")
next

run
exit
</PRE>
<HR>
<H2><A NAME="cl">CL</A></H2>
<i>A programming language for the IBM AS/400</i>
<PRE>
    PGM
    /*  99 Bottles of Beer in AS/400 CL (Command Language)           */
    /*  Programmer:  Werner Grzemba, 101326.3300@compuserve.com      */

    /*  To avoid the necessity of any user action, the output is     */
    /*  sent to the status line (except of the buy-request at end)   */

             DCL        VAR(&MSG) TYPE(*CHAR) LEN(79)
             DCL        VAR(&BEER1) TYPE(*CHAR) LEN(30) VALUE(' +
                          bottles of beer on the wall, ')
             DCL        VAR(&BEER2) TYPE(*CHAR) LEN(31) VALUE('Take +
                          one down, pass it around, ')
             DCL        VAR(&BEER3) TYPE(*CHAR) LEN(78) VALUE('Go +
                          to the store and by some more... 99 +
                          bottles of beer')
             DCL        VAR(&BOTTLES) TYPE(*DEC) LEN(2 0) VALUE(99)
             DCL        VAR(&XB) TYPE(*CHAR) LEN(2)
             DCL        VAR(&RPY) TYPE(*CHAR) LEN(4)

             CHGVAR     VAR(&XB) VALUE(&BOTTLES)

    MOREBEER:
             CHGVAR     VAR(&MSG) VALUE(&XB *CAT &BEER1 *CAT &XB +
                          *CAT %SST(&BEER1 1 16))
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&MSG) +
                          TOPGMQ(*EXT) MSGTYPE(*STATUS)
             DLYJOB     DLY(1)
             CHGVAR     VAR(&BOTTLES) VALUE(&BOTTLES - 1)
             CHGVAR     VAR(&XB) VALUE(&BOTTLES)
             CHGVAR     VAR(&MSG) VALUE(&BEER2 *CAT &XB *CAT +
                          %SST(&BEER1 1 28))
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&MSG) +
                          TOPGMQ(*EXT) MSGTYPE(*STATUS)
             DLYJOB     DLY(1)
             IF         COND(&BOTTLES > 0) THEN(GOTO CMDLBL(MOREBEER))

             CHGVAR     VAR(&MSG) VALUE('No more' *CAT &BEER1 *CAT +
                          'no more' *CAT %SST(&BEER1 1 16))
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&MSG) +
                          TOPGMQ(*EXT) MSGTYPE(*STATUS)
             DLYJOB     DLY(2)
             SNDPGMMSG  MSGID(CPF9898) MSGF(QCPFMSG) MSGDTA(&BEER3) +
                          TOPGMQ(*EXT) MSGTYPE(*INQ) KEYVAR(&RPY)

    ENDPGM

</PRE>
<HR>
<H2><A NAME="clist">CLIST</A></H2>
<i>An outdated IBM batch language.</i>
<PRE>
/* THIS IS WRITTEN IN CLIST - A IBM MVS/TSO BATCH LANGUAGE     
/* THIS LINE IS A COMMENT                                      
/* ALEX V FLINSCH SPARROWHAWK@WORLDNET.ATT.NET 
PROC 0                                                         
   SET BEER=99                                                 
A: WRITE &BEER BOTTLES OF BEER ON THE WALL                     
   WRITE &BEER BOTTLES OF BEER                                 
   WRITE TAKE ONE DOWN AND PASS IT AROUND                      
   SET BEER=&EVAL(&BEER-1)                                     
   IF &BEER ,= 0 THEN GOTO A                                   
   WRITE NO MORE BOTTLES OF BEER ON THE WALL                   
   WRITE NO MORE BOTTLES OF BEER                               
</PRE>
<HR>
<H2><A NAME="bc">BC</A></H2>
<i></i>
<PRE>
/* 99 bottles of beer in Unix bc                                          */
/* by Adam Roach <adam.roach@exu.ericsson.se>                             */
/*                                                                        */
/* In theory, this could be shortened by functions, but the version of    */
/* bc that I have access to doesn't allow functions... so this is long... */

i = 99
while ( i > 0 ) {
  if (i/10 == 1) "1"
  if (i/10 == 2) "2"
  if (i/10 == 3) "3"
  if (i/10 == 4) "4"
  if (i/10 == 5) "5"
  if (i/10 == 6) "6"
  if (i/10 == 7) "7"
  if (i/10 == 8) "8"
  if (i/10 == 9) "9"
  if (i%10 == 0) "0 bottle"
  if (i%10 == 1) "1 bottle"
  if (i%10 == 2) "2 bottle"
  if (i%10 == 3) "3 bottle"
  if (i%10 == 4) "4 bottle"
  if (i%10 == 5) "5 bottle"
  if (i%10 == 6) "6 bottle"
  if (i%10 == 7) "7 bottle"
  if (i%10 == 8) "8 bottle"
  if (i%10 == 9) "9 bottle"
  if (i != 1) "s"
  " of beer on the wall,
"
  if (i/10 == 1) "1"
  if (i/10 == 2) "2"
  if (i/10 == 3) "3"
  if (i/10 == 4) "4"
  if (i/10 == 5) "5"
  if (i/10 == 6) "6"
  if (i/10 == 7) "7"
  if (i/10 == 8) "8"
  if (i/10 == 9) "9"
  if (i%10 == 0) "0 bottle"
  if (i%10 == 1) "1 bottle"
  if (i%10 == 2) "2 bottle"
  if (i%10 == 3) "3 bottle"
  if (i%10 == 4) "4 bottle"
  if (i%10 == 5) "5 bottle"
  if (i%10 == 6) "6 bottle"
  if (i%10 == 7) "7 bottle"
  if (i%10 == 8) "8 bottle"
  if (i%10 == 9) "9 bottle"
  if (i != 1) "s"
  " of beer.
"
  i = i - 1 
  "Take one down, pass it around.
"
  if (i/10 == 1) "1"
  if (i/10 == 2) "2"
  if (i/10 == 3) "3"
  if (i/10 == 4) "4"
  if (i/10 == 5) "5"
  if (i/10 == 6) "6"
  if (i/10 == 7) "7"
  if (i/10 == 8) "8"
  if (i/10 == 9) "9"
  if (i%10 == 0) "0 bottle"
  if (i%10 == 1) "1 bottle"
  if (i%10 == 2) "2 bottle"
  if (i%10 == 3) "3 bottle"
  if (i%10 == 4) "4 bottle"
  if (i%10 == 5) "5 bottle"
  if (i%10 == 6) "6 bottle"
  if (i%10 == 7) "7 bottle"
  if (i%10 == 8) "8 bottle"
  if (i%10 == 9) "9 bottle"
  if (i != 1) "s"
  " of beer on the wall.

"
}
quit
</PRE>
<HR>
<H2><A NAME="abc">ABC</A></H2>
<i><a href=http://www.cwi.nl/cwi/projects/abc.html>ABC</a> was
developed at CWI in the Netherlands.</i>
<PRE>
PUT "by Whitey (whitey@netcom.com) - 10/13/96" IN author

HOW TO RETURN verse n:
   SELECT:
      n = 0:
         PUT "no more bottles of beer" IN s
      n = 1:
         PUT "1 bottle of beer" IN s
      ELSE:
         PUT "`n` bottles of beer" IN s
   RETURN s

HOW TO DRINK:
   PUT 99 IN num
   WHILE num > 0:
      WRITE verse num, " on the wall, ", verse num, "," /
      WRITE "take one down, pass it around," /
      PUT num - 1 IN num
      WRITE verse num, " on the wall." /

DRINK
</PRE>
<HR>
<H2><A NAME="bliss">Bliss</A></H2>
<i>There are two versions here: one is done procedurally, the second
is more in keeping with Bliss's style.</i>
<PRE>
module NINTY_NINE_BOTTLES (main=BOTTLES) =
!
!   "99 Bottles of Beer on the Wall"
!   using BLISS on DIGITAL's Alpha OpenVMS
!   by Ron Brender, brender@zko.dec.com
!
begin

forward routine
    BOTTLES	    : novalue,	    ! Main routine
    BOTTLE_S	    : novalue,	    ! 'bottle&lt;s&gt;'
    BOTTLE_COUNT    : novalue;	    ! &lt;n&gt; or 'no'

external routine
    printf	    : novalue	    external_name('DECC$GXPRINTF');
		    !
		    ! To "port" this program to UNIX or WNT, use
		    ! external_name('printf') or the appropriate lower case
		    ! compilation option instead of the above.
		      

macro
    PUT_TEXT(T) =
	printf(uplit(%asciz '%s'), uplit(%asciz T))
	%,
    PUT_INT(N) =
	printf(uplit(%asciz '%*d'), if N lss 10 then 1 else 2, N)
	%,
    PUT_NL (dummy) =
	printf(uplit(%asciz %string(%char(10))))
	%;

global routine BOTTLES : novalue =
    begin

    ! Title
    !
    PUT_NL();
    PUT_TEXT('        "99 Bottles of Beer on the Wall"'); PUT_NL();
    PUT_NL();

    decr I from 99 to 1 do
	begin

	! &lt;n&gt; bottle&lt;s&gt; of beer on the wall; &lt;n&gt; bottle&lt;s&gt; of beer
	!
	BOTTLE_COUNT(.I); PUT_TEXT(' '); BOTTLE_S(.I);
	    PUT_TEXT(' of beer on the wall; ');
	BOTTLE_COUNT(.I); PUT_TEXT(' '); BOTTLE_S(.I); PUT_TEXT(' of beer');
	    PUT_NL();

	! Take &lt;one|it&gt; down and pass it around
	!
	PUT_TEXT('Take ');
	if .I eql 1 then PUT_TEXT('it') else PUT_TEXT('one');
	PUT_TEXT(' down and pass it around'); PUT_NL();

	! &lt;n-1&gt; bottle&lt;s&gt; of beer on the wall
	!
	BOTTLE_COUNT(.I-1); PUT_TEXT(' '); BOTTLE_S(.I-1);
	    PUT_TEXT(' of beer on the wall'); PUT_NL();

	! New stanza
	!
	PUT_NL();

	end;

    end;

routine BOTTLE_S (COUNT) : novalue =
    begin

    PUT_TEXT('bottle');
    if .COUNT neq 1 then PUT_TEXT('s');

    end;

routine BOTTLE_COUNT (COUNT) : novalue =
    if .COUNT eql 0 then PUT_TEXT('No') else PUT_INT(.COUNT);

end
eludom
</PRE>
<i>Version #2</i>
<PRE>
module NINTY_NINE_BOTTLES_CT (main=BOTTLES) =
!
!   "99 Bottles of Beer on the Wall"
!   using BLISS on DIGITAL's Alpha OpenVMS
!   by Ron Brender, brender@zko.dec.com
!
begin

external routine
    printf	    : novalue	    external_name('DECC$GXPRINTF');
		    !
		    ! To "port" this program to UNIX or WNT, use
		    ! external_name('printf') or the appropriate lower case
		    ! compilation option instead of the above.
		      

macro
    PUT_TEXT(T) =
	printf(uplit(%asciz '%s'), uplit(%asciz T))
	%,
    PUT_NL (dummy) =
	printf(uplit(%asciz %string(%char(10))))
	%;

compiletime
    TEMP = 0;

! In principle, the complete text can be constructed at compile-time and
! output with a single PUT_TEXT call, however, that runs up against a
! compile-time maximum string length. This implementation constructs a
! complete stanza at compile-time.
!
macro
    BOTTLE_S(COUNT) =
	%if COUNT eql 1 %then 'bottle' %else 'bottles' %fi
	%,

    BOTTLE_COUNT(COUNT) =
	%assign(TEMP, COUNT)
	%if TEMP eql 0 %then 'No' %else %string(%number(TEMP)) %fi
	%,

    BOTTLE_STANZA(COUNT) =
	PUT_TEXT(%string(
	    BOTTLE_COUNT(COUNT), ' ', BOTTLE_S(COUNT),
		' of beer on the wall; ',
	    BOTTLE_COUNT(COUNT), ' ', BOTTLE_S(COUNT), ' of beer', %char(10),
	    'Take one down and pass it around', %char(10),
	    BOTTLE_COUNT(COUNT-1), ' ', BOTTLE_S(COUNT-1),
		' of beer on the wall', %char(10),
	    %char(10)))
	%,

    BOTTLE_TEXT(COUNT)[] =
	BOTTLE_STANZA(COUNT);
	%if COUNT gtr 1 %then
	    BOTTLE_TEXT(COUNT - 1)
	    %fi
	%;

global routine BOTTLES : novalue =
    begin

    ! Title
    !
    PUT_NL();
    PUT_TEXT('        "99 Bottles of Beer on the Wall"'); PUT_NL();
    PUT_NL();

    BOTTLE_TEXT(99);

    end;

end
eludom
</PRE>
<HR>
<H2><A NAME="calc">calc</A></H2>
<i></i>
<PRE>
/*
 * 99 bottles of beer
 *
 * See:
 *      http://reality.sgi.com/csp/ioccc/noll/noll.html#calc
 */

for (i=99; i > 0;) {
    /* current wall state */
    some_bottles = (i != 1) ? "bottles" : "bottle";
    print i, some_bottles, "of beer on the wall,",;
    print i, some_bottles, "of beer!";

    /* glug, glug */
    --i;
    print "Take one down and pass it around,",;

    /* new wall state */
    less = (i > 0) ? i : "no";
    bottles = (i!=1) ? "bottles" : "bottle";
    print less, bottles, "of beer on the wall!\n";
}
</PRE>
<HR>
<H2><A NAME="bobo">Bobo</A></H2>
<i>The author (below) created the language.  "Bobo" is Spanish for
idiot.  Good enough description for a computer in general if you
ask me. </i>
<PRE>
## 99.bb v1.2
## Bayard W. Wenzel

# some handy macros

/nprint {"\n" add print} def
/space {"\n" print} def
/dec {dup get 1 sub def} def
/class-define {{get invoke} bind pop-dict} def

# i will use the bobo object protocol! it is cool.

/new-bar {
  13 /bar-dict create-dict

  /count 0 def
  /lyric-type "I'm a computer, I can't decide what to say," def

  /set-count {/count exch def} def
  /set-lyric-type {/lyric-type exch def} def

  # proper grammar counts

  /bottle-thing {
    /i exch rdef

    i 1 eq {
      i " bottle" add print
    } {
      i " bottles" add print
    } if-else
  } def

  # and, the meat of it!

  /beer-lyrics {
    /i exch rdef

    i bottle-thing " of beer on the wall," nprint
    i bottle-thing " of beer!" nprint
    lyric-type nprint
    i 1 sub bottle-thing " of beer on the wall." nprint space
  } def

  /final-lyrics {
     "0 bottles of beer on the wall," nprint
     "0 bottles of beer." nprint
     "Go into town, buy a new round," nprint
     "Get some more bottles of beer on the wall!" nprint
  } def

  /consume {
    count {
      count beer-lyrics
      /count dec
    } {
      final-lyrics
    } if-else
  } def

  class-define
} def

/song {
  /lyric-type exch rdef
  /count exch rdef

  /bar new-bar rdef

  count /set-count bar
  lyric-type /set-lyric-type bar  

  count 1 add {/consume bar} loop
} def

/messy "If one of those bottles should happen to fall," def
/thirsty "Take one down, pass it around," def

99 thirsty song
</PRE>
<HR>
<H2><A NAME="chill">Chill/2</A></H2>
<i></i>
<PRE>
io: MODULE
/*
  The CHILL/2 compiler I use has no VARYING strings.
  To tackle this inconvenience, I declare a record with variants..
*/

  GRANT String, nul, OutS, OutL, OutC, OutI;

  NEWMODE String = STRUCT(CASE OF
    :s9  CHAR(9),
    :s11 CHAR(11),
    :s13 CHAR(13),
    :s16 CHAR(16),
    :s31 CHAR(31)
    ESAC
  );

  SYN nul = C'00';

  OutS: PROC(s String LOC); END OutS;
  OutL: PROC(); END OutL;
  OutC: PROC(c CHAR); END OutC;
  OutI: PROC(i INT); END OutI;

END io;

beer: MODULE /* jr_31jan97 */

  SEIZE String, nul, OutC, OutS, OutI, OutL <> USING io;

  bottles: PROC(n INT, wall BOOL, end CHAR);
    DCL s String;
    IF n>1 THEN OutI(n); s.s9:=' Bottles'//nul;
    ELSIF n=1 THEN s.s11:='one Bottle'//nul;
    ELSIF n=0 THEN s.s16:='no more Bottles'//nul;
    FI;
    OutS(s); s.s9:=' of Beer'//nul; OutS(s);
    IF wall THEN s.s13:=' on the Wall'//nul; OutS(s); FI;
    OutC(end); OutL();
  END bottles;

  singTheSong: PROC();
    DCL i INT, s String;
    DO FOR i:=99 DOWN TO 1;
      bottles(i, TRUE, ',');
      bottles(i, FALSE, '.');
      s.s31:='Take one down, pass it around,'//nul; OutS(s); OutL();
      bottles(i-1, TRUE, '.');
    OD;
  END singTheSong;

END beer;
</PRE>
<HR>
<H2><A NAME="abundance">Abundance</A></H2>
<PRE>
\ Abundance version of 99 bottles of beer   RG 2.0/1.0  97/03/08
                                                                
&lt;&lt;&lt;DEFINE 1 99 SMALL All-Bottles DEFINE&gt;&gt;&gt;

&lt;&lt;&lt; Bottles ( count -- ) DUP WRITE
    CASE 0 OF DROP " No more bottles " ENDOF
         1 OF DROP " 1 bottle "        ENDOF
    OTHERS OF   .  " bottles "         ENDOF ENDCASE &gt;&gt;&gt;

&lt;&lt;&lt; Sing 
   WRITE                                           
   &lt;&lt;&lt;RFOR All-Bottles
       I Bottles " of beer on the wall, "
       I Bottles " of beer" NL
       " Take one down and pass it around," NL
       I 1- Bottles " of beer on the wall." 2 NLS 
   RFOR&gt;&gt;&gt; &gt;&gt;&gt;                                                  
</PRE>
<HR>
<H2><A NAME="aplus">A+</A></H2>
<i>A+ is a hybrid of APL and C,
developed primarily by Arthur Whitney amd Jeff Birnbaum, and is used
at the investment bank Morgan Stanley.</i>
<PRE>
$mode uni
// Usage: fallsong n for "American" verison starting at n bottles.
//        takesong n for "British" version 
//        eM n - general utility which returns english version of n.
// Note: Definition of billion, trillion, etc. follow American usage.
// Limits: Some counting and reporting problems caused by comparison
// tolerance and floating-point numbers above one trillion.
// Absolute limit: Approximately 9.9998354e65, at which point
// floating-point representation becomes unreliable.

ewd1:=("zero";"one";"two";"three";"four";"five";"six";"seven";"eight";"nine";
  "ten";"eleven";"twelve";"thirteen";"fourteen";"fifteen";"sixteen";
  "seventeen";"eighteen";"nineteen")
ewd10:=("";"";"twenty";"thirty";"forty";"fifty";"sixty";"seventy";
  "eighty";"ninety"); ewdh:=" hundred"; ewdc:=" and ";
epow:=("";" thousand")," ",~("m";"b";"tr";"quadr";"quint";"sext";"sept";
  "oct";"non";"dec";"undec";"duodec";"tredec";"quattuordec";"quindec";
  "sexdec";"septendec";"octodec";"novemdec";"vigint"),~&lt;"illion"
eH n:{if(20&lt;=n){(t;xx):=0 10 M.&gt;n;(t I.&gt;ewd10),if(0=xx)""else "-",xx I.&gt;ewd1}
  else n I.&gt; ewd1}
eT n:{if(100&lt;=n){(h;x):=0 100 M.&gt;n;(h I.&gt;ewd1),ewdh,if(0=x)""else ewdc,eH x}
  else eH n}
eM n:{z:="";(i:=#epow)do{
  (n;x):=0 1000 M.&gt;n;
  if(0!=x)z:=,(((100&gt;x)&(i=0)&0!=n)/"and "),(eT M.-x),(i I.&gt;epow),
    ((0!=#z)/", "),z;
  if(0=n):=z};z}
cap str:{n:=`int|1 S.+str;if((97&lt;=n)&122&gt;=n)str[0]:=`char|n- 32;str}
nb n:(if(0!=n)(cap eM n)else "No more"),((- 1=n)S.-" bottles")," of beer"
ootb n:if(1!=n)"one of those bottles"else"that bottle"
fate{b;n}:{if(b)".\nIf ",(ootb n)," should happen to fall,\n" else 
  ".\nTake ",((1=n)I.&gt;("one";"it"))," down; pass it around,\n"}
b stanza n:{w:=" on the wall.";
  (nb n),w,"\n",(nb n),(b fate n),(nb n- 1),w,"\n"}
fallsong n:{(i:=n)do S.- 1 stanza n-i;}
takesong n:{(i:=n)do S.- 0 stanza n-i;}
</PRE>
<HR>
<H2><A NAME="blank">Blank</A></H2>
<i>This is a custom language project.  The compiler is available at 
<a href=http://www.sound.net/~aturley/blank.htm>http://www.sound.net/~aturley/blank.htm</a></i>
<PRE>
99 Bottles of Beer
Written in Blank
by Andrew Turley

[99] bottles of beer
{#} pop the last calling cell
[20]{>} call "x bottles of beer on the wall,"
[65]{>} call "x bottles of beer."
[98]{>} call "Take one down, pass it around,"
{:}[1]{-}{!}[7]{\}{|} if bottles of beer is not 1
[124]{>} call "x-1 bottles of beer on the wall!"
{?}[19]{-}{>} go back to the beginning of the program

[157]{>} otherwise goto "No bottles of beer on the wall!"

"x bottles of beer on the wall," :36+11
{:}{.} print bottles of beer
[0] string termination
[10] "\n"
[44][108][108][97][119][32][101][104][116][32][110][111][32] ",llaw
eht no " [114][101][101][98][32][102][111][32] "reeb fo "
[24]{^}[1]{-}[4]{\}{!}{|} [115] "s" [1]{>}{#}
[101][108][116][116][111][98][32] "elttob " [34]{>} call the printing
part of the program {<} return to calling cell

"x bottles of beer." :24+11
{:}{.} print bottles of beer
[0] string termination
[10] "\n"
[46][114][101][101][98][32][102][111][32] ".reeb fo "
[12]{^}[1]{-}[4]{\}{!}{|}
[115] "s"
[1]{>}{#}
[101][108][116][116][111][98][32] "elttob "
[34]{>} call the printing part of the program
{<} return to calling cell

"Take one down, pass it around" :35
[0] string termination
[10] "\n"
[44][100][110][117][111][114][97][32][116][105][32] ",dnuora ti "
[115][115][97][112][32][44][110][119][111][100][32] "ssap ,nwod "
[101][110][111][32][101][107][97][84] "eno ekaT" [38]{>} goto the
printing part of the program {<} return to calling cell

"x-1 bottles of beer on the wall!" :38
[1]{-}{:}{.} (print bottles of beer)-1
[0] string termination
[10] "\n"
[10] "\n"
[33][108][108][97][119][32][101][104][116][32][110][111][32] "!llaw
eht no " [114][101][101][98][32][102][111][32] "reeb fo "
[115][101][108][116][116][111][98][32] "selttob " [38]{>} goto the
printing part of the program {<} return to calling cell


"No bottles of beer on the wall!", terminating part of program :36 [0]
string termination [10] "\n"
[33][108][108][97][119][32][101][104][116][32][110][111][32] "!llaw
eht no " [114][101][101][98][32][102][111][32] "reeb fo "
[115][101][108][116][116][111][98][32][111][78] "selttob oN" [9]{>}
goto the printing part of the program {@} exit program

printing part of the program :13

{:}[7]{\}{!}{|}{#}{,}{?}[10]{-}{>} print the top of the stack until 0
{#} ppop the call {#} ppop the if {$} pop the 0 {<} return to calling
cell</PRE>
<HR>
<H2><A NAME="asp">ASP</A></H2>
<i>Microsoft's Active Server Pages language (called VBScript),
meant to be embedded in HTML documents.</i>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;99 Bottles of Beer&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;!-- Microsoft ASP (Active Server Pages) listing by Vince Curley
(vincec@microsoft.com) --&gt;
&lt;%
	n = 99
	do
		str = n & " bottle"
		if n &lt;&gt; 1 then str = str & "s"
		str = str & " of beer"
		Response.Write str & " on the wall...&lt;BR&gt;"
		Response.Write str & "!&lt;BR&gt;"
		Response.Write "Take one down, pass it around...&lt;BR&gt;"
		n = n - 1
		if n &gt; 0 then
			str = n
		else
			str = "No "
		end if
		str = str & " bottle"
		if n &lt;&gt; 1 then str = str & "s"
		str = str & " of beer on the wall!&lt;BR&gt;"
		Response.Write str
		Response.Write "&lt;BR&gt;"
	loop while n &gt; 0
	Response.Write "&lt;FONT SIZE=7&gt;&lt;STRONG&gt;Buy more
beer!&lt;/STRONG&gt;&lt;/FONT&gt;"
%&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
<HR>
<H2><A NAME="cpreprocess">C/C++ Preprocessor</A></H2>
<i>This is the pre-processor for C or C++.  Normally, not a language in itself,
but created to make using C/C++ easier.  This is a novel use of the pre-processor</i>
<PRE>
-- BEER.CPP ---------------------------------------------------------
// 99 Bottles written entirely in Visual C++ preprocessor directives.
// By Wim Rijnders.
#pragma warning(disable : 4005 )

#define BOTTLES "bottles"
#define TAKE_ONE_DOWN "Take one down, pass it around,"
#define DEC_NUM 9
#define DEC_STR "9"
#define DEC2_NUM 9
#define DEC2_STR "9"

#define TEST_BOTTLES(a,b) (DEC2_NUM == a  && DEC_NUM == b )
#define STILL_HAVE__BOTTLES !TEST_BOTTLES(0,0)
#define NO_MORE__BOTTLES TEST_BOTTLES(0,0)
#define JUST_ONE__BOTTLE TEST_BOTTLES(0,1)

#define OF_BEER DEC2_STR DEC_STR " " BOTTLES " of beer"
#define BEER_ON_WALL OF_BEER " on the wall"

#include "sing.h"
-- SING.H -----------------------------------------------------------
//Following to beat the 32-file include limit of VC
#if STILL_HAVE__BOTTLES
	#include "stanza.h"               
	#include "stanza.h"               
	#include "stanza.h"               
	#include "stanza.h"               
	#include "sing.h"               
#endif 
-- STANZA.H ---------------------------------------------------------
#if STILL_HAVE__BOTTLES
	#pragma message(BEER_ON_WALL ",")
	#pragma message(OF_BEER ",")
	#pragma message(TAKE_ONE_DOWN)
	
	#include "dec.h"         
	#if NO_MORE__BOTTLES
		#define DEC2_STR ""
		#define DEC_STR "No more"
	#endif	
	
	#if JUST_ONE__BOTTLE
		#define BOTTLES "bottle"
	#else
		#define BOTTLES "bottles"	
	#endif
	
	#pragma message(BEER_ON_WALL ".")
	#pragma message("")
#endif 
-- DEC.H ------------------------------------------------------------
#if DEC_NUM == 9
	#define DEC_NUM 8
	#define DEC_STR "8"
#elif DEC_NUM == 8
	#define DEC_NUM 7
	#define DEC_STR "7"
#elif DEC_NUM == 7
	#define DEC_NUM 6
	#define DEC_STR "6"
#elif DEC_NUM == 6
	#define DEC_NUM 5
	#define DEC_STR "5"
#elif DEC_NUM == 5
	#define DEC_NUM 4
	#define DEC_STR "4"
#elif DEC_NUM == 4
	#define DEC_NUM 3
	#define DEC_STR "3"
#elif DEC_NUM == 3
	#define DEC_NUM 2
	#define DEC_STR "2"
#elif DEC_NUM == 2
	#define DEC_NUM 1
	#define DEC_STR "1"
#elif DEC_NUM == 1
	#define DEC_NUM 0
	#define DEC_STR "0"
#elif DEC_NUM == 0    
	#include "dec2.h"
	#define DEC_NUM 9
	#define DEC_STR "9"
#endif   
-- DEC2.H -----------------------------------------------------------
#if DEC2_NUM == 9
	#define DEC2_NUM 8
	#define DEC2_STR "8"
#elif DEC2_NUM == 8
	#define DEC2_NUM 7
	#define DEC2_STR "7"
#elif DEC2_NUM == 7
	#define DEC2_NUM 6
	#define DEC2_STR "6"
#elif DEC2_NUM == 6
	#define DEC2_NUM 5
	#define DEC2_STR "5"
#elif DEC2_NUM == 5
	#define DEC2_NUM 4
	#define DEC2_STR "4"
#elif DEC2_NUM == 4
	#define DEC2_NUM 3
	#define DEC2_STR "3"
#elif DEC2_NUM == 3
	#define DEC2_NUM 2
	#define DEC2_STR "2"
#elif DEC2_NUM == 2
	#define DEC2_NUM 1
	#define DEC2_STR "1"
#elif DEC2_NUM == 1
	#define DEC2_NUM 0
	#define DEC2_STR ""
#endif                    
</PRE>
<HR>
<H2><A NAME="brainfuck">Brainf***</A></H2>
<i>Yes, it's a dirty word.  An explanation and an interpreter
of this can be found at <a href=http://www.cats-eye.com/cet/soft/lang>
http://www.cats-eye.com/cet/soft/lang</a>.
</i>
<PRE>
>+++++++++[<+++++++++++>-]<[>[-]>[-]<<[>+>+<<-]>>[<<+>>-]>>>
[-]<<<+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>>+<
-]<<-<-]+++++++++>[<->-]>>+>[<[-]<<+>>>-]>[-]+<<[>+>-<<-]<<<
[>>+>+<<<-]>>>[<<<+>>>-]>[<+>-]<<-[>[-]<[-]]>>+<[>[-]<-]<+++
+++++[<++++++<++++++>>-]>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-
]<<<<<<.>>[-]>[-]++++[<++++++++>-]<.>++++[<++++++++>-]<++.>+
++++[<+++++++++>-]<.><+++++..--------.-------.>>[>>+>+<<<-]>
>>[<<<+>>>-]<[<<<<++++++++++++++.>>>>-]<<<<[-]>++++[<+++++++
+>-]<.>+++++++++[<+++++++++>-]<--.---------.>+++++++[<------
---->-]<.>++++++[<+++++++++++>-]<.+++..+++++++++++++.>++++++
++[<---------->-]<--.>+++++++++[<+++++++++>-]<--.-.>++++++++
[<---------->-]<++.>++++++++[<++++++++++>-]<++++.-----------
-.---.>+++++++[<---------->-]<+.>++++++++[<+++++++++++>-]<-.
>++[<----------->-]<.+++++++++++..>+++++++++[<---------->-]<
-----.---.>>>[>+>+<<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>>+++
+[<++++++>-]<--.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.
><+++++..--------.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++
++++++++++++.>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<++
+++++++>-]<--.---------.>+++++++[<---------->-]<.>++++++[<++
+++++++++>-]<.+++..+++++++++++++.>++++++++++[<---------->-]<
-.---.>+++++++[<++++++++++>-]<++++.+++++++++++++.++++++++++.
------.>+++++++[<---------->-]<+.>++++++++[<++++++++++>-]<-.
-.---------.>+++++++[<---------->-]<+.>+++++++[<++++++++++>-
]<--.+++++++++++.++++++++.---------.>++++++++[<---------->-]
<++.>+++++[<+++++++++++++>-]<.+++++++++++++.----------.>++++
+++[<---------->-]<++.>++++++++[<++++++++++>-]<.>+++[<----->
-]<.>+++[<++++++>-]<..>+++++++++[<--------->-]<--.>+++++++[<
++++++++++>-]<+++.+++++++++++.>++++++++[<----------->-]<++++
.>+++++[<+++++++++++++>-]<.>+++[<++++++>-]<-.---.++++++.----
---.----------.>++++++++[<----------->-]<+.---.[-]<<<->[-]>[
-]<<[>+>+<<-]>>[<<+>>-]>>>[-]<<<+++++++++<[>>>+<<[>+>[-]<<-]
>[<+>-]>[<<++++++++++>>>+<-]<<-<-]+++++++++>[<->-]>>+>[<[-]<
<+>>>-]>[-]+<<[>+>-<<-]<<<[>>+>+<<<-]>>>[<<<+>>>-]<>>[<+>-]<
<-[>[-]<[-]]>>+<[>[-]<-]<++++++++[<++++++<++++++>>-]>>>[>+>+
<<-]>>[<<+>>-]<[<<<<<.>>>>>-]<<<<<<.>>[-]>[-]++++[<++++++++>
-]<.>++++[<++++++++>-]<++.>+++++[<+++++++++>-]<.><+++++..---
-----.-------.>>[>>+>+<<<-]>>>[<<<+>>>-]<[<<<<++++++++++++++
.>>>>-]<<<<[-]>++++[<++++++++>-]<.>+++++++++[<+++++++++>-]<-
-.---------.>+++++++[<---------->-]<.>++++++[<+++++++++++>-]
<.+++..+++++++++++++.>++++++++[<---------->-]<--.>+++++++++[
<+++++++++>-]<--.-.>++++++++[<---------->-]<++.>++++++++[<++
++++++++>-]<++++.------------.---.>+++++++[<---------->-]<+.
>++++++++[<+++++++++++>-]<-.>++[<----------->-]<.+++++++++++
..>+++++++++[<---------->-]<-----.---.+++.---.[-]<<<]
</PRE>
<HR>
<H2><A NAME="aspect">Aspect</A></H2>
<i></i>
<PRE>
; ASPECT version of 99 Bottles of beer
; (aspect is the scripting language of PROCOMM PLUS)
; This program requires Procomm Plus version 2.0
; programmer: Michael LaGrasta lagrasta@zimage.com
proc main
integer bottles
string szVerse_a
string szVerse_b
string szChorus
string szTemp_a
string szTemp_b
bottles = 99
szVerse_a = " bottles of beer"
szVerse_b = " on the wall"
szChorus = "Take one down and pass it around"
numtostr bottles szTemp_a
numtostr bottles szTemp_b
strcat szTemp_a szVerse_a
strcat szTemp_a szVerse_b
termwrites szTemp_a
termwritec 0x0d
termwritec 11
strcat szTemp_b szVerse_a
termwrites szTemp_b
termwritec 0x0d
termwritec 11
termwrites szChorus
termwritec 0x0d
termwritec 11
szTemp_a = ""
bottles = bottles - 1
numtostr bottles szTemp_a
strcat szTemp_a szVerse_a
strcat szTemp_a szVerse_b
termwrites szTemp_a
termwritec 0x0d
termwritec 11
termwritec 0x0d
termwritec 11
szTemp_a = ""
szTemp_b = ""
while bottles > 2
  numtostr bottles szTemp_a
  numtostr bottles szTemp_b
  strcat szTemp_a szVerse_a
  strcat szTemp_a szVerse_b
  termwrites szTemp_a
  termwritec 0x0d
  termwritec 11
  strcat szTemp_b szVerse_a
  termwrites szTemp_b
  termwritec 0x0d
  termwritec 11
  termwrites szChorus
  termwritec 0x0d
  termwritec 11
  szTemp_a = ""
  bottles = bottles - 1
  numtostr bottles szTemp_a
  strcat szTemp_a szVerse_a
  strcat szTemp_a szVerse_b
  termwrites szTemp_a
  termwritec 0x0d
  termwritec 11
  termwritec 0x0d
  termwritec 11
  szTemp_a = ""
  szTemp_b = ""
endwhile
termwrites "1 bottle of beer on the wall ?!?!"
termwritec 0x0d
termwritec 11
termwrites "Uh oh! LAST BOTTLE!"
termwritec 0x0d
termwritec 11
termwrites "I ain't passin' this one around!"
termwritec 0x0d
termwritec 11
termwrites "AAAAAAAAAAAAA!!! No more beer!!!"
termwritec 0x0d
termwritec 11
endproc
</PRE>
<HR>
<H2><A NAME="cdcnosccl">CDC NOS CCL</A></H2>
<i>Contributed by Valerie Harris (valerie@grin.net)
with a little help from my friends
<P>
CDC = Control Data Corporation
<BR>NOS = Network Operating System
<BR>CCL = Cyber Control Language
<P>
It's the operating system control language of the cyber machine.
</i>
<PRE>
.PROC,DRV99*I,
COUNT = (*N=10,*F).
.HELP.
THIS PROC READS ARGUMENT COUNT, AND INITIALIZES
REGISTER COUNTER TO THAT VALUE.
THEN THIS PROC LOOPS FOR THAT MANY COUNTS, DECREMENTING
THE REGISTER COUNTER EVERY LOOP.  DURING THE LOOP THIS PROC
CALLS PRN99 WHICH PRINTS MESSAGE FOR THAT COUNT
.HELP,COUNT.
THIS IS THE INITITAL COUNT, THE COUNT FROM WHICH TO DECREMENT.
.ENDHELP
.IF,NUM(COUNT),QUIT.
SET,R1=COUNT.
SET,R2=0.
WHILE,R1.GT.R2,LOOP.
BEGIN,PRN99,DRV99,R1.
SET,R1=R1-1.
ENDW,LOOP.
NOTE./NO BOTTLES OF BEER ON THE WALL
REVERT,NOLIST.
.ENDIF,QUIT.
REVERT,ABORT.  NONNUMERIC PASSES
.PROC,PRN99*I,COUNT=(*N=10,*F).
.SET,K9=STRD(COUNT).
NOTE./K9 BOTTLES OF BEER ON THE WALL
NOTE./K9 BOTTLES OF BEER
NOTE./TAKE ONE DOWN, AND PASS IT AROUND/
REVERT,NOLIST.
</PRE>
<HR>
<H2><A NAME="befunge">Befunge</A></H2>
<i></i>
<PRE>
----- begin beer.bf -----
v v0\1:\1:\0\0\!:p15-<     Bottles of Beer for Befunge
0 \ {befunge} >" ekaT">v   written by Brian Raiter, 5/97
0>>.0"llaw eht no "v<#,:   breadbox@muppetlabs.com
"\,     >"eno"^>0 #"^1^_v
c1,>51g#^_"ti"^. >vr :  $
"::^" down, pass "<e    5
>^|\*25,<^     # i e ^g1< 
  ,>052*":dnuor t"vbv:<
v0_^    .      , ^< " "
>52*".ll"v   >,^   fb e
v<v<v_$!|>"aw eht no r"v
""" ,:  >" ;"^      f ^<@
meo >^"bottle"<    "o   $
o m^"re:"<v  _^#g15<  v_^
s""  >52*^>"s"^v"les"<,:
"^<  ^"99 bott"<    >^>^<
>" yub ,erots eht ot oG"^
------ end beer.bf ------
</PRE>
<HR>
<H2><A NAME="befdc">Befdc</A></H2>
<i>Sam has too much time on his hands.  This was created partially to frustrate
a programming instructor (not that that isn't a worthy goal) and 99BoB was
used to test the language constructs.  It's a combination of <a href=#befunge>Befunge</a>
and a desk calculator.  Details at <a href=http://www.cs.su.oz.au/~sholden/BefDC>
http://www.cs.su.oz.au/~sholden/BefDC</a></i>
<PRE>
>9999*++000s1100sXv<     >#v100g5-v
X              >100g3-   |v       _@
               |-2g001_ v
v *39s1010pg000  s0012-#<  <
vv*35s1010pg000<      1
v##      *47s1011s0014g# <
v*35s1010<Xs000-1g000s0011<
X>3100sv              0
^      <              1
                      ^
{
000              >         x
v        s100+1g100   <
>001g101g9gp001g201g -|
s                     0
1                     0
0                     0
2        xv#    <     1
^         >000v       s
          v0pg<       P
          0           x
          g
         ^_5100s^
{
100 bottles of beer.
{
In BefDC - a derivative of Befudge and dc, by Sam Holden
{
This code by Sam Holden, 1997.
{
Note: this language was actually designed to do my cryptography assigments,
      which is why it is defined with 'infinite' precision math.
{
{
{
{
 bottles of beer on the wall
Take one down, pass it around
</PRE>
<HR>
<H2><A NAME="al">AL</A></H2>
<i>AL is used in Navision, which is a financial program.</i>
<PRE>
bottles := 99;
OPENWINDOW('##1# bottles of beer on the wall \'+
          '##1# bottles of beer on the wall');
UPDATEWINDOW(1,bottles);
REPEAT
   OPENWINDOW('Take one down, pass it around');
   OPENWINDOW('##1# bottles of beer on the wall \'+
          '##1# bottles of beer on the wall');
   bottles := bottles -1;
   UPDATEWINDOW(1,bottles);
UNTIL bottles = 1;
OPENWINDOW('1 bottle of beer on the wall \'+
          'no more bottles of beer on the wall');
CLOSEWINDOW();
</PRE>
<HR>
<H2><A NAME="basic">BASIC</A></H2>
<PRE>
10 REM Basic version of 99 bottles of beer
20 FOR X=100 TO 1 STEP -1
30 PRINT X;"Bottle(s) of beer on the wall,";X;"bottle(s) of beer"
40 PRINT "Take one down and pass it around,"
50 PRINT X-1;"bottle(s) of beer on the wall"
60 NEXT
</PRE>
In order to avoid slighting anyone, here is the QuickBasic version:
<PRE>
'99 Bottles of Beer on the Wall
'Patrick Fleming   http://chem-www.mps.ohio-state.edu/~pfleming/

CLS

n = 100
DO UNTIL n = 1
     n = n - 1
     PRINT n; "bottle";
     IF n <> 1 THEN PRINT "s";
     PRINT " of beer on the wall . . ."
     PRINT n; "bottle";
     IF n <> 1 THEN PRINT "s";
     PRINT " of beer!"
     PRINT "Take one down, pass it around . . ."
     PRINT n - 1; "bottle";
     IF n - 1 <> 1 THEN PRINT "s";
     PRINT " of beer on the wall!"
     PRINT
LOOP

END

</PRE>
<HR>
<H2><A NAME="coldfusion">Cold Fusion</A></H2>
<i>Cold Fusion is merely a set of tags that are 
interpreted on the server side.  Cold Fusion's real strength 
is accessing or modifying SQL datasources through ODBC and 
formatting the output into web pages.</i>
<PRE>
&lt;!---  99 Bottles of Beer in Cold Fusion by Steven Reich  
      tauman@earthlink.net ---&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Bottles of Beer&lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;CFLOOP INDEX="idx" FROM=99 TO=2 STEP=-1&gt;
&lt;CFOUTPUT&gt;
#idx# Bottles of Beer on the wall, #idx# Bottles of Beer,
&lt;BR&gt;Take one down, pass it around, #Evaluate("#idx# - 1")# Bottles of 
Beer on the wall
&lt;P&gt;
&lt;/CFOUTPUT&gt;
&lt;/CFLOOP&gt;
1 Bottle of Beer on the wall, 1 Bottle of Beer,
&lt;BR&gt;Take one down, pass it around, no Bottles of Beer on the wall

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
<HR>
<H2><A NAME="adl">ADL</A></H2>
<i>ADL is Adventure Definition Language</i>
<PRE>
{ This version of beer.adl is the normal procedural one which has }
{ no user interaction, and only prints out the song.  Quite boring, }
{ really. Ross Cunniff, 1997 cunniff@fc.hp.com }
START =
    LOCAL i, s;
    ($setg i 99)
    (WHILE ($gt @i 0) DO
	(IF ($gt @i 1) THEN
	    ($say ($str @i) " bottles of beer on the wall.\n")
	    ($say ($str @i) " bottles of beer.\n")
	 ELSE
	    ($say "1 bottle of beer on the wall.\n")
	    ($say "1 bottle of beer.\n")
	)
	($say "You take one down, pass it around.\n")
	($setg i ($minus @i 1))
	(IF ($gt @i 1) THEN
	    ($say ($str @i) " bottles of beer on the wall.\n\n")
	 ELSEIF ($eq @i 1) THEN
	    ($say "1 bottle of beer on the wall.\n\n")
	 ELSE
	    ($say "No more bottles of beer on the wall.\n")
	)
    )
    ($spec 3)
;
</PRE>
<HR>
<H2><A NAME="clos">CLOS</A></H2>
<i>Common Lisp Object System</i>
<PRE>
;;;; 99 bottles of beer as a CLOS program.
;;;; Author: Christopher Oliver (oliver@traverse.com)
;;;; Aug 10, 1997

(defconstant *bottles-at-store* 500)
(defconstant *bottles-at-gathering* 99)

(defclass bottle-of-beer () ())

(defclass beer-holder () ((inventory :accessor inventory :initform nil)))

(defclass wall (beer-holder)  ((on-hand :accessor on-hand :initform 0)))

(defclass store (beer-holder) ())

(defmethod consume ((bottle bottle-of-beer))
  (format t "pass it around.~%"))

(defmethod add-to-inventory ((holder beer-holder) (bottle bottle-of-beer))
  (push bottle (inventory holder)))

(defmethod remove-from-inventory ((holder beer-holder))
  (pop (inventory holder)))

(defmethod add-to-inventory :after ((wall wall) (bottle bottle-of-beer))
  (incf (on-hand wall)))

(defmethod remove-from-inventory ((wall wall))
  (let ((bottle (call-next-method)))
    (when bottle
      (format t "~&Take ~:[one~;it~] down, and " (= (on-hand wall) 1))
      (decf (on-hand wall)))
    bottle))

(defmethod count-bottles ((wall wall) &key (long-phrase nil))
  (let ((on-hand (on-hand wall)))
    (format t "~&~:[~@(~R~)~;No more~*~] bottle~p of beer~@[ on the wall~]."
	    (zerop on-hand) on-hand on-hand long-phrase)))

(defmethod remove-from-inventory ((store store))
  (let ((bottle (call-next-method)))
    (if bottle
	(unless (consp (inventory store))
	  (format t "~&(You've exhausted my supply!)~%"))
        (format t "~&(I have nothing left to sell you!)~%"))
    bottle))

(defmethod replenish ((wall wall) (store store))
  (format t "~&Go to the store, and buy some more.")
  (dotimes (number-bought 99)
    (let ((bottle (remove-from-inventory store)))
      (cond (bottle	            (add-to-inventory wall bottle))
	    ((plusp number-bought)  (return-from replenish))
	    (t	                    (error "The end is at hand!"))))))

(defun ninety-nine ()       
  (let ((store (make-instance 'store))
	(wall (make-instance 'wall)))
    (dotimes (ix *bottles-at-store*)
      (add-to-inventory store (make-instance 'bottle-of-beer)))
    (dotimes (ix *bottles-at-gathering*)
      (add-to-inventory wall (make-instance 'bottle-of-beer)))
    (loop
      (progn
	(count-bottles wall :long-phrase t)
	(count-bottles wall)
	(let ((this-bottle (remove-from-inventory wall)))
	  (if this-bottle
	      (consume this-bottle)
	    (replenish wall store)))
	(count-bottles wall :long-phrase t)
	(format t "~&~%")))))
</PRE>
<HR>
<H2><A NAME="corvu">CorVu</A></H2>
<i><a href=http://www.corvu.com.au>CorVu</a> is an integrated business
intelligence suite</i>
<PRE>
bottles = 99;

(bottles > 0)
?*
(
	text = ((bottles > 1) ? " bottles" : " bottle");
	display(bottles, text, " of beer on the wall,");
	newline();
	display(bottles, text, " of beer,");
	newline();
	display("Take one down, and pass it around,");
	newline();
	bottles = bottles - 1;
	(bottles > 0)
	?
	(
		text = ((bottles > 1) ? " bottles" : " bottle");
		display(bottles, text, " of beer on the wall.")
	)
	:
	(
		display("No more bottles of beer on the wall.")
	);
	newline(2)
);

display("No more bottles of beer on the wall,");
newline();
display("No more bottles of beer,");
newline();
display("Go to the store and buy some more,");
newline();
display("99 bottles of beer on the wall.");
newline()
</PRE>
<HR>
<H2><A NAME="amanda">Amanda</A></H2>
<i>Amanda is a DOS version of <A HREF="beer_i_m.html#miranda">Miranda</a>.
I'm told it's freeware, but was given no reference.</i>
<PRE>
/*
   I made some changes to the miranda script by Tim Walls.
   
   Changes by Gavin Spearhead (wieger1@noord.bart.nl)
			                                           */


bottlesofbeer :: num -> [char]

bottlesofbeer n = "\nNo more bottles of beer on the wall, \n"
                  ++ "no more bottles of beer.\n"  , if n = 0
                = "\nOne bottle of beer on the wall, one bottle of beer,\n"
                  ++ "Take one down and pass it around"
                  ++ (bottlesofbeer (n-1))         , if n = 1
                = "\n" ++ itoa(n) ++ " bottles of beer on the wall, "
                       ++ itoa(n)
                       ++ " bottles of beer,\nTake one down and pass it around"
                       ++ (bottlesofbeer (n-1))         , otherwise
</PRE>
<HR>
<H2><A NAME="boxer">Boxer Macro Language</A></H2>
<i>Boxer is an editor for DOS/OS2 environment.  See www.boxersoftware.com/users/dhamel
</i>
<PRE>
* 99 bottles of beer on the wall
* In the Boxer macro language
* Load / Compile this macro
* And execute by pressing :
* CTRL-A
* ALT-Y
* 98 <enter>
* CTRL-B
*
* Written by Gavin Spearhead 1997
* wieger1@noord.bart.nl

&lt;macro=1&gt;&lt;name="init beer"&gt;
99&lt;sp&gt;bottles&lt;sp&gt;of&lt;sp&gt;beer&lt;sp&gt;on&lt;sp&gt;wall&lt;enter&gt;99&lt;sp&gt;bottles&lt;sp&gt;of&lt;sp&gt;beer
&lt;enter&gt;Take&lt;sp&gt;one&lt;sp&gt;down,&lt;sp&gt;pass&lt;sp&gt;it&lt;sp&gt;around&lt;enter&gt;98&lt;sp&gt;bottles&lt;sp&gt;
of&lt;sp&gt;beer&lt;sp&gt;on&lt;sp&gt;wall&lt;enter&gt;

&lt;macro=2&gt;&lt;name="Drink one"&gt;
&lt;up&gt;&lt;up&gt;&lt;up&gt;&lt;up&gt;&lt;mark down&gt;&lt;mark down&gt;&lt;mark down&gt;&lt;mark down&gt;&lt;copy&gt;&lt;down&gt;
&lt;enter&gt;&lt;paste&gt;&lt;decrement&gt;1&lt;enter&gt;&lt;down&gt;&lt;decrement&gt;1&lt;enter&gt;&lt;down&gt;&lt;down&gt;
&lt;decrement&gt;1&lt;enter&gt;&lt;down&gt;
</PRE>
<HR>
<H2><A NAME="cal">CAL</A></H2>
<i>Cakewalk Application Language (v3).  Cakewalk is a MIDI sequencing program
which can manipulate midi data using CAL programs.  This program is multi-file
and file name breaks are in italics.</i>
<P>
<i>-- BEER.CAL --</i>
<PRE>
;  BEER.CAL by Tom Murphy 7 <poop@cmu.edu> for Cakewalk CAL 
; (version 3)
;  It will even play the song along if you have a MIDI device 
; hooked up, otherwise it is REALLY boring.
;  <9.9.97>

(do
	(int beer 99)
	(while (!= beer 0) (do
	(if (!= beer 1)
       (message beer "bottles of beer on the wall")
       (message "1 more bottle of beer on the wall...")
	)
	(include "part1.cal")
	(if (!= beer 1)
       (message beer "bottles of beer")
       (message "1 more bottle of beer...")
	)
		 (delay 600)
      (include "part2.cal")
   (message "Take one down, pass it around")
   (delay 600) (include "part3.cal")
		(-- beer)
	(delay 600)
	(if (!= beer 1)
       (message beer "bottles of beer on the wall")
       (message "1 more bottle of beer on the wall...")
	)
    (include "part4.cal") (delay 600)
		))
   (pause "We're out of beer, dude.")
)
</PRE>
<i>-- PART1.CAL --</i>
<PRE>
; PART1.CAL
; replace this (and the other PART?.CAL files) with:
; (do
;    NIL
; )
; if you want it to not make sounds.

(do
  (sendMIDI -1 1 NOTE 48 64)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
   (sendMIDI -1 1 NOTE 48 0) (delay 100) (sendMIDI -1 1 NOTE 43 64)
      (sendMIDI -1 1 NOTE 55 64) (delay 300) (sendMIDI -1 1 NOTE 55 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 55 64) (delay 300) (sendMIDI -1 1 NOTE 55 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 55 64) (delay 300) (sendMIDI -1 1 NOTE 55 0)
  (sendMIDI -1 1 NOTE 43 0) (delay 100) (sendMIDI -1 1 NOTE 48 64)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 60 64) (delay 300) (sendMIDI -1 1 NOTE 60 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 60 64) (delay 600) (sendMIDI -1 1 NOTE 60 0)
   (sendMIDI -1 1 NOTE 48 0)
)
</PRE>
<i>-- PART2.CAL --</i>
<PRE>
(do
  (sendMIDI -1 1 NOTE 50 64)
      (sendMIDI -1 1 NOTE 62 64) (delay 300) (sendMIDI -1 1 NOTE 62 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 62 64) (delay 300) (sendMIDI -1 1 NOTE 62 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 62 64) (delay 300) (sendMIDI -1 1 NOTE 62 0)
   (sendMIDI -1 1 NOTE 50 0) (delay 100) (sendMIDI -1 1 NOTE 45 64)
      (sendMIDI -1 1 NOTE 57 64) (delay 300) (sendMIDI -1 1 NOTE 57 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 57 64) (delay 300) (sendMIDI -1 1 NOTE 57 0)
    (delay 100)
      (sendMIDI -1 1 NOTE 57 64) (delay 300) (sendMIDI -1 1 NOTE 57 0)
  (sendMIDI -1 1 NOTE 45 0) (delay 100) (sendMIDI -1 1 NOTE 50 64)
      (sendMIDI -1 1 NOTE 62 64) (delay 1200) (sendMIDI -1 1 NOTE 62 0)
   (sendMIDI -1 1 NOTE 50 0)
)
</PRE>
<i>-- PART3.CAL --</i>
<PRE>
(do
   (sendMIDI -1 1 NOTE 43 64)
   (sendMIDI -1 1 NOTE 59 64) (delay 400) (sendMIDI -1 1 NOTE 59 0)
   (delay 300) (sendMIDI -1 1 NOTE 59 64) (delay 300)
   (sendMIDI -1 1 NOTE 59 0) (delay 100) (sendMIDI -1 1 NOTE 59 64)
   (delay 600) (sendMIDI -1 1 NOTE 59 0) (delay 400)
   (sendMIDI -1 1 NOTE 59 64) (delay 250) (sendMIDI -1 1 NOTE 59 0)
   (delay 100) (sendMIDI -1 1 NOTE 59 64) (delay 250)
   (sendMIDI -1 1 NOTE 59 0) (delay 100) (sendMIDI -1 1 NOTE 59 64)
   (delay 250) (sendMIDI -1 1 NOTE 59 0) (delay 100)
   (sendMIDI -1 1 NOTE 59 64) (delay 500) (sendMIDI -1 1 NOTE 59 0)
   (sendMIDI -1 1 NOTE 43 0)
)
</PRE>
<i>-- PART4.CAL --</i>
<PRE>
(do
   (sendMIDI -1 1 NOTE 43 64)
   (sendMIDI -1 1 NOTE 55 64) (delay 400) (sendMIDI -1 1 NOTE 55 0)
   (delay 300) (sendMIDI -1 1 NOTE 55 64) (delay 300)
   (sendMIDI -1 1 NOTE 55 0) (delay 100) (sendMIDI -1 1 NOTE 57 64)
   (delay 600) (sendMIDI -1 1 NOTE 57 0) (delay 100)
   (sendMIDI -1 1 NOTE 59 64) (delay 250) (sendMIDI -1 1 NOTE 59 0)
   (sendMIDI -1 1 NOTE 43 0) (delay 100) (sendMIDI -1 1 NOTE 36 64)
   (sendMIDI -1 1 NOTE 60 64) (delay 250) (sendMIDI -1 1 NOTE 60 0)
   (delay 100) (sendMIDI -1 1 NOTE 60 64) (delay 250)
   (sendMIDI -1 1 NOTE 60 0) (delay 100) (sendMIDI -1 1 NOTE 60 64)
   (delay 250) (sendMIDI -1 1 NOTE 60 0) (delay 100)
   (sendMIDI -1 1 NOTE 60 64) (delay 500) (sendMIDI -1 1 NOTE 60 0)
   (sendMIDI -1 1 NOTE 36 0)
)
</PRE>
<HR>
<H2><A NAME="cupl">CUPL</A2></H2>
<i>CUPL is the Cornell University Programming Language (c. 1966)</i>
<PRE>
COMMENT	99 BOTTLES IN CUPL (CORNELL UNIVERSITY PROGRAMMING LANGUAGE, C. 1966)
COMMENT	DAVE PLONKA - PLONKA@DOIT.WISC.EDU
COMMENT	FEB 17 1998
	LET N = 99
	PERFORM SONG WHILE N GT 2
LINES	BLOCK
	WRITE /N, ' BOTTLES OF BEER ON THE WALL,'
	WRITE /N, ' BOTTLES OF BEER,'
LINES	END
LINE	BLOCK
	WRITE 'TAKE ONE DOWN, PASS IT AROUND,'
LINE	END
SONG	BLOCK
	PERFORM LINES
	PERFORM LINE
	LET N = N - 1
	WRITE /N, ' BOTTLES OF BEER ON THE WALL.'
	WRITE ''
SONG	END
	PERFORM LINES
	PERFORM LINE
	WRITE '1 BOTTLE OF BEER ON THE WALL.'
	WRITE ''
	WRITE '1 BOTTLE OF BEER ON THE WALL,'
	WRITE '1 BOTTLE OF BEER,'
	PERFORM LINE
	WRITE 'NO BOTTLES OF BEER ON THE WALL.'
	STOP
</PRE>
<HR>
<H2><A NAME="babbage">Babbage's Analytical Engine</A></H2>
<I>This is an emulation of Babbage's original design.  Details and the
emulator may be found at <a href=http://www.fourmilab.ch/babbage/>http://www.fourmilab.ch/babbage/</a></I>
<PRE>
. 99 bottles of beer song
. written for Babbage's Analytical Engine with Attendant
. by Greg Cook 15/1/1998
. Attendant converts flow structure to conditional jumps

. No new line after number
A write in columns

. constants
N000  0
N001  1
N002  2

. bottle count
N003 99

(?
-
L003
P
. finish subtraction to compare bottles to 1
L002
{?
A write annotation  bottles
}{
A write annotation  bottle
}
A write annotation  of beer on the wall,
A write new line

. new subtraction card to clear mill
-
L003
P
L002
{?
A write annotation  bottles
}{
A write annotation  bottle
}
A write annotation  of beer,
A write new line
A write annotation Take one down and pass it around,
A write new line

. Still subtracting, update counter
L003
L001
S003
. compare for 0 this time
L003
L001
{?
. if <=0 then don't finish verse
-
L003
P
L002
{?
A write annotation  bottles
}{
A write annotation  bottle
}
A write annotation  of beer on the wall.
A write new line
A write new line
}
. if >0 then continue loop
L000
L003
)
A write annotation No more bottles of beer on the wall!
A write new line
</PRE>
<HR>
<P>
<P>
<CENTER>
<FONT SIZE=2><I>Compilation Copyright 1995, 1996, 1997 Tim Robinson.  All Rights Reserved
<BR>Permission to copy enthusiastically granted to instructors of computer science
<BR>(who would like to demonstrate the styles of different programming languages
<BR>to their students) provided that the names of the contributors are retained.</I></FONT SIZE>
</CENTER>
<BR><A HREF=beer_d_h.html>More beer</A>
<BR><A HREF=../index.html>Back to the Funhouse</A>
<P>
<P>
<P>
&nbsp;
<HTML>
<HEAD>
   <TITLE>99 Bottles of Beer on the Wall (D-H)</TITLE>
   <META NAME="Author" CONTENT="Tim Robinson">
</HEAD>
<BODY BACKGROUND="greenbar.gif" TEXT=#000000 BGCOLOR="#ffff00" LINK="#ff0000" VLINK="#007000" ALINK="#0077FF">
<UL>
<H2><A NAME="dal">DAL</A></H2>
<i>Apple's Data Access Language</i>
<PRE>
/*
DAL version of 99 Bottles of beer programmer:
by Georg Hentsch: ghentsch@blsoft.com
*/

declare integer beers = 99;
declare varchar s;

while (beers > 0)
{
	if (beers != 1)
		s = "s";
	else
		s = "";
	printf("%d bottle%s of beer on the wall,\n", beers, s);
	printf("%d bottle%s of beeeeer . . . ,\n", beers, s);
	printf("Take one down, pass it around,\n");

	beers--;
	if (beers > 0)
		printf("%d", beers);
	else
		printf("No more");
	if (beers != 1)
		s = "s";
	else
		s = "";
	printf(" bottle%s of beer on the wall.\n", s);
}
</PRE>
<H2><A NAME="dosbatch">DOS Batch</A></H2>
<PRE>
@echo off
REM 99 Bottles of Beer in DOS Batch
REM Gert-jan Los (los@lsdb.bwl.uni-mannheim.de)

if "%1"=="" goto outer
if "%1"=="body" goto body
:inner
for %%a in ( 9 8 7 6 5 4 3 2 1 0 ) do call beer body %2 %%a
goto exit

:outer
for %%a in ( 9 8 7 6 5 4 3 2 1 0 ) do call beer inner %%a
goto exit

:body
set num=%2%3
set bottle=bottles
if "%num%"=="99" goto skipfirst
if "%2"=="0" set num=%3
if "%num%"=="1" set bottle=bottle
echo %num% %bottle% of beer on the wall
echo.
if "%num%"=="0" exit
:skipfirst
echo %num% %bottle% of beer on the wall
echo %num% %bottle% of beer
echo take one down and pass it around
:exit

</PRE>
<HR>
<H2><A NAME="fortran">Fortran</A></H2>
<PRE>
C     <A HREF=http://www.access.digex.net/~pryan>patrick m. ryan</A> pryan@access.digex.net
      program ninetynine
      implicit none
      integer i

      do i=99,1,-1
        print*, i,' bottles of beer on the wall, ',i,' bottles of beer'
        print*, 'take one down, pass it around, ',i-1,
     .       ' bottles of beer on the wall'
      enddo
      end
</PRE>
<HR>
<H2><A NAME="forth">Forth</A></H2>
<PRE>
\ Forth version of the 99 Bottles program.
\ Dan Reish, dreish@izzy.net

: .bottles ( n -- n-1 )
   dup 1 = IF  ." One bottle of beer on the wall," CR
	       ." One bottle of beer," CR
	       ." Take it down," 
   ELSE  dup . ." bottles of beer on the wall," CR
	 dup . ." bottles of beer," CR
	 ." Take one down," 
   THEN
   CR
   ." Pass it around," CR
   1-
   ?dup IF  dup 1 = IF  ." One bottle of beer on the wall;" 
	    ELSE  dup . ." bottles of beer on the wall;" 
	    THEN
	ELSE  ." No more bottles of beer on the wall." 
   THEN
   CR
;

: nbottles ( n -- )
  BEGIN  .bottles  ?dup NOT UNTIL
;

99 nbottles

</PRE>
<HR>
<H2><A NAME="fortran4">Fortran IV</A></H2>
<PRE>
C Allen Mcintosh
C mcintosh@bellcore.com 
      integer bottls
      do 50 i = 1, 99
         bottls = 100 - i
         print 10, bottls
10       format(1x, i2, 31h bottle(s) of beer on the wall.)
         print 20, bottls
20       format(1x, i2, 19h bottle(s) of beer.)
         print 30
30       format(34h Take one down and pass it around,)
         bottls = bottls - 1
         print 10, bottls
         print 40
40       format(1x)
50    continue
      stop
      end

</PRE>
<HR>
<H2><A NAME="elisp">Emacs Lisp</A></H2>
<PRE>
;;Geza Gyuk - gyuk@oddjob.uchicago.edu"

(defun beersong (n)
  "Does the n-beers song."

(progn (insert (int-to-string n) " bottle" (cond ((= n 1) "")
                                                 (t "s")) 
                                         " of beer on the wall,\n")
       (insert (int-to-string n) " bottle" (cond ((= n 1) "")
                                                 (t "s"))
                                         " of beer,\n")
       (insert "take one down and pass it around,\n")
       (insert (cond ((= n 1) "no more")
                     (t (int-to-string (- n 1)))) 
               " bottle" (cond ((= n 2) "")
                               (t "s")) 
               " of beer on the wall.\n\n")
       (cond ((> n 1) (beersong (- n 1))))))

</PRE>
<HR>
<H2><A NAME="hackmongo">hackMongo</A></H2>
<I>hackMongo is an extension of the Mongo plotting package.</I>
<PRE>
! Does the beer song... sends output to a postscript file
! Geza Gyuk - gyuk@oddjob.uchicago.edu

printer 1
erase

data beer.dat
setv rounds c1(1)                       ! get number of rounds
                                        ! from first line, first
setv container bottles                  ! column of file beer.dat
expand {5/rounds}
loop i {rounds} 2 -1
   relocate 0.1 {i*5/(5*rounds)}
   putlabel 6 {i} bottles of beer on the wall,
   relocate 0.1 {(i*5-1)/(5*rounds)}
   putlabel 6 {i} bottles of beer,
   relocate 0.1 {(i*5-2)/(5*rounds)}
   putlabel 6 take one down and pass it around,
   if ({i}=2) setv container bottle
   relocate 0.1 {(i*5-3)/(5*rounds)}
   putlabel 6 {i-1} {container} of beer on the wall.
   relocate 0.1 {(i*5-4)/(5*rounds)}
   putlabel 6
endloop

relocate 0.1 {5/(5*rounds)}
putlabel 6 1 bottle of beer on the wall,
relocate 0.1 {4/(5*rounds)}
putlabel 6 1 bottle of beer,
relocate 0.1 {3/(5*rounds)}
putlabel 6 take it down and pass it around,
relocate 0.1 {2/(5*rounds)}
putlabel 6 no more bottles of beer on the wall.

hardcopy
end

</PRE>
<HR>
<H2><A NAME="delphi">Delphi</A></H2>
<I>Note:  Borland's Delphi only runs under Windows, so the simple
task of dumping the text to standard output isn't so simple any more.
The large body of code is to account for the Windows interface.</I>
<PRE>
{----------------------------------------------------------------------}
{Contents of BEER99.DPR}
program Beer99;

{99 bottles of beer - Borland Delphi 1.0}
{by Rodney M. Savard &lt;rodney.savard%phun@phunnet.org&gt;}

uses
  Forms,
  Beer in 'BEER.PAS' {Form1};

{$R *.RES}

begin
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.

{----------------------------------------------------------------------}
{Contents of BEER.PAS}
unit Beer;

interface

uses
  Classes, Controls, Forms, StdCtrls, SysUtils;

type
  TForm1 = class(TForm)
    Memo1: TMemo;
    Button1: TButton;
    procedure FormCreate(Sender: TObject);
    procedure Button1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  Bottles: Integer;
  s: String;

implementation

{$R *.DFM}

procedure TakeOneDown;
begin
   with Form1 do begin
      Memo1.Lines.Clear;
      Memo1.Lines.Add(IntToStr(bottles)+' bottle'+s+' of beer on the wall,');
      Memo1.Lines.Add(IntToStr(bottles)+' bottle'+s+' of beer.');
      Memo1.Lines.Add('');
      Memo1.Lines.Add('Take one down, pass it around,');

      Dec(Bottles);
      if Bottles<>1 then s:='s' else s:='';

      if Bottles=0 then begin
         Memo1.Lines.Add('no more bottles of beer on the wall!');
         Button1.Caption:='No More!';
         Button1.Enabled:=False;
      end
      else begin
         Memo1.Lines.Add(IntToStr(bottles)+' bottle'+s+' of beer on the wall.');
      end;
   end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
   Bottles:=99;
   s:='s';
   Button1Click(Form1);
end;

procedure TForm1.Button1Click(Sender: TObject);
begin
   TakeOneDown;
end;

end.
{----------------------------------------------------------------------}

</PRE>
<HR>
<H2><A NAME="dylan">Dylan</A></H2>
<PRE>
// Dylan version of 99 Bottles of Beer
// programmer: Jim Studt jim@federated.com

define method enumerate( count == 1 ) "1 bottle" end method enumerate;
define method enumerate( count == 0 ) "no more bottles" end method enumerate;
define method enumerate( count :: &lt;integer&gt; )
  format-to-string("%d bottles", count);
end method enumerate;

define method reference( count == 1) "it" end method reference;
define method reference( count :: &lt;integer&gt;) "one" end method reference;

define method main (argv0, #rest noise)
  for ( i from 99 to 1 by -1) 
    format( *standard-output*, "%s of beer on the wall, %s of beer.\n", 
	   enumerate(i), enumerate(i));
    format( *standard-output*, 
	   "  Take %s down, pass it around, %s of beer on the wall.\n",
	   reference(i), enumerate( i - 1));
  end for;
end method main;
</PRE>
<HR>
<H2><A NAME="eiffel">Eiffel</A></H2>
<i><a href=http://www.jovial.com/~billf/>Click</a> for information.</i>
<PRE>
class BEERS

creation

    make

feature     -- Creation

    make is
        local
            i : INTEGER
            b : STRING;
        do
            from i := 99 variant i until i <= 0 loop
                if i = 1 then
                    b := " bottle";
                else
                    b := " bottles"
                end -- if
                io.put_integer(i);
                io.put_string(b);
                io.put_string(" of beer on the wall, ");
                io.put_integer(i);
                io.put_string(b);
                io.put_string(" of beer,");
                io.new_line;
                io.put_string("Take one down and pass it around, ");
                i := i - 1;
                io.put_integer(i);
                io.put_string(b);
                io.put_string(" bottles of beer on the wall.");
                io.new_line;
            end -- loop
            io.put_string("Go to the store and buy some more,");
            io.new_line;
            io.put_string("99 bottles of beer on the wall.");
            io.new_line;
        end;

end -- class BEERS
</PRE>
<i>Here is the OOP version of this in Eiffel... that is to say, the "proper"
way to do Eiffel:</i>
<PRE>
class SHELF

      -- A shelf of bottles

creation

   make

feature

   make (l_bottles: INTEGER) is
      require
         positive_bottles: l_bottles >= 0
      do
         bottles := l_bottles
      end

   remove is
      require
         bottles_exist: bottles > 0
      do
         bottles := bottles - 1
      ensure
         removed: bottles = old bottles - 1
      end

   bottles: INTEGER

   short_description: STRING is
      do
         if bottles = 0 then
            Result := "No"
         else
            Result := bottles.out
         end
         Result.append (" bottle")
         if bottles /= 1 then
            Result.append ("s")
         end
         Result.append (" of beer")
      ensure
         result_exists: Result /= Void
      end

   description: STRING is
      do
         Result := short_description
         Result.append (" on the wall, ")
         Result.append (short_description)
         Result.append ("%N")
      ensure
         result_exists: Result /= Void
      end

   empty: BOOLEAN is
      do
         Result := bottles = 0
      end

invariant

   positive_bottles: bottles >= 0
         
end -- class SHELF

class BEER

   -- Produuce the ditty
   -- Nick Leaton

creation

   make

feature

   shelf: SHELF

   make is
      do
         from
            !!shelf.make (99)
         until
            shelf.empty
         loop
            io.put_string (shelf.description)
            shelf.remove
            io.put_string ("Take one down, pass it all around%N%N")
         end
         io.put_string (shelf.description)
         io.put_string ("Go to the store and buy some more%N%N")
         shelf.make (99)
         io.put_string (shelf.description)
      end   
            
end -- class BEER

</PRE>
<HR>
<H2><A NAME="erlang">Erlang</A></H2>
<i><a href=http://www.ericsson.se/cslab/erlang/>Erlang</a>
is a language used for real-time control systems.</i>
<PRE>
% ---------------------------------------------------------------
% Erlang version of the beer song
% Kent Engstrm, kenen@ida.liu.se
% ---------------------------------------------------------------
% See http://www.ericsson.se/cslab/erlang/ for Erlang information
% ---------------------------------------------------------------

-module(beer).
-export([song/0]).

song() ->
    song(100).

song(0) ->
    done;
song(N) ->
    Bottles=bottles(N),
    Bottles1=bottles(N-1),
    io:format("~s of beer on the wall, ~s of beer.~n",
	      [Bottles,Bottles]),
    io:format("Take one down and pass it around, ~s of beer on the wall.~n",
	      [Bottles1]),
    song(N-1).

bottles(0)->
    "no more bottles";
bottles(1)->
    "1 bottle";
bottles(N)->
    lists:append(integer_to_list(N)," bottles").
</PRE>
<HR>
<H2><A NAME="focal">Focal</A></H2>
<PRE>
01.10 c Focal-8 version of 99 Bottles of beer
01.20 c Hacked by Akira KIDA, &lt;SDI00379@niftyserve.or.jp&gt;

10.10 set bottles = 99
10.20 do 20
10.30 quit

20.10 for i = bottles, 1, -1; do 30
20.20 return

30.10 set b = i
30.20 do 40 ; type " on the wall, "
30.30 do 40 ; type ".", ! , "Take one down, pass it around.", !
30.40 set b = i - 1
30.50 do 40 ; type " on the wall.", !, !
30.60 return

40.10 do 50
40.20 type " of beer"
40.30 return

50.10 if (b - 1) 50.20, 50.40, 50.60
50.20 type "No more bottles"
50.30 return
50.40 type %1.0, b, " bottle"
50.50 return
50.60 type %1.0, b, " bottles"
50.70 return
</PRE>
<H2><A NAME="dectpu">DECTPU</A></H2>
<i>DEC's Pascal-like "Text Processing Utility."</i>
<PRE>
PROCEDURE BEER
          LOCAL BOTTLES, LINE_1, LINE_2, LINE_3;

          BOTTLES := 99;
          LINE_1 := "!SL bottle!%S of beer on the wall";
          LINE_2 := "!SL bottle!%S of beer,";
          LINE_3 := "If !0<!SL!>!1%Cthat single bottle"
                  + "!%Eone of those bottles!%F should happen to fall,";
          LOOP;
               COPY_TEXT( FAO( LINE_1, BOTTLES) + ","); SPLIT_LINE;
               COPY_TEXT( FAO( LINE_2, BOTTLES));       SPLIT_LINE;
               COPY_TEXT( FAO( LINE_3, BOTTLES));       SPLIT_LINE;
               BOTTLES := BOTTLES - 1;
               COPY_TEXT( FAO( LINE_1, BOTTLES) + "."); SPLIT_LINE;
SPLIT_LINE;
               EXITIF BOTTLES = 0;
          ENDLOOP;
ENDPROCEDURE
</PRE>
<HR>
<H2><A NAME="false">False</A></H2>
<i>The False language was created by Wouter van Oortmerssen
(Wouter@alf.let.uva.nl).</i>
<PRE>
{ False version of 99 Bottles by Marcus Comstedt (marcus@lysator.liu.se) }
[$0=["no more bottles"]?$1=["One bottle"]?$1>[$." bottles"]?%" of beer"]b:
100[$0>][$b;!" on the wall, "$b;!".
"1-"Take one down, pass it around, "$b;!" on the wall.
"]#%
</PRE>
<HR>
<H2><A NAME="hope">Hope</A></H2>
<i><a href=http://www-ala.doc.ic.ac.uk/~rap/Hope/>Click</a> 
for more information.</i>
<PRE>
! Hope Version of 99 Bottles of Beer : RAM-Biter!!!
! Tested on a SPARC classic, SunSolaris 2 
! Programmer: Wolfgang Lohmann   wlohmann@informatik.uni-rostock.de
 
dec app  :( list ( char ) X list ( char )) -> list ( char ) ;
dec i2c  : num -> char;
dec i2s  : num -> list(char);
dec beer : num -> list(char);

--- app ( nil , w )
       <= w  ;
--- app (( a  ::  v ), w )
       <=( a  ::  app ( v , w )) ;

--- i2c(0) <= '0';
--- i2c(1) <= '1';
--- i2c(2) <= '2';
--- i2c(3) <= '3';
--- i2c(4) <= '4';
--- i2c(5) <= '5';
--- i2c(6) <= '6';
--- i2c(7) <= '7';
--- i2c(8) <= '8';
--- i2c(9) <= '9';

--- i2s(x) <= if x &lt; 10 then [i2c(x)] else
				app(i2s(x div 10), i2s( x mod 10)); 

--- beer(x) <= if x = 1 then app( i2s(x), 
				" bottle of beer. No more beer on the wall.")
                	else app( app( app( app( app( 
				i2s(x), 
				" bottles of beer on the wall, "),
				i2s(x)), 
				" bottles of beer. "),
				"Take one down, pass it around. "), 
				beer(y))
                        where y== x-1;
</PRE>
<HR>
<H2><A NAME="haskell">Haskell</A></H2>
<i><a href=http://www.cs.yale.edu/HTML/YALE/CS/haskell/yale-fp.html>Click</a> 
for more information.</i>
<PRE>
-- Haskell program for the Beer Song.
--
-- Bert Thompson 5.11.95 (aet@cs.mu.oz.au)

module Main where

main = song 99

song n =
        bob n ++ " on the wall,\n" ++
        bob n ++ ".\n" ++
        "Take one down, pass it around.\n"  ++
        if n == 1
        then
                "No more bottles of beer on the wall.\n"
        else
                bob (n-1) ++ " on the wall.\n"
                ++ song (n-1)

bob n =
        show n ++ bottle ++ " of beer"
        where
        bottle = " bottle" ++ if n == 1 then "" else "s"
</PRE>
<HR>
<H2><A NAME="f90">Fortran 90</A></H2>
<PRE>
!  F90 (Fortran 90) version of 99 bottles of beer.
!    written by Akira KIDA,  SDI00379@niftyserver.or.jp
!    Note that this source is in FIXED format.

	program ninetynine
	implicit none
	integer, parameter :: BOTTLES = 99
	integer :: i
	integer :: k
	character*7 :: btl = 'bottles'

	do i = BOTTLES, 1, -1
		k = len(btl)
		if (i == 1) k = k - 1
		print *, i, btl(1:k), ' of beer on the wall, ',
     c			 i, btl(1:k), ' of beer.'
		print *, 'Take one down, pass it around.'
		if (i == 0) exit
		print *, i, btl(1:k), ' of beer on the wall.'
	end do
	print *, 'No more bottles of beer on the wall.'
	end
</PRE>
<HR>
<H2><A NAME="forms3">Forms/3</A></H2>
<i>Programming in Forms/3 follows the spreadsheet paradigm; the programmer 
uses direct manipulation to place cells on forms, and then defines a formula 
for each cell.
<a href=http://www.cs.orst.edu/~burnett/Forms3/forms3.html>Click here</a>
for more information.
<P>
</i>
<IMG src=forms3.gif>
<HR>
<H2><A NAME="dibol">DIBOL</A></H2>
<PRE>
.TITLE - "Program to display 99 bottles of beer on the wall"
;
;=======================================================================================================
;	Author: Bob Welton (welton@pui.com)
;		Projects Unlimited Inc.
;		Dayton, OH  45414
;
;	Language: DIBOL or DBL
;=======================================================================================================

RECORD MISC
    NUMBOTTLES	,D2,99			;Default # of bottles to 99
    ANUMBOTTLES	,A2			;Used to mask the output of bottles


.PROC
    XCALL FLAGS (0007000000,1)		;Suppress STOP message
    OPEN (8,O:C,"TT:")        		;Open the terminal/display
    REPEAT
	BEGIN
	ANUMBOTTLES = NUMBOTTLES,'ZX'
	WRITES (8,ANUMBOTTLES+" Bottles of Beer on the wall,")
	ANUMBOTTLES = NUMBOTTLES,'ZX'
	WRITES (8,ANUMBOTTLES+" Bottles of Beer,")
	WRITES (8,"   Take one down, pass it around,")
	DECR NUMBOTTLES	      		;Reduce # of bottles by 1
	IF (NUMBOTTLES .LE. 1) EXITLOOP	;If just 1 bottle left, get out
	ANUMBOTTLES = NUMBOTTLES,'ZX'
	WRITES(8,ANUMBOTTLES+" Bottles of Beer on the wall.") 
	WRITES (8," ")
	END
    ANUMBOTTLES = NUMBOTTLES,'ZX'
    WRITES(8,ANUMBOTTLES+" Bottle of Beer on the wall.") 
    WRITES (8," ")
    WRITES (8,ANUMBOTTLES+" Bottle of Beer on the wall,")
    WRITES (8,ANUMBOTTLES+" Bottle of Beer,")
    WRITES (8,"   Take one down, pass it around,")
    WRITES (8," ")
    WRITES (8," ")
    WRITES (8, "Hey the Beer's gone, I am out of here...")
    SLEEP 2
    CLOSE 8
    STOP
.END
</PRE>
<HR>
<H2><A NAME="dbaseiii">dBase III</A></H2>
<I></i>
<PRE>
&& BEER.PRG  - 99 Bottles of Beer  - Brian Hobbs  Jan 1996
&& (BHOBBS@cayman.vf.mmc.com)
SET TALK OFF
I=99
DO WHILE I>=1
   b = STR(i,2)
   ? b +" Bottle"
   IF i &gt; 1
      ?? "s"
   ENDIF
   ?? " of beer on the wall "+b+" bottle"
   IF i> 1 
     ?? "s"
     ENDIF
   ?? " of beer"
   ? "   Take one down and pass it around"
   i=i-1
   b = STR(i,2)
   if i = 0
     b = "No more"
     ENDIF
   ? b + " Bottle"
   IF I &gt; 1 .OR. I=0
      ?? "s"
   ENDIF
   ?? " of beer on the wall"
   ?
ENDDO
   ? "No more bottles of beer on the wall, No more bottles of beer"
   ? "Go to the store and buy some more - 99 bottles of beer on the wall"
SET TALK ON
</PRE>
<HR>
<H2><A NAME="gofer">Gofer</A></H2>
<I>Gofer is a variation of Haskell.
<a href=http://www.cs.yale.edu/HTML/YALE/CS/haskell/yale-fp.html>More Information</a></i>
<PRE>
-- 99 bottles of beer (gofer version)
-- Written by Bow-Yaw Wang (bywang@saul.cis.upenn.edu)

radix 0 _ = []
radix x n = (x `mod` n):(radix (x/n) n)

itoa x = map (\x -> chr(x + ord('0'))) (reverse (radix x 10))

bottles :: Int -> Dialogue

bottles 1 resps = [AppendChan stdout "1 bottle of beer on the wall, ",
                   AppendChan stdout "1 bottle of beer.\n",
                   AppendChan stdout "Take one down, pass it around, ",
                   AppendChan stdout "no more bottles of beer on the wall.\n"]
bottles n resps = [AppendChan stdout (itoa n),
                   AppendChan stdout " bottles of beer on the wall, ",
                   AppendChan stdout (itoa n),
                   AppendChan stdout " bottles of beer.\n",
                   AppendChan stdout "Take one down, pass it around, ",
                   AppendChan stdout (itoa (n-1)),
                   AppendChan stdout " bottles of beer on the wall.\n"] ++
                   bottles (n-1) resps
</PRE>
<HR>
<H2><A NAME="dialogsystem">Dialog System</A></H2>
<I>'Dialog System', a system for developing graphical applications.</i>
<PRE>
# Programmer: Mark Gray - mvg@mfltd.co.uk
# http://www.mfltd.co.uk/
#
# Note: requires version 2.5 of Dialog System.

Form BEER
   Screenset Details
       First-Window WIN1
   End Details

   Form Data
       Group BOTTLE-TEXT-GROUP-1 Vertical Occurs 1
           NUMBER-OF-BOTTLES-1 Integer(2)
           BOTTLE-TEXT-1 Character(28)
           BOTTLE-PUNCTUATION-1 Character(1)
       End Group # BOTTLE-TEXT-GROUP-1

       Group BOTTLE-TEXT-GROUP-2 Vertical Occurs 1
           NUMBER-OF-BOTTLES-2 Integer(2)
           BOTTLE-TEXT-2 Character(17)
       End Group # BOTTLE-TEXT-GROUP-2

           BOTTLE-TEXT-1A Character(31)
           BOTTLE-TEXT-2A Character(19)
           BOTTLE-TEXT-3 Character(30)
           BOTTLE-TEXT-4 Character(34)
   End Data

   Object WIN1
       Type DIALOG-BOX
       Parent DESKTOP
       Start (492,720)
       Size  (1208,1150)
       Display "99 Bottles of Beer"
       Style MODELESS TITLEBAR SYSTEM-MENU
   End Object  #WIN1

   Object BEER-LIST
       Type LIST-BOX
       Parent WIN1
       Start (64,100)
       Size  (1088,800)
       Style DISABLE-HORIZONTAL
   End Object  #BEER-LIST

   Object PB1
       Type PUSH-BUTTON
       Parent WIN1
       Start (416,1040)
       Size  (372,96)
       Display "Close"
   End Object  #PB1

   Global Dialog CASE(OFF)
       Event ESC
           SET-EXIT-FLAG ;
           TERMINATE ;
       End Event # ESC
       Event CLOSED-WINDOW
           SET-EXIT-FLAG ;
           TERMINATE ;
       End Event # CLOSED-WINDOW
       Event BUTTON-SELECTED
           SET-EXIT-FLAG ;
           TERMINATE ;
       End Event # BUTTON-SELECTED
       Event SCREENSET-INITIALIZED
           MOVE " bottles of beer on the wall" BOTTLE-TEXT-1(1) ;
           MOVE " bottles of beer," BOTTLE-TEXT-2(1) ;
           MOVE "Take one down, pass it around," BOTTLE-TEXT-3 ;
           MOVE "Go to the store and buy some more," BOTTLE-TEXT-4 ;
           MOVE 99 NUMBER-OF-BOTTLES-1(1) ;
           BRANCH-TO-PROCEDURE COUNT-BOTTLES ;
       End Event # SCREENSET-INITIALIZED
       Procedure COUNT-BOTTLES
           MOVE NUMBER-OF-BOTTLES-1(1) NUMBER-OF-BOTTLES-2(1) ;
           MOVE "," BOTTLE-PUNCTUATION-1(1) ;
           MOVE BOTTLE-TEXT-GROUP-1 BOTTLE-TEXT-1A ;
           MOVE BOTTLE-TEXT-GROUP-2 BOTTLE-TEXT-2A ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-1A 0 ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-2A 0 ;
           MOVE "." BOTTLE-PUNCTUATION-1(1) ;
           IF= NUMBER-OF-BOTTLES-1(1) 0 END-BOTTLES ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-3 0 ;
           DECREMENT NUMBER-OF-BOTTLES-1(1) ;
           MOVE BOTTLE-TEXT-GROUP-1 BOTTLE-TEXT-1A ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-1A 0 ;
           BRANCH-TO-PROCEDURE COUNT-BOTTLES ;
       End Procedure # COUNT-BOTTLES
       Procedure END-BOTTLES
           MOVE 99 NUMBER-OF-BOTTLES-1(1) ;
           MOVE BOTTLE-TEXT-GROUP-1 BOTTLE-TEXT-1A ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-4 0 ;
           INSERT-LIST-ITEM BEER-LIST BOTTLE-TEXT-1A 0 ;
       End Procedure # END-BOTTLES
   End Dialog
End Form
</PRE>
<HR>
<H2><A NAME="hypertalk">HyperTalk</A></H2>
<I>The scripting language for Apple's HyperCard.</i>
<PRE>
--
-- a version of the "99 bottles of beer" song in HyperTalk
-- by eric carlson: eric@bungdabba.com
--
on BeerSong99
  BottlesOfBeer 99
end BeerSong99


--
-- do something with a lyric from the beer song.  this handler adds 
it to
--  a field on the current card
on OutputBeerLyric beerString
  if ( beerString is "&lt;reset&gt;" ) then
    put empty into cd fld "beer song"
  else
    put beerString & return after cd fld "beer song"
  end if
end OutputBeerLyric


--
-- sing the beer song with the specified number of bottles
on BottlesOfBeer bottleCount
  put bottleCount into initialCount
  OutputBeerLyric "&lt;reset&gt;"
  
  repeat until ( bottleCount &lt; 1 )
    set cursor to busy     -- let 'em know this might take a while
    put BottleString(bottleCount) into currentString
    OutputBeerLyric currentString && "of beer on the wall,"
    OutputBeerLyric currentString && "of beer."
    OutputBeerLyric "Take one down, and pass it around,"
    
    subtract one from bottleCount
    OutputBeerLyric BottleString(bottleCount) && "of beer on the 
wall." & return
  end repeat
  
  OutputBeerLyric "Go to the store and buy some more..."
  OutputBeerLyric initialCount & " bottles of beer on the wall."
end BottlesOfBeer


--
-- return the bottle string appropriate for the current count
function BottleString bottleCount
  if ( bottleCount is 1 ) then
    return "1 bottle"
  else if ( bottleCount is 0 ) then
    return "no more bottles"
  else
    return bottleCount && "bottles"
  end if
end BottleString
</PRE>
<HR>
<H2><A NAME="foxpro">Foxpro/Xbase</A></H2>
<I>The scripting language controlling the Foxpro database.</i>
<PRE>
** Randy Jean
FOR x = 100 TO 1 STEP -1
	?x,"Bottle(s) of beer on the wall,",x,"bottle(s) of beer"
	?"         Take one down and pass it around,"
	?x-1,"bottle(s) of beer on the wall"
ENDFOR
</PRE>
<HR>
<H2><A NAME="froth">Froth</A></H2>
<PRE>
\ 99 bottles of beer in Froth, by Leo Wong, a teetotaler   6FEB96  +
\ Pass it around.

: LYRICS   [CHAR] ! PARSE  TUCK  HERE CHAR+  SWAP CHARS MOVE   DUP C,  CHARS ALLOT ;
: VOCALIZE  ( a)  COUNT TYPE ;
: SING   CREATE LYRICS  DOES> VOCALIZE ;

SING NO_MORE No more !
SING BOTTLE bottle! 
SING BOTTLES bottles! 
SING OF_BEER  of beer!  
SING ON_THE_WALL  on the wall!
SING TAKE Take !
SING IT it! 
SING ONE one!
SING DOWN_AND_PASS_IT_AROUND  down and pass it around!
SING GO_TO_THE_STORE_&_BUY_SOME_MORE Go to the store and buy some more! 
SING COMMA ,!
SING PERIOD .!

: ?: CREATE  ( n)  ,   ' ,  ' ,
   DOES>  ( n)  TUCK @ <>  1-  CELLS -  @ EXECUTE ;

: NONE  ( n)  DROP NO_MORE ;
: SOME  ( n)  . ;

0 ?: HOW_MANY  NONE  SOME 

1 ?: BOTTLE(S)  BOTTLE  BOTTLES

1 ?: IT|ONE  IT  ONE

: COMMERCIAL  ( 0 - 99)  GO_TO_THE_STORE_&_BUY_SOME_MORE  99 + ;  
: SHAREWARE  ( n - n-1)  DUP  TAKE IT|ONE DOWN_AND_PASS_IT_AROUND  1- 
;

0 ?: main(){0?99:--}  COMMERCIAL  SHAREWARE

: BURP  ( n - n n)  DUP ;
: HOW_MANY_BOTTLES_OF_BEER  ( n n n)  HOW_MANY BOTTLE(S) OF_BEER ;

: Froth  ( n - n')
   CR  BURP BURP BURP  HOW_MANY_BOTTLES_OF_BEER ON_THE_WALL  COMMA
   CR  BURP BURP BURP  HOW_MANY_BOTTLES_OF_BEER              COMMA 
   CR  BURP            main(){0?99:--}                       COMMA
   CR  BURP BURP BURP  HOW_MANY_BOTTLES_OF_BEER ON_THE_WALL  PERIOD 
CR ;

: LeoWong  ( n)  DROP ;

: SONG   99
</PRE>
<HR>
<H2><A NAME="draco">Draco</A></H2>
<i>An Amiga language combining features of 
<a href=#c>C</a> and <a href=#pascal>Pascal</a></i>
<PRE>
/* 99 Bottles of Beer */
/* James Hicks (hicksjl@cs.rose-hulman.edu) */
/* 5 August 1996 */

int BEERS = 99;

proc main()void:

  uint i;

  for i from BEERS downto 1 do
    if i &gt; 1 then
      writeln(i, " bottles of beer on the wall, ", i, " bottles of beer.");
    else
      writeln(i, " bottle of beer on the wall, ", i, " bottle of beer.");
    fi;
    writeln("Take one down, pass it around,");
    if i &gt; 2 then
      writeln(i - 1, " bottles of beer on the wall.");
    elsif i &gt; 1 then
      writeln(i - 1, " bottle of beer on the wall.");
    else
      writeln("No bottles of beer on the wall.");
    fi;
  od;

corp;
</PRE>
<HR>
<H2><A NAME="expect">Expect</A></H2>
<i>Update:  Through some kind comments from others, I can now say
something about this language.  It is designed to talk to other
interactive programs apparently for testing purposes.   I am
told the contributor was the author of the language but apparently was
being humble.</i>
<PRE>
#!/usr/local/bin/expect

# 99 bottles of beer on the wall, Expect-style
# Author: Don Libes <libes@nist.gov>

# Unlike programs (http://www.ionet.net/~timtroyr/funhouse/beer.html)
# which merely print out the 99 verses, this one SIMULATES a human
# typing the beer song.  Like a real human, typing mistakes and timing
# becomes more erratic with each beer - the final verse is barely
# recognizable and it is really like watching a typist hunt and peck
# while drunk.

# Finally, no humans actually sing all 99 verses - particularly when
# drunk.  In reality, they occasionally lose their place (or just get
# bored) and skip verses, so this program does likewise.

# Because the output is timed, just looking at the output isn't enough
# - you really have to see the program running to appreciate it.
# Nonetheless, for convenience, output from one run (it's different
# every time of course) can be found in the file beer.exp.out
# But it won't show the erratic timing;  you have to run it for that.

proc bottles {i} {
	return "$i bottle[expr $i!=1?"s":""] of beer"
}

proc line123 {i} {
	out $i "[bottles $i] on the wall,\n"
	out $i "[bottles $i],\n"
	out $i "take one down, pass it around,\n"
}

proc line4 {i} {
	out $i "[bottles $i] on the wall.\n\n"
}

proc out {i s} {
	foreach c [split $s ""] {
		# don't touch punctuation; just looks too strange if you do
		if [regexp "\[,. \n\]" $c] {
			append d $c
			continue
		}

		# keep first couple of verses straight
		if {$i &gt; 97} {append d $c; continue}

		# +3 prevents it from degenerating too far
		# /2 makes it degenerate faster though

		set r [rand [expr $i/2+3]]
		if {$r} {append d $c; continue}

		# do something strange
		switch [rand 3] {
		    0 {
			# substitute another letter

			if [regexp \[aeiou\] $c] {
				# if vowel, substitute another
				append d [string index aeiou [rand 5]]
			} elseif [regexp \[0-9\] $c] {
				# if number, substitute another
				append d [string index 123456789 [rand 9]]
			} else {
				# if consonant, substitute another
				append d [string index bcdfghjklmnpqrstvwxyz [rand 21]]
			}
		    } 1 {
			# duplicate a letter
			append d $c$c
		    } 2 {
			# drop a letter
		    }
		}
	}

	set arr1 [expr .4 - ($i/333.)]
	set arr2 [expr .6 - ($i/333.)]
	set shape [expr log(($i+2)/2.)+.1]
	set min 0
	set max [expr 6-$i/20.]

	set send_human "$arr1 $arr2 $shape $min $max"

	send -h $d
}

set _ran [pid]

proc rand {m} {
	global _ran

	set period 259200
	set _ran [expr ($_ran*7141 + 54773) % $period]
	expr int($m*($_ran/double($period)))
}

for {set i 99} {$i>0} {} {
	line123 $i
	incr i -1
	line4 $i

	# get bored and skip ahead
	if {$i == 92} {
		set i [expr 52+[rand 5]]
	}
	if {$i == 51} {
		set i [expr 12+[rand 5]]
	}
	if {$i == 10} {
		set i [expr 6+[rand 3]]
	}
}
</PRE>
Sample output:
<PRE>
99 bottles of beer on the wall,
99 bottles of beer,
take one down, pass it around,
98 bottles of beer on the wall.

11 botqle off baer oc tbe wakl,
1 botplo of beer,
take onne da, pass itt arounm,
0 yotglees oof beeeer on tte walll.
</PRE>
<HR>
<H2><A NAME="filemaker">FileMaker Pro 3.0</A></H2>
<i>This program will allegedly sing to you.  Program courtesy
Jon Rosen (techwiz@netaxis.com).</i>
<PRE>
Enter Browse Mode
Set Field No. Bottles/Calculation (99)
Set Field Bottle Text/Calculation ()
Loop
  Set Field Bottle Text/Calculation
    If(No. Bottles  1,
      No. Bottles & bottles of beer on the wall.  & No. Bottles & bottles of beer. & Paragraph & Take one down and pass it around and ,
      No. Bottles & bottle of beer on the wall.  & No. Bottles & bottle of beer. & Paragraph & Take one down and pass it around and ) & Paragraph &
    If(No. Bottles - 1  1,
      (No. Bottles - 1) &  bottles of beer on the wall,
      (No. Bottles - 1) &  bottle of beer on the wall)
Refresh Window
Comment (Viewing text is optional)
Speak (Speech Data: Field: Bottle Text/Wait for completion)
Comment  (Speech is optional)
Set Field No. Bottles/Calculation (No. Bottles - 1)
Exit Loop If (Calculation (No. Bottles = 0))
End Loop
Set Field Bottle Text/Calculation (0 bottles of beer on the wall. 0 bottles of beer. Go to the store and buy some more. & Paragraph & 99 bottles of beer on the wall.
Refresh Window
Speak (Speech Data: Field: Bottle Text/Wait for completion)
</PRE>
<HR>
<H2><A NAME="grasp">GrASP</A></H2>
<i>GrASP is used for controlling the GrASP animation program.</i>
<PRE>
video 1
local var1 99
local var2 24
mark 98
text 1 @var2 @var1
text " bottle(s) of beer on the wall,"
text 1 @var2-1 @var1
text " bottle(s) of beer!"
text 1 @var2-2 "Take one down, pass it around,"
text 1 @var2-3 @var1-1
text " bottle(s) of beer on the wall!"
waitkey 500
set var1 @var1-1
loop
</PRE>
<HR>
<H2><A NAME="gnucpp">GNU-cpp</A></H2>
<i></i>
<PRE>
/************************************************************************/
/*	bottle.cpp							*/
/*	1996 Walter Zimmer (walter.zimmer@rz.uni-ulm.de)		*/
/*									*/
/*	Save as "bottle.cpp" or change all the #includes !		*/
/*	#include is necessary since cpp expands each line into		*/
/*	no more than one new line					*/
/*									*/
/*	Invocation: cpp -P bottle.cpp					*/
/*									*/
/*	Remove comments to have less empty lines in the output		*/
/*	but we still have to many...					*/
/************************************************************************/

#if defined TEXT
/* This is the part which outputs one verse. 'Passed' parameters are */
	/* ONES:	inner digit */
	/* TENS:	outer digit */
	/* SECONDTEN:	outer digit decremented by one */

	/* if ONES == 0 then we have to use the decremented outer digit */
	#if ONES == 0
		/* omit output of 00 verse */
		#if SECONDTEN < 10
		/* Use SECONDTEN */
			print(TENS,ONES)
			print(TENS,ONES)
			  Take one down, pass it around
			print(SECONDTEN,SECONDONE)
		#endif /* SECONDTEN */
	#else /* ONES */
		/* Here everthing is normal, we use the normal TENS */
			print(TENS,ONES)
			print(TENS,ONES)
			  Take one down, pass it around
			print(TENS,SECONDONE)
	#endif /* ONES */
#elif defined LOOP
/*	This is the inner loop which iterates about the last digit */
	/* #undef LOOP, #define TEXT so we output text in the next #include */
	#undef LOOP
	#define TEXT

	/* #undef and #define the inner digits, invoke text output */
	#undef ONES
	#undef SECONDONE
	#define ONES 9
	#define SECONDONE 8
	#include "bottle.cpp"

	/* ...and so on for digits 8-0 */
	#undef ONES
	#undef SECONDONE
	#define ONES 8
	#define SECONDONE 7
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 7
	#define SECONDONE 6
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 6
	#define SECONDONE 5
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 5
	#define SECONDONE 4
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 4
	#define SECONDONE 3
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 3
	#define SECONDONE 2
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 2
	#define SECONDONE 1
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 1
	#define SECONDONE 0
	#include "bottle.cpp"
	#undef ONES
	#undef SECONDONE
	#define ONES 0
	#define SECONDONE 9
	#include "bottle.cpp"

	/* Clean up */
	#undef TEXT

#else /* TEXT, LOOP */
/*	Here is the basic 'loop' which iterates about the outer digit */

	/* First define the print macro which outputs one line of xx beer */
	/* We have to define it over the second define 'raw' to combine */
	/* prescan with concatenation */
	#define raw(TENS,ONES) TENS ## ONES
	#define print(TENS,ONES) raw(TENS,ONES) bottles of beer on the wall

	/* Tell bottle.cpp to invoke the inner loop when #included */
	#define LOOP

	/* #define outer digit and process inner loop */
	#define TENS 9
	#define SECONDTEN 8
	#include "bottle.cpp"

	/* Do this for the other digits 8 to 0, now with #undef */
	/* Since LOOP gets #undef'd, we have to define it again */
	#define LOOP
	#undef TENS
	#define TENS 8
	#undef SECONDTEN
	#define SECONDTEN 7
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 7
	#undef SECONDTEN
	#define SECONDTEN 6
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 6
	#undef SECONDTEN
	#define SECONDTEN 5
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 5
	#undef SECONDTEN
	#define SECONDTEN 4
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 4
	#undef SECONDTEN
	#define SECONDTEN 3
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 3
	#undef SECONDTEN
	#define SECONDTEN 2
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 2
	#undef SECONDTEN
	#define SECONDTEN 1
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 1
	#undef SECONDTEN
	#define SECONDTEN 0
	#include "bottle.cpp"
	#define LOOP
	#undef TENS
	#define TENS 0
	#undef SECONDTEN

	/* We @define SECONDTEN as 10 to indicate that we are outputting */
	/* the last block and therefore need only 9 verses */
	#define SECONDTEN 10
	#include "bottle.cpp"
#endif
</PRE>
<HR>
<H2><A NAME="exec">EXEC</A></H2>
<i></i>
<PRE>
* EXEC version of 99 Bottles of beer program
* By Torbjrn Vaaje (<a href="mailto:etotv@eto.ericsson.se">etotv@eto.ericsson.se</a>)
*
&BEERS = 99
&S = ES
&LOOP 5 99
&TYPE &BEERS BOTTL&S OF BEER ON THE WALL, &BEERS BOTTL&S OF BEER.
&BEERS = &BEERS - 1
&IF &BEERS = 1 &S = E
&IF &BEERS = 0 &BEERS = NO_MORE
&TYPE TAKE ONE DOWN AND PASS IT AROUND, &BEERS BOTTL&S OF BEER ON THE WALL
</PRE>
<HR>
<H2><A NAME="focus">Focus</A></H2>
<i>Focus is a fourth generation data reporting/management
language/toolset. It runs on a numerous platforms, from Windows up to
MVS.  <a href=http://www.ibi.com/>http://www.ibi.com/</a>
</i>
<PRE>
-* Randy Gleason
-* 99 beer challenge

 -REPEAT ENDBEER FOR &COUNTER FROM 99 TO 1 STEP -1
 -SET &PL = IF &COUNTER EQ 1 THEN '' ELSE 's' ;
 -TYPE &COUNTER bottle&PL of beer on the wall, &COUNTER bottle&PL of beer
 -TYPE Take one down, pass it around
 -TYPE
 -ENDBEER
 -TYPE No more bottles of beer on the wall, No more bottles of beer
 -TYPE And we all shout out..WHO'S BUYING THE NEXT ROUND!
</PRE>
<HR>
<H2><A NAME="express">Express</A></H2>
<i>Custom language used by IRI Software</i>
<PRE>
"  Language:  Express
"  Written by Lori Smallwood, IRI Software
"  April 12, 1997

vrb _beer  int
_beer = 99

while _beer gt 0
  do
    shw joinchars(_beer ' bottles of beer on the wall,')
    shw joinchars(_beer ' bottles of beer... ')
    shw 'Take one down, pass it around,'
    _beer = _beer - 1
    shw joinchars(_beer ' bottles of beer on the wall!')
  doend
</PRE>
<HR>
<H2><A NAME="excel">Excel</A></H2>
<i>Admittedly, yet another VB application.</i>
<PRE>
Sub Beers()
' 99 bottles of beer on the wall
' Visual Basic for Excel version
' by Alejandro Julien (ajulien@tonatiuh.sis.uia.mx)
' Done with Excel 7 (Windows '95)
'
' It will start from the first cell of the first worksheet
' and move on downwards.
    Dim Cervezas As Integer 'Cervezas = beer in spanish
    Dim miCelda As Integer  'miCelda = myCell in spanish
    Worksheets(1).Activate
    ' Colors
    Range("A1:AA1").Interior.Color = RGB(0, 0, 128)
    ActiveCell.Offset(1, 0).Value = "by Alejandro Julien"
    Range("A1:A204").Font.Color = RGB(0, 0, 128)
    ' Title
    Range("A1").Select
    With ActiveCell
        .Value = "The 99 bottles of beer on the wall song"
        .Font.Size = 18
        .Font.Color = RGB(255, 255, 255)
    End With
    With ActiveCell.Offset(2, 0)
        .Value = "(ajulien@tonatiuh.sis.uia.mx)"
        With .Font
            .Italic = True
            .Size = 8
        End With
    End With
    miCelda = 3
    ' GO!
    For Cervezas = 99 To 2 Step -1
        ActiveCell.Offset(miCelda, 0).Value = Cervezas & " bottles of beer on the wall, " & Cervezas & " bottles of beer"
        miCelda = miCelda + 1
        ActiveCell.Offset(miCelda, 0).Value = "take one down and pass it around"
        miCelda = miCelda + 1
    Next
    ' ONE_BEER_EXCEPTION handling *whew!*
    ActiveCell.Offset(miCelda, 0).Value = "One bottle of beer on the wall, one bottle of beer"
    miCelda = miCelda + 1
    ActiveCell.Offset(miCelda, 0).Value = "take it down and pass it around"
    miCelda = miCelda + 1
    ' Beer's over
    ActiveCell.Offset(miCelda, 0).Value = "No more bottles of beer on the wall, no more bottles of beer"
    miCelda = miCelda + 1
    ActiveCell.Offset(miCelda, 0).Value = "Go to the store and buy some more"
    miCelda = miCelda + 1
    ' Sponsor's message
    With ActiveCell.Offset(miCelda, 0)
        .Value = "...but make sure it's mexican beer!"
        .Font.Italic = True
        .Font.Size = 8
    End With
    Application.Caption = "Cerveza mexicana siempre!"
    ' No kidding. If you have the chance, try a good mexican beer (:
    '-------
    ' This piece of code goes for the "99 bottles of beer" homepage,
    ' and may be used by whoever finds it useful to show Language,
    ' way of doing the chore, or proof that programmers seem to have
    ' no life (even though this is not a complete truth...)
    ' <#include "disclaim.h>
End Sub
</PRE>
<HR>
<H2><A NAME="dc">dc</A></H2>
<i>dc is the Desk Calculator for *nix; It works on     
reverse polish notation, and a few other commands.  
The output of this routine is a little jagged, as   
dc has no commands to control screen formatting.
<br>
 Usage: dc 99bottles                                
<br>
 where this source file is saved as 99bottles       
 NB: A blank line is required at the end of the file
     Without it, dc will not quit.</i>
<PRE>
[   bottles of beer on the wall
]sa
[   bottles of beer
]sb
[   take one down, pass it around
]sc
[   
]sd
99sn
[lalnpsnPlblnp1-snPlcPlalnpsnPldPln0<x]sx
lxx
q

</PRE>
<HR>
<H2><A NAME="dc">dc</A></H2>
<i>dc is the Desk Calculator for *nix; It works on     
reverse polish notation, and a few other commands.  
The output of this routine is a little jagged, as   
dc has no commands to control screen formatting.
<br>
 Usage: dc 99bottles                                
<br>
 where this source file is saved as 99bottles       
 NB: A blank line is required at the end of the file
     Without it, dc will not quit.</i>
<PRE>
[   bottles of beer on the wall
]sa
[   bottles of beer
]sb
[   take one down, pass it around
]sc
[   
]sd
99sn
[lalnpsnPlblnp1-snPlcPlalnpsnPldPln0<x]sx
lxx
q

</PRE>
<HR>
<H2><A NAME="e">E</A></H2>
<i>E is the macro language for IBM's EPM editor.</i>
<PRE>
;  99 bottles of beer in E, the macro language for IBM's EPM editor.
-- Todd Fox
/* The most interesting thing about this language is that it has 3
 * different commenting styles and that the macros must be recompiled
 * directly into the editor to be used. */

defproc make_bottle_text(num_bottles)
   if (num_bottles > 1) then
      bottle_text = num_bottles || ' bottles'
   elseif (num_bottles = 1) then
      bottle_text = num_bottles || ' bottle'
   else
      bottle_text = 'No bottles'
   endif

   return(bottle_text)

defproc sing_beer_main_line(num_bottles, is_long)
   lyrics = make_bottle_text(num_bottles) || ' of beer'

   if (is_long) then
      lyrics = lyrics || ' on the wall'
   endif

   insertline lyrics

defproc sing_beer_song()
   init_bottle_cnt = 99
   curr_bottle_cnt = init_bottle_cnt

   do while curr_bottle_cnt >= 1
      sing_beer_main_line(curr_bottle_cnt, 1)
      sing_beer_main_line(curr_bottle_cnt, 0)
      insertline 'Take one down and pass it around'
      curr_bottle_cnt = curr_bottle_cnt - 1
      sing_beer_main_line(curr_bottle_cnt, 1)
      insertline '' -- don't use "insert", existing text will get mixed 
in
   enddo

   sing_beer_main_line(curr_bottle_cnt, 1)
   sing_beer_main_line(curr_bottle_cnt, 0)
   insertline 'Go to the store and buy some more'
   curr_bottle_cnt = init_bottle_cnt
   sing_beer_main_line(curr_bottle_cnt, 1)


; Define a command to execute it from the EPM command line.

defc sing_beer_song
   call sing_beer_song()

; Execute with ctrl-X

def c_X = 'sing_beer_song'

; done

</PRE>
<HR>
<H2><A NAME="DSSP">DSSP</A2></H2>
<i>For Info see <a href=http://www.dssp.msk.ru>http://www.dssp.msk.ru</a></i>
<PRE>
[  99 bottles in DSSP
   Programmer: Laszlo Aszalos &lt;aszalos@math.klte.hu&gt;

   Run it with 99 BOTTLE
]

B10
: BOTTLE [N] LOT_OF ONE_LEFT ZERO [] ;
: LOT_OF [N] CR C 1- DO ONE_BOTTLE D ;
: ONE_BOTTLE [N]
     ON_THE_WALL .", " CR NUMBER_OFF BOTTLES ."," CR
     TAKE 1- [N-1] C 1 = IF0 MANY ;
: MANY ON_THE_WALL ."." CR ;
: TAKE ."take one down, pass it around," CR ;
: ON_THE_WALL NUMBER_OFF BOTTLES ." on the wall" ;
: BOTTLES ." bottles of beer" ;

: ONE_LEFT ONE_ON_THE_WALL ."." CR ONE_ON_THE_WALL ."," CR BOTTLE1 
."," CR ; 
: ONE_ON_THE_WALL BOTTLE1 ." on the wall" ;
: BOTTLE1 ." 1 bottle of beer" ;

: ZERO TAKE ZERO_ON ."." CR ZERO_ON ."," CR  NO_MORE ."," CR
       ."go to the store, and buy some more!" CR ;
: ZERO_ON NO_MORE ." on the wall" ;
: NO_MORE ."no more bottles of beer" ;
: NUMBER_OFF C 2 TON ;
: NUMBER_OFF C 2 TON ;
</PRE>
<HR>
<P>
<P>
<CENTER>
<FONT SIZE=2><I>Compilation Copyright 1995, 1996, 1997 Tim Robinson.  All Rights Reserved
<BR>Permission to copy enthusiastically granted to instructors of computer science
<BR>(who would like to demonstrate the styles of different programming languages
<BR>to their students) provided that the names of the contributors are retained.</I></FONT SIZE>
</CENTER>
<BR><A HREF=beer_i_m.html>More beer</A>
<BR><A HREF=../index.html>Back to the Funhouse</A>
<P>
<P>
<P>
&nbsp;
<HTML>
<HEAD>
   <TITLE>99 Bottles of Beer on the Wall (I-M)</TITLE>
   <META NAME="Author" CONTENT="Tim Robinson">
</HEAD>
<BODY BACKGROUND="greenbar.gif" TEXT=#000000 BGCOLOR="#ffff00" LINK="#ff0000" VLINK="#007000" ALINK="#0077FF">
<UL>
<H2><A NAME="macwp">Macintosh WordPerfect</A></H2>
<PRE>

; Here is the Macintosh WordPerfect macro language version.

Assign (Var01;99)
Repeat
  Type Var (Var01)
  Type ( bottles of beer on the wall.  )
  Type Var (Var01)
  Type ( bottles of beer.  )
  Type (Take one down, pass it around.  )
  Assign (Var01;Var01-1)
  Type Var (Var01)
  Type ( bottles of beer on the wall.)
  Hard Return
Until (Var01=0)

</PRE>
<HR>
<H2><A NAME="m2">Modula 2</A></H2>
<PRE>
(* Modula-2 version of 99 Bottles of Beer            *)
(* Tested on a VAX 7700 running OpenVMS              *)
(* Programmer: Jeremy Rule  rulej@tempest.adsnet.net *)
MODULE BottlesOfBeer;

FROM InOut IMPORT WriteCard, WriteString, WriteLn;

CONST
        BOTTLES = 99;
VAR
        counter : CARDINAL;
BEGIN
        counter := BOTTLES;
        REPEAT
                WriteCard( counter,2 );
                WriteString(" bottles of beer on the wall, ");
                WriteCard( counter,2 );
                WriteString(" bottles of beer."); WriteLn;
                WriteString(" Take one down, and pass it around, ");
                DEC( counter );
                WriteCard( counter,2 );
                WriteString(" bottles of beer on the wall."); WriteLn;
        UNTIL ( counter = 1 );
        WriteString("1 bottle of beer on the wall, 1 bottle of beer"); WriteLn;
        WriteString("Take it down and pass it around, ");
        WriteString("No more bottles of beer on the wall."); WriteLn;

END BottlesOfBeer.

</PRE>
<HR>
<H2><A NAME="m3">Modula 3</A></H2>
<PRE>
MODULE BottlesOfBeer EXPORTS Main;
 
FROM IO  IMPORT Put ;
FROM Fmt IMPORT Int ;
 
VAR bottles := 99 ;
 
BEGIN
  WHILE (bottles &gt; 0) DO
    Put(Int(bottles) & " bottle(s) of beer on the wall,\n") ;
    Put(Int(bottles) & " bottle(s) of beer. \n") ;
    Put("Take one down, and pass it around,\n");
    DEC(bottles);
    Put(Int(bottles) & " bottle(s) of beer on the wall.\n");
  END ;
 
END BottlesOfBeer.
</PRE>
<HR>
<H2><A NAME="lpc">LPC</A></H2>
<I>LPC was originally conceived as a object oriented C-like language for writing
MUDs and being able to modify them on the fly.</I>
<PRE>
// beersong.c
// an implementation in the LPC language
// Tim Hollebeek, 6/6/95 - tim@debusy.Princeton.EDU

private string bottles(int n) {
    switch (n) {
    case 0: return "no more bottles of beer";
    case 1: return "1 bottle of beer";
    default: return n + " bottles of beer";
    }
}

void beersong() {
    for (int i = 99; i; i--) {
        write(bottles(i) + " on the wall, " + bottles(i)
	      + ", take one down, pass it around, "
	      + bottles(i - 1) + " on the wall.\n");
    }
}

</PRE>
<HR>
<H2><A NAME="mumps">Mumps</A></H2>
<PRE>
; The following is a single line of code
beer    ; Randy M. Hayman (haymanr@icefog.alaska.edu)
        for i=99:-1:1 w !,i," bottle",$S(i=1:"",1:"s")," of beer on the wa
ll, ",i," bottle",$S(i=1:"",1:"s")," of beer.",!,"Take one down, pass it a
round, ",i-1," bottle",$S(i=2:"",1:"s")," of beer on the wall.",!
</PRE>
<HR>
<H2><A NAME="itcl">ITCL</A></H2>
<PRE>
#!/usr/local/bin/itcl_sh
# [incr Tcl] version of "99 bottles of beer"
# Author: Steven Grady
# grady@xcf.berkeley.edu

itcl_class bottle {
	constructor {config} {
		incr numBottles
	}

	destructor {
		incr numBottles -1
	}

	method drink {} {
		puts "Take one down, pass it around,"
		$this delete
	}

	proc numBottleStr {} {
		switch $numBottles {
		  0 {
			return "No more bottles of beer"
		  }
		  1 {
			return "1 bottle of beer"
		  }
		  default {
			return "$numBottles bottles of beer"
		  }
		}
	}

	proc numBottles {} {
		return $numBottles
	}

	common numBottles 0
}

proc createBottles {numBottles} {
	for {set i 0} {$i &lt; $numBottles} {incr i} {
		bottle #auto
	}
}

createBottles 99
foreach b [itcl_info objects -class bottle] {
	set str [bottle :: numBottleStr]
	puts "$str on the wall, $str"
	$b drink
	puts "[bottle :: numBottleStr] on the wall."
}

</PRE>
<HR>
<H2><A NAME="m4">M4</A></H2>
<I>A Unix macro language.</I>
<PRE>
# by Ozan S. Yigit" (oz@sni.ca)
#
define(BOTTLES,`ifelse($1, 0, no more bottles,
			$1, 1, one bottle, $1 bottles) of beer') dnl
define(BEER,`ifelse(eval($1 &gt; 0), 1,
`BOTTLES($1) on the wall, BOTTLES($1)
take one down, pass it around
BOTTLES(eval($1 - 1)) on the wall.

BEER(eval($1 - 1))')') dnl

BEER(10)

</PRE>
<HR>
<H2><A NAME="java">Java</A></H2>
<I><A HREF=http://java.sun.com>Java</A> is a machine independent compiler based on C++ which targets to pseudo-code.</I>
<PRE>
// java version of 99 bottles of beer on the wall
// 1995 Sean Russell (ser@cs.uoregon.edu)

class bottles
{
  public static void main(String args[])
    {
    String s = "s";
    for (int beers=99; beers>-1;)
      {
      System.out.print(beers + " bottle" + s + " of beer on the wall, ");
      System.out.println(beers + " bottle" + s + " of beer, ");
      if (beers==0)
        {
        System.out.print("Go to the store, buy some more, ");
        System.out.println("99 bottles of beer on the wall.\n");
        System.exit(0);
        }
      else
        System.out.print("Take one down, pass it around, ");
      s = (--beers == 1)?"":"s";
      System.out.println(beers + " bottle" + s + " of beer on the wall.\n");
      }
    }
}
</PRE>
<HR>
<H2><A NAME="javascript">Java Script</A></H2>
<I>Interpretive <A href=#java>Java</a>.</I>
<PRE>
/**
 * 99 Bottles of Beer on the Wall in JavaScript
 * This program prints out the lyrics of an old pub song.
 * Copyright (C) 1996, Brian Patrick Lee (blee@media-lab.mit.edu)
 */
if (confirm("Are you old enough to read about beer\n" +
	    "according to your local community standards?")) {
  for (i = 99 ; i &gt; 0 ; i--) {
    j = i - 1;
    if (i != 1) { 
      icase = "bottles"; 
    } else { 
      icase = "bottle";
    }
    if (j != 1) {
      jcase = "bottles";
    } else {
      jcase = "bottle";
    }
    document.writeln(i + " " + icase + " of beer on the wall,");
    document.writeln(i + " " + icase + " of beer,");
    document.writeln("Take 1 down, pass it around,");
    if (j != 0) {
      document.writeln(j + " " + jcase + " of beer on the wall.");
    } else {
      document.writeln("No more bottles of beer on the wall!");
    }
    document.writeln()
  }
} else {
  document.write("You might want think about moving to another community.")
}
</PRE>
<HR>
<H2><A NAME="intercal">INTERCAL</A></H2>
<I>INTERCAL is a real language, apparently created with the notion that
programming ought to be hard.  Program courtesy Matt Dimeo.</i>
<PRE>
PLEASE DO ,10 <- #1
PLEASE DO ,10SUB#1 <- #176
PLEASE DO ,11 <- #30
PLEASE DO ,11SUB#1 <- #76
       DO ,11SUB#2 <- #190
       DO ,11SUB#3 <- #80
       DO ,11SUB#4 <- #200
PLEASE DO ,11SUB#5 <- #256
       DO ,11SUB#6 <- #248
       DO ,11SUB#7 <- #144
       DO ,11SUB#8 <- #216
PLEASE DO ,11SUB#9 <- #202
       DO ,11SUB#10 <- #14
       DO ,11SUB#11 <- #144
       DO ,11SUB#12 <- #98
PLEASE DO ,11SUB#13 <- #190
       DO ,11SUB#14 <- #160
       DO ,11SUB#15 <- #256
       DO ,11SUB#16 <- #88
PLEASE DO ,11SUB#17 <- #74
       DO ,11SUB#18 <- #14
       DO ,11SUB#19 <- #128
       DO ,11SUB#20 <- #114
PLEASE DO ,11SUB#21 <- #214
       DO ,11SUB#22 <- #24
       DO ,11SUB#23 <- #112
       DO ,11SUB#24 <- #162
PLEASE DO ,11SUB#25 <- #22
       DO ,11SUB#26 <- #104
       DO ,11SUB#27 <- #80
       DO ,11SUB#28 <- #256
PLEASE DO ,11SUB#29 <- #2
       DO ,11SUB#30 <- #228
PLEASE DO ,12 <- #49
PLEASE DO ,12SUB#1 <- #76
       DO ,12SUB#2 <- #190
       DO ,12SUB#3 <- #80
       DO ,12SUB#4 <- #200
PLEASE DO ,12SUB#5 <- #256
       DO ,12SUB#6 <- #248
       DO ,12SUB#7 <- #144
       DO ,12SUB#8 <- #216
PLEASE DO ,12SUB#9 <- #202
       DO ,12SUB#10 <- #14
       DO ,12SUB#11 <- #144
       DO ,12SUB#12 <- #98
PLEASE DO ,12SUB#13 <- #190
       DO ,12SUB#14 <- #160
       DO ,12SUB#15 <- #256
       DO ,12SUB#16 <- #88
PLEASE DO ,12SUB#17 <- #218
       DO ,12SUB#18 <- #36
       DO ,12SUB#19 <- #38
       DO ,12SUB#20 <- #164
PLEASE DO ,12SUB#21 <- #176
       DO ,12SUB#22 <- #48
       DO ,12SUB#23 <- #162
       DO ,12SUB#24 <- #14
PLEASE DO ,12SUB#25 <- #128
       DO ,12SUB#26 <- #208
       DO ,12SUB#27 <- #162
       DO ,12SUB#28 <- #222
PLEASE DO ,12SUB#29 <- #48
       DO ,12SUB#30 <- #8
       DO ,12SUB#31 <- #120
       DO ,12SUB#32 <- #66
PLEASE DO ,12SUB#33 <- #48
       DO ,12SUB#34 <- #246
       DO ,12SUB#35 <- #136
       DO ,12SUB#36 <- #184
PLEASE DO ,12SUB#37 <- #256
       DO ,12SUB#38 <- #202
       DO ,12SUB#39 <- #110
       DO ,12SUB#40 <- #104
PLEASE DO ,12SUB#41 <- #42
       DO ,12SUB#42 <- #126
       DO ,12SUB#43 <- #56
       DO ,12SUB#44 <- #88
PLEASE DO ,12SUB#45 <- #72
       DO ,12SUB#46 <- #56
       DO ,12SUB#47 <- #80
       DO ,12SUB#48 <- #242
PLEASE DO ,12SUB#49 <- #228
PLEASE DO ,13 <- #31
PLEASE DO ,13SUB#1 <- #76
       DO ,13SUB#2 <- #190
       DO ,13SUB#3 <- #80
       DO ,13SUB#4 <- #200
PLEASE DO ,13SUB#5 <- #256
       DO ,13SUB#6 <- #248
       DO ,13SUB#7 <- #144
       DO ,13SUB#8 <- #216
PLEASE DO ,13SUB#9 <- #202
       DO ,13SUB#10 <- #14
       DO ,13SUB#11 <- #144
       DO ,13SUB#12 <- #98
PLEASE DO ,13SUB#13 <- #190
       DO ,13SUB#14 <- #160
       DO ,13SUB#15 <- #256
       DO ,13SUB#16 <- #88
PLEASE DO ,13SUB#17 <- #74
       DO ,13SUB#18 <- #14
       DO ,13SUB#19 <- #128
       DO ,13SUB#20 <- #114
PLEASE DO ,13SUB#21 <- #214
       DO ,13SUB#22 <- #24
       DO ,13SUB#23 <- #112
       DO ,13SUB#24 <- #162
PLEASE DO ,13SUB#25 <- #22
       DO ,13SUB#26 <- #104
       DO ,13SUB#27 <- #80
       DO ,13SUB#28 <- #256
PLEASE DO ,13SUB#29 <- #194
       DO ,13SUB#30 <- #36
       DO ,13SUB#31 <- #256
PLEASE DO ,20 <- #10
PLEASE DO ,20 SUB #1 <- #76
       DO ,20 SUB #2 <- #196
       DO ,20 SUB #3 <- #4
       DO ,20 SUB #4 <- #132
PLEASE DO ,20 SUB #5 <- #36
       DO ,20 SUB #6 <- #164
       DO ,20 SUB #7 <- #228
       DO ,20 SUB #8 <- #100
PLEASE DO ,20 SUB #9 <- #52
       DO ,20 SUB #10 <- #180
PLEASE DO ,21 <- #10 BY #10
PLEASE DO ,21SUB#1#1 <- #248
PLEASE DO ,21SUB#1#2 <- #120
PLEASE DO ,21SUB#1#3 <- #184
PLEASE DO ,21SUB#1#4 <- #56
PLEASE DO ,21SUB#1#5 <- #216
PLEASE DO ,21SUB#1#6 <- #88
PLEASE DO ,21SUB#1#7 <- #152
PLEASE DO ,21SUB#1#8 <- #24
PLEASE DO ,21SUB#1#9 <- #232
PLEASE DO ,21SUB#1#10 <- #104
       DO ,21SUB#2#1 <- #128
       DO ,21SUB#2#2 <- #256
       DO ,21SUB#2#3 <- #64
       DO ,21SUB#2#4 <- #192
       DO ,21SUB#2#5 <- #96
       DO ,21SUB#2#6 <- #224
       DO ,21SUB#2#7 <- #32
       DO ,21SUB#2#8 <- #160
       DO ,21SUB#2#9 <- #112
       DO ,21SUB#2#10 <- #240
       DO ,21SUB#3#1 <- #64
       DO ,21SUB#3#2 <- #192
       DO ,21SUB#3#3 <- #256
       DO ,21SUB#3#4 <- #128
       DO ,21SUB#3#5 <- #32
       DO ,21SUB#3#6 <- #160
       DO ,21SUB#3#7 <- #224
       DO ,21SUB#3#8 <- #96
       DO ,21SUB#3#9 <- #48
       DO ,21SUB#3#10 <- #176
       DO ,21SUB#4#1 <- #192
       DO ,21SUB#4#2 <- #64
       DO ,21SUB#4#3 <- #128
       DO ,21SUB#4#4 <- #256
       DO ,21SUB#4#5 <- #160
       DO ,21SUB#4#6 <- #32
       DO ,21SUB#4#7 <- #96
       DO ,21SUB#4#8 <- #224
       DO ,21SUB#4#9 <- #176
       DO ,21SUB#4#10 <- #48
PLEASE DO ,21SUB#5#1 <- #32
PLEASE DO ,21SUB#5#2 <- #160
PLEASE DO ,21SUB#5#3 <- #224
PLEASE DO ,21SUB#5#4 <- #96
PLEASE DO ,21SUB#5#5 <- #256
PLEASE DO ,21SUB#5#6 <- #128
PLEASE DO ,21SUB#5#7 <- #192
PLEASE DO ,21SUB#5#8 <- #64
PLEASE DO ,21SUB#5#9 <- #16
PLEASE DO ,21SUB#5#10 <- #144
       DO ,21SUB#6#1 <- #160
       DO ,21SUB#6#2 <- #32
       DO ,21SUB#6#3 <- #96
       DO ,21SUB#6#4 <- #224
       DO ,21SUB#6#5 <- #128
       DO ,21SUB#6#6 <- #256
       DO ,21SUB#6#7 <- #64
       DO ,21SUB#6#8 <- #192
       DO ,21SUB#6#9 <- #144
       DO ,21SUB#6#10 <- #16
       DO ,21SUB#7#1 <- #96
       DO ,21SUB#7#2 <- #224
       DO ,21SUB#7#3 <- #32
       DO ,21SUB#7#4 <- #160
       DO ,21SUB#7#5 <- #64
       DO ,21SUB#7#6 <- #192
       DO ,21SUB#7#7 <- #256
       DO ,21SUB#7#8 <- #128
       DO ,21SUB#7#9 <- #80
       DO ,21SUB#7#10 <- #208
       DO ,21SUB#8#1 <- #224
       DO ,21SUB#8#2 <- #96
       DO ,21SUB#8#3 <- #160
       DO ,21SUB#8#4 <- #32
       DO ,21SUB#8#5 <- #192
       DO ,21SUB#8#6 <- #64
       DO ,21SUB#8#7 <- #128
       DO ,21SUB#8#8 <- #256
       DO ,21SUB#8#9 <- #208
       DO ,21SUB#8#10 <- #80
PLEASE DO ,21SUB#9#1 <- #16
PLEASE DO ,21SUB#9#2 <- #144
PLEASE DO ,21SUB#9#3 <- #208
PLEASE DO ,21SUB#9#4 <- #80
PLEASE DO ,21SUB#9#5 <- #240
PLEASE DO ,21SUB#9#6 <- #112
PLEASE DO ,21SUB#9#7 <- #176
PLEASE DO ,21SUB#9#8 <- #48
PLEASE DO ,21SUB#9#9 <- #256
PLEASE DO ,21SUB#9#10 <- #128
       DO ,21SUB#10#1 <- #144
       DO ,21SUB#10#2 <- #16
       DO ,21SUB#10#3 <- #80
       DO ,21SUB#10#4 <- #208
       DO ,21SUB#10#5 <- #112
       DO ,21SUB#10#6 <- #240
       DO ,21SUB#10#7 <- #48
       DO ,21SUB#10#8 <- #176
       DO ,21SUB#10#9 <- #128
       DO ,21SUB#10#10 <- #256
PLEASE DO ,22 <- #10
PLEASE DO ,22 SUB #1 <- #8
       DO ,22 SUB #2 <- #136
       DO ,22 SUB #3 <- #72
       DO ,22 SUB #4 <- #200
PLEASE DO ,22 SUB #5 <- #40
       DO ,22 SUB #6 <- #168
       DO ,22 SUB #7 <- #104
       DO ,22 SUB #8 <- #232
PLEASE DO ,22 SUB #9 <- #24
       DO ,22 SUB #10 <- #152
       DO .10 <- #9
       DO .11 <- #9
PLEASE DO ,10 <- #1
PLEASE DO ,10SUB#1 <- #176
       DO READ OUT ,10		
       DO COME FROM (999)	
       DO (500) NEXT		
PLEASE DO ,11SUB#1 <- .5	
       DO READ OUT ,11
       DO (500) NEXT		
       DO ,12SUB#1 <- .5	
PLEASE DO READ OUT ,12
PLEASE DO .6 <- '?"!10~.10'~#1"$#1'~#3
       DO (50) NEXT
PLEASE DO .7 <- '?"!11~.11'~#1"$#1'~#3		
       DO (70) NEXT
       DO .2 <- #1
       DO .1 <- .11
PLEASE DO (1010) NEXT		
       DO .11 <- .3
       DO (600) NEXT		
       DO (101) NEXT		
(70)   DO (71) NEXT
       DO .11 <- #9		
       DO .2 <- #1
PLEASE DO .1 <- .10
       DO (1010) NEXT		
       DO .10 <- .3
       DO (600) NEXT		
       DO (101) NEXT		
(71)   DO RESUME .7		
(50)   DO (51) NEXT
PLEASE DO FORGET #1
       DO .2 <- #1
       DO .1 <- .11
PLEASE DO (1010) NEXT		
       DO .11 <- .3
       DO (600) NEXT		
PLEASE DO .7 <- '?"!11~.11'~#1"$#1'~#3		
       DO (80) NEXT
       DO (101) NEXT
(80)   DO (81) NEXT
       DO GIVE UP
(81)   DO RESUME .7
(51)   DO RESUME .6		
(101) DO FORGET #1
(999) DO FORGET #1		
(600)  DO (500) NEXT		
       DO ,13SUB#1 <- .5	
       DO READ OUT ,13	
       DO RESUME #1
(500)  DO ,30 <- #1		
       DO .1 <- .10		
       DO (1020) NEXT		
PLEASE DO ,30SUB#1 <- ,20SUB.1  
       DO READ OUT ,30		
       DO .3 <- .1		
       DO .1 <- .11		
       DO (1020) NEXT		
PLEASE DO ,30SUB#1 <- ,21SUB .3 .1  
       DO READ OUT ,30		
       DO .5 <- ,22SUB.1	
PLEASE DO RESUME #1		
</PRE>
<HR>
<H2><A NAME="icon">Icon</A></H2>
<PRE>
# Scott E Gilbert &lt;scott@cs.arizona.edu&gt;
procedure main()
  t:= table("bottles")
  t[1]:= "bottle"
  every n:= 100 to 1 by -1 do {
    write(n, " ", t[n], " of beer on the wall.\n",
      n, " ", t[n], " of beer.\n",
      "Take one down, Pass it around.\n",
      n-1, " ", t[n-1], " of beer on the wall.\n"
    )
  }
end
</PRE>
<HR>
<H2><A NAME="matlab">MATLAB</A></H2>
<I><a href=http://www.mathworks.com>Click</a> for more information.</i>
<PRE>
% MATLAB verion of 99 Bottles of beer
% by Bill Becker

function beer(n);
if nargin<1, n=99; end
for i=n:-1:1,
  disp([int2str(i) ' Bottles of beer on the wall,'])
  disp([int2str(i) ' Bottles of beer,'])
  disp('Take one down and pass it around,')
  if i>1, disp([int2str(i-1) ' Bottles of beer on the wall.']),end
  end
disp('No more bottles of beer on the wall!')
</PRE>
<I>Here is a version contributed that shows the language in its
more "native" form.  (Cf. <a href=#cpp>C++</a>)</i>
<PRE>
% MATLAB *vectorized* version of "99 bottles of beer"
% Rich Stein (rich@cs.umbc.edu)

bottles = [98:-1:3]; % bottles 98 to 3 (99, 2 & 1 are treated as special case)
lines = 3; % need the number of bottles at the beginning of 3 lines

num_array = ones(lines,1) * bottles; % bottles is a (1x96) array

format_plural1 = '%d bottles of beer on the wall,\n%d bottles of beer,\n';
format_plural2 = 'Take one down, pass it around,\n%d bottles of beer on the wall.\n\n';
format_sing1 = '%d bottle of beer on the wall,\n%d bottle of beer,\n';
format_sing2 = 'Take one down, pass it around,\n%d bottle of beer on the wall.\n\n';
format_none2 = 'Take it down, pass it around,\nNo bottles of beer on the wall.\n';

% bottles 99, 2 & 1 are treated as special cases
fprintf([format_plural1 format_plural2], 99,99,num_array,2)
fprintf([format_plural1 format_sing2], 2,2,1)
fprintf([format_sing1 format_none2], 1,1)

</PRE>
<HR>
<H2><A NAME="msword">Microsoft Word</A></H2>
<i>The scripting language used for Microsoft Word</i>
<PRE>
Sub MAIN
REM "99 bottles of beer on the wall"
REM Microsoft Word WordBasic macro language version
REM written by Mark Pilgrim, f8dy@netaxs.com
FileNew
beer$ = "99"
bottle$ = " bottles "
For  count = 99 To 1 Step - 1
  Insert beer$ + bottle$ + "of beer on the wall,"
  InsertPara
  Insert beer$ + bottle$ + "of beer,"
  InsertPara
  Insert "Take "
  If count &gt; 1 Then
    Insert "one"
  Else
    Insert "it"
  End If
  Insert " down, pass it around,"
  InsertPara
  If count &gt; 1 Then
    beer$ = Str$(count - 1)
    beer$ = Right$(beer$, Len(beer$) - 1)
    If count = 2 Then bottle$ = " bottle "
    Insert beer$ + bottle$ + "of beer on the wall."
    InsertPara
  Else
    Insert "No more bottles of beer on the wall."
  End If
  InsertPara
Next
End Sub
</PRE>
<HR>
<H2><A NAME="mathematica">Mathematica</A></H2>
<i><a href=http://mathserv.math.sfu.ca/Software/MmaIntro.html>Mathematica</a>
is a computer algebra system.</i>
<PRE>
(* Mathematica version of 99 Bottles of Beer *)
(* Bill Dall *)
Do[If[i>1,
     Print[i, " more bottles of beer on the wall. ",i,
           " more bottles of beer."];
     Print["Take one down, pass it around."], 
     (* else *)
     Print["1 more bottle of beer on the wall. 1 more bottle of beer."]; 
     Print["Take one down, pass it around."];
     Print["No more bottles of beer on the wall."] 
     ], (* If *)
   {i,99,1,-1}]
</PRE>
<HR>
<H2><A NAME="logo"></A>Logo</H2>
<i>
<a href=http://www.inasec.ca/com/Logo/mainpb.htm>Logo</a> is a simple
language, suitable for teaching and famed for its "turtle" graphics.
<a href=http://http.cs.berkeley.edu/~bh/>More info</a>
</i>
<PRE>
; by Augusto Chioccariello
to 99bottles
for [i 99 1 -1] [
   print se :i [bottle(s) of beer on the wall]
   print se :i [bottle(s) of beer]
   print [take one down, pass it around]
   print se (:i - 1) [bottle(s) of beer on the wall]]
end
</PRE>
<HR>
<H2><A NAME="mops">Mops</A></H2>
<i><a href=http://www.netaxs.com/~jayfar/mops.html>Mops</a>
is a Forth-based OOP freeware package for developing Macintosh 
applications.</i>
<PRE>
\ Mops Beer (object paradigm)
\ by Bruce Bennett

:class BEER super{ object }

record{
          var   n
}

private

:m lastBottle:
        cr ." 1 last bottle of beer on the wall," cr
        ." Only 1 bottle of beer." cr
        ." Take it down, pass it around --" cr
        ." No more bottles of beer!" cr
;m

public

:m bottlesOf: { n -- }
        1 n DO
            i 1 = IF lastBottle: self LEAVE THEN cr
            i . ." bottles of beer on the wall," cr
            i . ." bottles of beer." cr
            ." Take one down, pass it around," cr
            i 2 = IF i 1 - . ." last bottle of beer." ELSE
            i 1 -  . ." bottles of beer on the wall." THEN cr
        -1 +LOOP
;m

;class

beer    beer!

99 bottlesOf: beer!
</PRE>
<HR>
<H2><A NAME="m5">M5</A></H2>
<PRE>
!rem 99 bottles of beer in the M5 macro language
!rem programmer Ron Franke-Polz - ronaldFP@aol.com
!rem
!rem define a macro which contains the song
!rem
!macro song
[v $1] [if [eq $1 1] "bottle" "bottles"] of beer on the wall,
[v $1] [if [eq $1 1] "bottle" "bottles"] of beer,
take one down and pass it around,
[if [eq [- $1 1] 1] "No more" [- $1 1]] [if [eq [- $1 1] 1] "bottle" "bottles"] of beer on the wall.

!endm
!rem
!rem sing the song 99 times
!rem
!eval [set count 99]
!while count
    !song (count)
    !eval [-- count]
!endwhile
</PRE>
<HR>
<H2><A NAME="ircii">IRC II</A></H2>
<i>This is the scripting language for Inter Relay Chat.</i>
<PRE>
alias bottles.start {
        while (1) {
                @ bottles.count = 99;
                while ( bottles.count )
                {
                        bottles.sayonwall ,
                        bottles.say
                        echo Take one down and pass it around
                        @ bottles.count = bottles.count - 1
                        bottles.sayonwall .
                        echo
                }
                echo No more bottles of beer on the wall,
                echo no more bottles of beer,
                echo Go to the store and buy some more,
                echo 99 bottles of beer on the wall.
                echo
        }
}

alias bottles.sayonwall echo $bottles.count bottles of beer on the wall$0
alias bottles.say echo $bottles.count bottles of beer,

bottles.start
</PRE>
<HR>
<H2><A NAME="life">LIFE</A></H2>
<i><A HREF=http://www.isg.sfu.ca/life/>LIFE</A>
is a constraint logic programming language.</i>
<PRE>
%% LIFE version of 99 Bottles of beer
%% by Denys Duchier duchier@cs.sfu.ca

how_many(0) -> "no more".
how_many(N) -> N.

action(0) -> 99  | write("Go to the store and buy some more.\n").
action(N) -> N-1 | write("Take one down, pass it around.\n").

bottles(1) -> "bottle".
bottles(N) -> "bottles".

sing(N) :-
  write(H:how_many(N)," ",B:bottles(N)," of beer on the wall, ",
        H," ",B," of beer.\n"),
  write(how_many(M:action(N))," ",bottles(M),
        " of beer on the wall.\n\n"),
  sing(M).
</PRE>
<HR>
<H2><A NAME="make">Make</A></H2>
<i>make is technically a tool for building applications, but it's amazing
what a pre-processor and recursion can do for you.</i>
<PRE>
#
#
# quick effort at 99 bottles program using gnu make
#
# the file must be called makefile.bottles
#
# Author: Andrew Dunstan (andrew.dunstan@its.maynick.com.au)
#
 
default:
        $(MAKE) -f makefile.bottles BOTTLES=99 bottles
 
.SILENT:
 
bottles:
        echo $(BOTTLES) bottles of beer on the wall
        echo $(BOTTLES) of beer
        echo Take one down and pass it around
ifeq ($(BOTTLES),0)
        echo No bottles of beer on the wall
else
        echo `expr $(BOTTLES) - 1` bottles of beer on the wall
        echo
        $(MAKE) -f makefile.bottles BOTTLES=`expr $(BOTTLES) - 1`  bottles
endif
</PRE>
<HR>
<H2><A NAME="maple">Maple V3</A></H2>
<PRE>
#
# Vanilla (non-graphical) version of 99 Bottles as sung 
# reluctantly by Maple V3, and only under the agreement that it
# will be called on to perform the song properly, in color, and with 
# appropriate animation... someday
#
# Authors: Hill and Burstall (handb@ionet.net)
#
lyrics:=(` Bottle`,` of beer on the wall! ` ,` of beer!  Take`, 
         ` down, pass it around...`):  
for i from 99 by -1 to 3 do   
     print(cat ( i ,lyrics[1],`s`,lyrics[2]), 
           cat(i, lyrics[1],`s`,lyrics[3],` one`,lyrics[4]), 
           cat(i-1,lyrics[1],`s`,lyrics[2]))   
                        od;
print(cat ( i ,lyrics[1],`s`,lyrics[2]), cat(i, lyrics[1],`s`,lyrics[3],` one`,
      lyrics[4]), cat(i-1,lyrics[1],lyrics[2]));
print(cat ( `1` ,lyrics[1],lyrics[2]), cat(`1`, lyrics[1],lyrics[3],` it`,
      lyrics[4]), cat(`0`,lyrics[1],`s`,lyrics[2]));
</PRE>
<HR>
<H2><A NAME="ml">ML</A></H2>
<PRE>
(* ML version of 99 bottles of beer                               *)
(*   - Using pattern of functions parameters                      *)
(*     and Recursion(like other functional programming langauges) *)

(* Written by Jong-Won Choi(jwchoi@gsen.goldstar.co.kr)           *)
(*                                                     Nov 13, 95 *)

fun NinetyNineBottlesOfBeer(0) =
  print("\n No more bottles of beer on the wall\n")
| NinetyNineBottlesOfBeer(1) = 
   (print("\n 1 bottle of beer on the wall, 1 bottle of beer.");
    print("\n Take one down and pass it around.");
    NinetyNineBottlesOfBeer(0))
| NinetyNineBottlesOfBeer(NumberOfBottles:int) =
   (print("\n "); print(NumberOfBottles);
    print(" bottle of beer on the wall, ");
    print(NumberOfBottles);
    print(" bottle of beer.");
    print("\n Take one down and pass it around.");
    NinetyNineBottlesOfBeer(NumberOfBottles - 1));
</PRE>
<HR>
<H2><A NAME="mercury">Mercury</A></H2>
<i>A purely declarative logic programming language.
<a href="http://www.cs.mu.oz.au/~zs/mercury.html">Click</a> 
for more information.</i>
<PRE>
% file: beer.m
% author: Fergus Henderson &lt;fjh@cs.mu.oz.au&gt;
% date: Thursday 9th November 1995

:- module beer.
:- interface.
:- import_module io.

:- pred main(io__state::di, io__state::uo) is det.

:- implementation.
:- import_module int.

main --> beer(99).

:- pred beer(int::in, io__state::di, io__state::uo) is det.

beer(N) -->
	( { N = 0 } ->
		io__write_string("Go to the store and buy some more!")
	;
		bottles(N),
		io__write_string(" on the wall,\n"),
		bottles(N),
		io__write_string(".\n"),
		io__write_string("Take one down, pass it around,\n"),
		{ N1 is N - 1 },
		bottles(N1),
		io__write_string(" on the wall.\n\n"),
		beer(N1)
	).

:- pred bottles(int::in, io__state::di, io__state::uo) is det.

bottles(N) -->
	( { N = 0 } ->
		io__write_string("No more bottles of beer")
	; { N = 1 } ->
		io__write_string("1 bottle of beer")
	;
		io__write_int(N),
		io__write_string(" bottles of beer")
	).

</PRE>
<HR>
<H2><A NAME="lingo">Lingo</A></H2>
<i>Lingo is Macromedia's Director scripting language.</i>
<PRE>
-- Lingo version of 99 Bottles of Beer 
-- programmer: John R. Nyquist SynapseDes@aol.com


on BottlesOfNABeer
  -- This handler outputs to the message window.
  
  set maxBottles to 99
  
  repeat with bottles = maxBottles down to 1
    set bottleString to WhichString(bottles)
    put bottleString & " of beer on the wall, " & bottleString & " of beer."
    put "Take one down, pass it around," 
    put WhichString(bottles - 1) & " of beer on the wall."
    put RETURN
  end repeat
  
  put "No bottles of beer on the wall, no bottles of beer."
  put "Go to the store and buy some more."
  put maxBottles & " bottles of beer on the wall."
  
end BottlesOfNABeer


on WhichString bottles
  
  if bottles > 1 then
    return bottles & " bottles"
  else if bottles = 1 then
    return "1 bottle"
  else
    return "No more bottles"
  end if
  
end WhichString 

</PRE>
<HR>
<H2><A NAME="inform">Inform</A></H2>
<I>Inform is a compiler meant for writing adventure games for the 
so-called "Z-machine" created by Infocom. 
<a href=http://www.doggysoft.co.uk/inform>Click here</a>
for more information.

</i>
<PRE>
! ---------------------------------------------------------------------------
!  99 Bottles of Beer on the Wall, Inform version [smaller]
!       _
!  Torbjorn Andersson, (d91tan@Minsk.DoCS.UU.SE) December 1995
! ---------------------------------------------------------------------------

! For technical reasons, the first function is not allowed to use local
! variables.

Global i = 99;

[ Main;
    print "^^^^";

    while (i &gt; 0) {
        new_line;
        print i, (char) ' ', (PluralBottle) i, " of beer on the wall,^";
        print (Chorus) i--;
        print "You take one down & pass it around^";
        print (Chorus) i;
    }

    @read_char 1 i;
    quit;
];

[ PluralBottle n;
    if (n == 1)
        print "bottle";
    else
        print "bottles";
];

[ Chorus n;
    print "  ";

    if (n == 0)
        print "No more";
    else
        print n;

    print_ret (char) ' ', (PluralBottle) n, " of beer";
];

end;

</PRE>
<HR>
<H2><A NAME="inform6">Inform 6</A></H2>
<I>Inform 6 is version 6 of a compiler meant for writing adventure games for the 
so-called "Z-machine" created by Infocom.  It seems to be more object oriented
than the original sent to me. 
<a href=http://www.doggysoft.co.uk/inform>Click here</a>
for more information.

</i>
<PRE>
! -----------------------------------------------------------------------------
! 99 Bottles of Beer on the Wall, Inform 6 version.
!
! Torbjrn Andersson, (d91tan@Student.DoCS.UU.SE), August 1997
! -----------------------------------------------------------------------------

Constant NUM_BOTTLES	99;

Object wall
  private
	bottles_left,
  with	init [ n;
	    self.bottles_left = n;
	],
	bottle_name [;
	    if (self.bottles_left == 1)
		return "bottle";

	    return "bottles";
	],
	bottle_count [;
	    return self.bottles_left;
	],
	take_one_down [;
	    self.bottles_left--;
	];

[ Main;
    wall.init(NUM_BOTTLES);

    while (wall.bottle_count() > 0) {
	print
	    "^",
	    wall.bottle_count(), " ", (string) wall.bottle_name(),
	    " of beer on the wall,^  ",
	    wall.bottle_count(), " ", (string) wall.bottle_name(),
	    " of beer^You take one down and pass it around^  ";

	wall.take_one_down();

	if (wall.bottle_count() == 0)
	    print "No more";
	else
	    print wall.bottle_count();

	print " ", (string) wall.bottle_name(), " of beer on the wall.^";
    }
];
</PRE>
<HR>
<H2><A NAME="kidsim">KidSim</A></H2>
<I>This is cool, but I couldn't really include the code for it here.
<a href=http://www.atg.apple.com/Allen_Cypher/99/>Click here</a>
for more information, including an animation of 99BoB's.
</i>
<P>
<IMG src=kidsim.gif>
<HR>
<H2><A NAME="idl">IDL</A></H2>
<I></i>
<PRE>
; The Bottles of Beer song (c) 1996 Eric Korpela (korpela@ssl.berkeley.edu)
; USAGE:  BOTTLES or BOTTLES, NUMBER
;
pro bottles, number
;
if not(keyword_set(number)) then begin
  number=99
  print,'BOTTLES: Defaulting to 99 bottles!'
endif
;
; Set up our song structure............
st1=replicate({n0:0,s1:' bottles of beer on the wall.',          $
               n1:0,s2:' bottles of beer.',                      $
               s3:'You take one down and pass it around.',       $
               n2:0,s4:' bottles of beer on the wall.'}, number)
;
; put in the appropriate numbers
i=(number-1)-indgen(number)
st1(*).n0=i+1
st1(*).n1=i+1
st1(*).n2=i
;
print,st1,format='(i3,a/i3,a/a/i3,a//)'
;
end
</PRE>
<HR>
<H2><A NAME="magicl">MAGIC/L</A></H2>
<I>A procedural language written in Forth.  Originally ran on Z80's
under CP/M and later available for IBM-PCs and Sun 3s.</i>
<PRE>
; MAGIC/L version of the beer bottle song 
; (c) 1996 Eric Korpela (korpela@ssl.berkeley.edu)
; WARNING! All the spaces are necessary!
;
; Add the help entry....
.subject bottles
Usage:  bottles ( number )
.
; and here's the procedure
define bottles 
  integer number
  local integer current
;
  current := number
  while ( current &gt; 1 )
    print current , " bottles of beer on the wall."
    print current , " bottles of beer."
    print "You take one down and pass it around."
    current := current - 1
    print current , " bottles of beer on the wall."
    print
  repeat
;
  print 1 , " bottle of beer on the wall."
  print 1 , " bottle of beer."
  print "You take one down and pass it around."
  print "No bottles of beer on the wall.
end
</PRE>
<HR>
<H2><A NAME="metahtml">Meta-HTML</A></H2>
<I></i>
<PRE>
&lt;html&gt;
&lt;head&gt; &lt;title&gt; 99 Bottles of Beer: The Compleat Lyrics &lt;/title&gt; &lt;/head&gt;
&lt;body&gt;

;;;
;;; The actual source code to The Compleat Lyrics.
&lt;defsubst plural whitespace=delete&gt;
  &lt;if &lt;not &lt;eq %0 1&gt;&gt; s&gt;
&lt;/defsubst&gt;

&lt;set-var beers=99&gt;
&lt;while &lt;gt beers 0&gt;&gt;
  &lt;get-var beers&gt; bottle&lt;plural beers&gt; of beer on the wall, &lt;br&gt;
  &lt;get-var beers&gt; bottle&lt;plural beers&gt; of beer, &lt;br&gt;
  You take one down, pass it around, &lt;br&gt;
  &lt;decrement beers&gt;
  &lt;get-var beers&gt; bottle&lt;plural beers&gt; of beer on the wall.
  &lt;p&gt;
&lt;/while&gt;

No more bottles of beer on the wall, &lt;br&gt;
No more bottles of beer, &lt;br&gt;
Go to the store, and buy some more, &lt;br&gt;

&lt;form method=GET action="&lt;get-var mhtml::current-url&gt;"&gt;
  &lt;input type="submit" name="button" value="99 Bottles of beer on the wall"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</PRE>
<HR>
<H2><A NAME="mush">MUSH/TinyTIM/TinyMUSH</A></H2>
<I>Heaven help us!  Stuff to program multi-user games on the net.</i>
<PRE>
A bunch of drunk engineers(#54326)
Owner: eric.korpela Key: eric.korpela(#54351PeoZ)  Money: 2
You see a bunch of engineers from a south bay firm who look like they've had a 
bit too much to drink. They are random walking all over town, stopping where 
ever they can find approprate beverages. I bet they'd sing "99 bottles of 
beer" if you asked them to.

Listen: *sing*99*

Ahear: use me;
       @wait 3={
          @while gt(V(vi),1)={
            @if eq(V(vj),V(vi))=think,{@trigger me/vy;@decrement me/vj}
          };
          @wait DONE=:collapses into an algoholic stupor.
       }

VY: say concat(V(vi),bottles of beer on the wall!); 
    say concat(V(vi),bottles of beer.); 
    say You take one down, and pass it around; 
    @decrement me/vi; 
    say concat(V(vi),bottles of beer on the wall.);
    @emit

Ause: @vi me=99;@vj me=100

Ouse: takes a deep breath and begins to sing.

Scent: They smell of 43 different types of liquor.

Functions: #69
</PRE>
<HR>
<H2><A NAME="kuip">KUIP</A></H2>
<PRE>
*******************************************
* KUIP version of 99 bottles of beer      *
* r.p.hofmann f15rph@ips105.desy.de       *
* http://ips105.desy.de:8765/             *
*******************************************
* about KUIP:                             *
* R.Brun, P.Zanarini                      *
* KUIP - Kit for a User Interface Package *
* Program library I202. CERN 1988         *
*******************************************

macro beer nbott=99 ndown=1

  if [ndown] &gt; 0 goto ndok
  ndown=-[ndown]
ndok:
  if [ndown] &gt; 1 goto mored
  alias/create pron it
  goto oned
mored:
  alias/create pron them
oned:
  if [nbott] &lt; 1 goto end
  if [nbott] = 1 goto one
  alias/create bob 'bottles of beer'
  alias/create otw 'on the wall'
pass:
  mess [nbott] bob otw
  mess [nbott] bob
  mess take [ndown] down and pass pron all around 
  nbott=[nbott]-[ndown]
  if [nbott] &lt;&gt; 1 goto moreb
  mess 1 bottle of beer otw
  goto oneb
moreb:  
  mess [nbott] bob otw
oneb:
  if [ndown] = 0 goto end
  if [nbott] &gt; 1 goto pass
  if [nbott] &lt; 1 goto end
one:
  mess 1 bottle of beer otw
  mess 1 bottle of beer
  mess take [ndown] down and pass pron all around
  nbott=1-[ndown]
  mess [nbott] bottles of beer otw
  if [nbott] &lt; 1 goto end
end:
</PRE>
<HR>
<H2><A NAME="moo">MOO</A></H2>
<PRE>
@args #230:"@99" none none none
@chmod #230:@99 rxd
@program #230:@99
"Programmed by Malcolm Gin-Hopwood y Silva (perigee@dgsys.com)";
"Runs on LambdaMOO core 1.7.9 and 1.8.0";
"This one spares any standers by the terror of 99 bottles of beer on the wall,
and does numbers to english passing as well.  Woo woo.";
count = 99;
while (count &gt; 0)
  $command_utils:suspend_if_needed(0);
  this:_round_of_beer(count);
  count = count - 1;
endwhile
player:tell("Time to buy more beer.");
.

@args #230:"_round_of_beer" this none this
@program #230:_round_of_beer
beer = args[1];
player:tell(($string_utils:capitalize($string_utils:english_number(beer)) +
((beer == 1) ? " bottle " | " bottles ")) + "of beer on the wall.");
player:tell(($string_utils:capitalize($string_utils:english_number(beer)) +
((beer == 1) ? " bottle " | " bottles ")) + "of beer...");
player:tell("Take one down and pass it around.");
player:tell(($string_utils:capitalize($string_utils:english_number(beer - 1))
+ (((beer - 1) == 1) ? " bottle " | " bottles ")) + "of beer on the wall.");
player:tell();
.
</PRE>
<HR>
<H2><A NAME="markiv">Mark IV</A></H2>
<PRE>
BEER    RCDUMMYFD S U   S    T      R                                           
BEER    RFSUBFILE SM4SUBF1                                                      
BEER    ERDATE                                                                  
BEER    AA
BEER    AA   <a href http://www.cstp.umkc.edu/users/mpasser>Michael Passer</a>
BEER    AA
BEER    AA   This program requires one dummy record of input
BEER    AA   (the M4OLD DD) to trigger execution.  Output is
BEER    AA   sent to the first subfile (M4SUBF1 DD).
BEER    AA
BEER    TFBOTTLESZ  3Z      100
BEER    AA                  ----+----1----+- 
BEER    TFBOB      15C      BOTTLES OF BEER                                     
BEER    TFOTW      11C      ON THE WALL                                         
BEER    TFTOD      13C      TAKE ONE DOWN                                       
BEER    TFPIA      14C      PASS IT AROUND                                      
BEER    TFCOMMA     1C      ,                                                   
BEER    TFPERIOD    1C      .                                                   
BEER    TFBLANK     1C                                                          
BEER    PR              GO SUB SING                                             
SING    ERDATE                                         S          100           
SING    PR     TBOTTLESZEQD0                                                    
SING    PR              GS RETURN                                               
SING    PR              GO SUB CHORUS                                           
SING    PR              R TMINUS1Z                        TBOTTLESZ             
SING    PR              GO REQUEST SING                                         
CHORUS  ERDATE                                         S                        
CHORUS  TFMINUS1Z   3Z                                                          
CHORUS  TFBOTTLES   3C                                                          
CHORUS  TFMINUS1    2C                                                          
CHORUS  PR     TBOTTLESZ- D1                              TMINUS1Z              
CHORUS  PR              R TBOTTLESZ                       TBOTTLES              
CHORUS  PR              R TMINUS1Z                        TMINUS1               
CHORUS  E1                              NR SUBFILE     V                        
CHORUS  R1     TBOTTLES                                                         
CHORUS  R1     TBLANK                                                           
CHORUS  R1     TBOB                                                             
CHORUS  R1     TBLANK                                                           
CHORUS  R1     TOTW                                                             
CHORUS  R1     TCOMMA                                                           
CHORUS  E2                              NR SUBFILE     V                        
CHORUS  R2     TBOTTLES                                                         
CHORUS  R2     TBLANK                                                           
CHORUS  R2     TBOB                                                             
CHORUS  R2     TCOMMA                                                           
CHORUS  E3                              NR SUBFILE     V                        
CHORUS  R3     TTOD                                                             
CHORUS  R3     TCOMMA                                                           
CHORUS  R3     TBLANK                                                           
CHORUS  R3     TPIA                                                             
CHORUS  R3     TCOMMA                                                           
CHORUS  E4                              NR SUBFILE     V                        
CHORUS  R4     TMINUS1                                                          
CHORUS  R4     TBLANK                                                           
CHORUS  R4     TBOB                                                             
CHORUS  R4     TBLANK                                                           
CHORUS  R4     TOTW                                                             
CHORUS  R4     TPERIOD                                                          
CHORUS  E5                              NR SUBFILE     V                        
CHORUS  R5     TBLANK                                                           
</PRE>
<HR>
<H2><A NAME="ismsml">ISM/SML</A></H2>
<I>SML is the language used in ISM/Openmaster, the BULL Administrative 
Platform.  ISM/SML (for Integrated System Management / System Management 
Language).</i>
<PRE>
; Code Begin
; A.Brunet@frcl.bull.fr (Alain Brunet)

(defun beer(cap)
  (dotimes (i cap)
    (print (- cap i) " bottle" (if (= i (- cap 1)) "" "s") " of beer on the wall.")
    (print "Take one down, pass it around.\n")
  )
  (print "Time to buy more beer !")
)

(beer 99)
</PRE>
<HR>
<H2><A NAME="ksh">Korn Shell</A></H2>
<I>Yet another UN*X shell.</i>
<PRE>
#!/bin/ksh
# Korn shell version of 99 Bottles
# Dave Plonka - plonka@carroll1.cc.edu

typeset -i n=99
typeset bottles=bottles
typeset no

while (( n ))
do
   print "${n?} ${bottles?} of beer on the wall,"
   print "${n?} ${bottles?} of beer,\ntake one down, pass it around,"
   n=n-1
   case ${n?} in
   0)
      no=no
      bottles=${bottles%s}s
      ;;
   1)
      bottles=${bottles%s}
      ;;
   esac
   print "${no:-${n}} ${bottles?} of beer on the wall.\n"
done

exit
</PRE>
<HR>
<H2><A NAME="labview">LabVIEW</A></H2>
<i>An icon based language.  
<a href=http://www.phy.ohiou.edu/~antel/beer.html>Click</a>
for more information</i>
<IMG src=labview.gif width=472 height=431>
<HR>
<H2><A NAME="leda">Leda</A></H2>
<i>Leda is a multiparadigm programming language           
designed by Timothy A. Budd.  It supports imperative,
object-oriented, functional and logic programming
paradigms.

<a href=http://www.cs.orst.edu/~budd/vita/ledatoc.htm>Click here </a>
for Information and an interpreter.</i>
<PRE>
{ 99 bottles of beer, Leda version  }
{ By Arion Lei (philipl@cs.ust.hk)  }

include "std.led";

const
  verse1 := " bottles of beer on the wall,\n";
  verse2 := " bottles of beer.  Take one down, pass it around,\n";
  verse3 := " bottles of beer on the wall.\n";
  verse4 := "No more bottles of beer on the wall, no more bottles of beer.\n";
  verse5 := "Go to the store and buy some more... 99 bottles of beer.\n\n";

{ ========== IMPERATIVE PROGRAMMING =========== }

function proc_Beer (bottleTotal : integer);
var bottleLeft : integer;
begin
  bottleLeft := bottleTotal;
  while bottleLeft>0 do begin
    print(bottleLeft);  print(verse1);
    print(bottleLeft);  print(verse2);
    bottleLeft := bottleLeft - 1;
    if (bottleLeft>0) then begin
      print(bottleLeft);  print(verse3);
    end;
  end;
  print(verse4);
  print(verse5);
end; { proc_Beer }


{ ========== OBJECT-ORIENTED PROGRAMMING =========== }

class Beers;
var
  bottleLeft : integer;

  function more () -> boolean;
  begin
    return bottleLeft &gt; 0;
  end;

  function consume1 ();
  begin
    print(bottleLeft);  print(verse1);
    print(bottleLeft);  print(verse2);
    bottleLeft := bottleLeft - 1;
    if (bottleLeft>0) then begin
      print(bottleLeft);  print(verse3);
    end else begin
      print(verse4);
      print(verse5);
    end;
  end;
end; { class Beers }

function obj_Beer (bottleTotal : integer);
var obeer : Beers;
begin
  obeer := Beers(bottleTotal);
  while (obeer.more()) do obeer.consume1();
end; { obj_Beer }


{ ========== FUNCTIONAL PROGRAMMING =========== }

function func_Beer (num : integer) -> function();
begin
  return function ();
    begin
      print(num);  print(verse1);
      print(num);  print(verse2);
      if num>1 then begin
        print(num-1);  print(verse3);
        func_Beer(num-1)();
      end else begin
        print(verse4);
        print(verse5);
      end;
    end;
end; { func_Beer }


{ ========== LOGIC PROGRAMMING =========== }

function log_Beer (bottleTotal : integer);

  function pickBottle (byRef left : integer, total : integer)->relation;
  begin
    if total = 0 then 
      return false
    else 
      return left <- total | pickBottle(left, total-1);
  end;
  
  function consume (i : integer)->relation;
  begin
    print(i);  print(verse1);
    print(i);  print(verse2);
    if i>1 then begin
      print(i-1); print(verse3);
    end else begin
      print(verse4);
      print(verse5);
    end;
    return true;
  end;

var i : integer;
begin
  for pickBottle(i, bottleTotal) & consume(i) do begin end;
end; { log_Beer }


{ ---------- MAIN PROGRAM ---------- }

var bottleTotal : integer;

begin
  bottleTotal := 99;
  proc_Beer (bottleTotal);
  obj_Beer (bottleTotal);
  func_Beer(bottleTotal)();
  log_Beer(bottleTotal);
end;
</PRE>
<HR>
<H2><A NAME="limbo">Limbo</A></H2>
<i>Limbo is compiler for Lucent Technologies new
Inferno Operating System.</i>
<PRE>
implement BeerBottles;

include "sys.m";
	sys: Sys;
include "draw.m";
	draw: Draw;

BeerBottles: module
{
	init: fn(ctxt: ref Draw->Context, agv: list of string);
};

init(ctxt: ref Draw->Context, argv: list of string)
{
	sys = load Sys Sys->PATH;
	for (int bottles = 99; bottles &gt; 0; bottles--) {
		sys->print("%d bottle(s) of beer on the wall,\n",bottles);
		sys->print("%d bottle(s) of beer.\n",bottles);
		sys->print("Take one down, pass it around,\n");
		sys->print("%d bottle(s) of beer on the wall.\n\n");
	}
}
</PRE>
<HR>
<H2><A NAME="mspeak">M-Speak</A></H2>
<i>M-Speak is a word-processing macro language created in the
late 1970's for the Spellbinder word processor.  </i>
<PRE>
;-)   Spellbinder Macro to print "99 Bottles of Beer on the Wall"   (-;
; by Andy Goldberg
;
:%A="s"                                         ;set variable for plural
:%1=99                                          ;initialize counter
:%2=%1-1                                        ;decrement at top of loop
s//%1 bottle%A of beer on the wall&lt;/            ;lyric
s//%1 bottle%A of beer&lt;/&lt;
s//Take one down and pass it around&lt;/
:on %2-1 /+4 / /+1                              ;check for last stanza
:%A=""                                          ;if last stanza clear plural
s//%2 bottle%A of beer on the wall.&lt;&lt;/          ;last line and blank line
:%1=%1-1                                        ;check for end
:on -1 /-9                                      ;if not end then loop
s//No more bottles of beer on the wall.&lt;/       ;ending line  
/t/p/wo/song.txt/t/gd                           ;print, save and end (optional)
</PRE>
<HR>
<H2><A NAME="metapost">MetaPost</A></H2>
<i>For more information on MetaPost see 
<a href=http://cm.bell-labs.com/who/hobby/MetaPost.html>
http://cm.bell-labs.com/who/hobby/MetaPost.html</a></i>
<PRE>
% MetaFont/MetaPost version of ``99 bottles'' by Tomasz J. Cholewo
% For more information see http://cm.bell-labs.com/who/hobby/MetaPost.html
for i:=99 downto 1:
  message decimal i & " bottle" if i>1: & "s" fi & " of beer on the wall,";
  message decimal i & " bottle" if i>1: & "s" fi & " of beer.";
  message "Take one down, pass it around.";
endfor;
message "No more bottles of beer on the wall.";
end
</PRE>
<HR>
<H2><A NAME="ile">ILE AS/400</A></H2>
<i>This is IBM's next generation of <a href="#rpg">RPG</a>.</i>
<PRE>
H*
H*  ILE RPG/400 - 99 Bottles of Beer on the Wall.
H*  (IBM AS/400 Midrange Platform)
H*  (Program Source BOTTLESR1)
H*
FBottlesS1 O    E             WorkStn
C
C                   Z-Add     *HIVAL        Bottles1
C
C                   DoW       Bottles1 > *Zero
C                   Eval      Bottles2 = Bottles1
C                   Write     #Display
C                   Sub       1             Bottles1
C                   EndDo
C
C                   Eval      *InLR = *On
C

-----------------------

A*
A*  ILE RPG/400 - 99 Bottles of Beer on the Wall.
A*  (IBM AS/400 Midrange Platform)
A*  (Display File Source BOTTLESS1)
A*
A                                      DSPSIZ(24 80 *DS3)
A          R #DISPLAY                  FRCDTA
A
A            BOTTLES1       2Y 0O  4  2EDTCDE(4)
A                                  4  5'Bottles of Beer On the Wall,'
A            BOTTLES2       2Y 0O  4 34EDTCDE(4)
A                                  4 37'Bottles of Beer,'
A                                  5  2'Take one down, pass it around.'
A
</PRE>
<HR>
<H2><A NAME="mptmon">MPTMON</A></H2>
<i></i>
<PRE>
; MPTMON (Multi Processor Test Monitor) is a debugging
; tool for telephonic exchanges from Alcatel.
; These two macros do the beer job..
REM MAC Bottle
DEF MAC Bottle
  WR %0,' Bottle',&
  IF %0<>1\'s',&
  END
  ' of Beer',&
  IF %1\' on the Wall',&
  END
  '%2'
EM
REM MAC Beer
DEF MAC Beer ; jr_31jan97
ADD SYM.I=99T
BAS=T
COU 99T
  Bottle:.I,TRUE,','
  Bottle:.I,FALSE,'.'
  '    Take one down, pass it around,'
  .I=.I-1
  Bottle:.I,TRUE,'.'
 ''
END
EM
Beer:
</PRE>
<HR>
<H2><A NAME="m204">Model 204</A></H2>
<PRE>
*Model 204 (or M204 as it's commonly called) is a proprietary
*database and language of Computer Corporation of America.
*It was first developed over 30 years ago by the NSA.
*Some claim that it's the fastest IBM Mainframe database.
*It is good for databases with large record counts.
*The Department of Social Security of Australian employs
*hundreds of M204 programmers.
*Add-on packages permit SQL and Web access.
*
* Written by Kevin Giles, NCI Information Systems Inc.
* e-mail: KGILES@USGS.GOV
*
* 100 bottles of beer / take one / action
*
*LOWER
BEGIN
DECLARE %S IS STRING LEN 1 COMMON
FOR %BOTTLE FROM 100 TO 0 BY -1
  CALL CHECKPLURAL(%BOTTLE)
  PRINT %BOTTLE AND 'bottle' WITH %S AND 'of beer on the wall.'
  PRINT %BOTTLE AND 'bottle' WITH %S AND 'of beer.'
  PRINT 'Take one down, pass it around.'
  CALL CHECKPLURAL(%BOTTLE-1)
  IF %BOTTLE-1 = +0 THEN PRINT 'No bottles of beer on the wall.'
      SKIP 1 LINE
      PRINT 'No bottles of beer on the wall.'
      PRINT 'No bottles of beer.'
      PRINT 'Go to the store, buy some more.'
      %BOTTLE = 101
      CALL CHECKPLURAL(%BOTTLE-1)
  END IF
  PRINT $UNBLANK(%BOTTLE-1) AND 'bottle' WITH %S AND -
                     'of beer on the wall.'
  SKIP 1 LINE
END FOR
SUBROUTINE CHECKPLURAL (%PASSVAL STRING DP 0 INPUT)
  IF %PASSVAL NE +1 THEN  %S = 's'
  ELSE                    %S = ''
  END IF
END SUBROUTINE
END
</PRE>
<HR>
<H2><A NAME="miranda">Miranda</A></H2>
<PRE>
|| 99 bottles of beer in Miranda - the hideous functional programming lingo
|| by Tim Walls, tjw1@doc.ic.ac.uk, http://www-students.doc.ic.ac.uk/~tjw1/
||
|| Call with 'bottlesofbeer 99'.
bottlesofbeer :: num -&gt; [char]

bottlesofbeer n = "\nNo more bottles of beer on the wall, \n"		
		       ++ "no more bottles of beer.\n"	, if n = 0
		= "\nOne more bottle of beer on the wall, one bottle of beer,\n"
		       ++ "Take one down and pass it around"
		       ++ (bottlesofbeer (n-1))		, if n = 1
		= "\n" ++ shownum(n) ++ " bottles of beer on the wall,"
		       ++ shownum(n)
		       ++ " bottles of beer,\nTake one down and pass it around"
		       ++ (bottlesofbeer (n-1))		, otherwise
</PRE>
<HR>
<H2><A NAME="k">K</A></H2>
<i></i>
<PRE>
s:" bottles of beer on the wall,  bottles of beer.
If  bottles should happen to fall,
 bottles of beer on the wall.

"
d:{`0:,/|(r[];u[]),n'|3_!x+1}
r:{k[(1;1;"that";"No more")]_di 8 39 64}
u:{n[2]_di 105}
n:{k(x;x;"one of those";x-1)}
k:{,/($x),'0 30 51 83_ s}
</PRE>
<HR>
<H2><A NAME="lakota">Lakota</A></H2>
<i>Lakota is a
shell language used mainly in the TRUEchange configuration management
package from True Software.  Code courtesy Beirne "Bern" Konarski.
</i>
<PRE>
#! /usr/local/lsh

set-string s s
set-string item one
do i 99 1 -1
    print (i) bottle(s) of beer on the wall,
    print (i) bottle(s) of beer.
    print You take (item) down, pass it around,
    set-string j {- (i) 1}
    if {=? (j) 1}
        set-string s
        set-string item it
    if {=? (i) 1}
        print No more bottles of beer on the wall.(newline)
    else
        print (j) bottle(s) of beer on the wall.(newline)
    cycle
</PRE>
<HR>
<H2><A NAME="luck">Luck</A></H2>
<i><A HREF=http://www.isg.sfu.ca/life/>Luck</A>
is custom programming language.  99BoB code contributed
by the creator.</i>
<PRE>
luck: Beer99
proc: main
  new #bottles = 99
  loop: #bottles > 0

saysolo #bottles
    say " bottle(s) of beer on the wall."
    saysolo
#bottles
    say " bottle(s) of beer."
    say "Take one down and pass it
around."
    #bottles = #bottles - 1
    if: #bottles = 0
      saysolo "No
more"
    end
    if: #bottles > 0
      saysolo #bottles
    end
    say "
bottle(s) of beer on the wall."
    say
  end
end
</PRE>
<HR>
<H2><A NAME="magma">Magma</A></H2>
<i>Magma is a computer algebra system from Australia.</i>
<PRE>
verse := function(n)
    bottles := function(n)
	return n eq 1 select "1 bottle" 
                      else IntegerToString(n) cat " bottles";
    end function;

    return current cat " of beer on the wall,\n" cat
	   current cat " of beer;\n" cat
           "Take one down, pass it around,\n" cat
	   bottles(n - 1) cat " of beer on the wall.\n\n"
		where current is bottles(n);
end function;

song := procedure()
    print &cat [verse(n) : n in [99 .. 1 by -1]] cat 
	  "Go to the store and get some more.";
end procedure;
</PRE>
<HR>
<H2><A NAME="jam">Jam</A2></H2>
<i>Jam is a make-like system for building programs, etc.</i>
<PRE>
# Jamfile for 99 Bottles of beer on the wall.
# David Brandon (brandon@aspentech.com)

ALWAYS beer ;

rule Drink {
    for tenbeers in 9 8 7 6 5 4 3 2 1 "" {
        for beers in 9 8 7 6 5 4 3 2 1 0 {
            b = $(tenbeers)$(beers) ;
            if ( $(b) != 99 ) {
                ECHO "$(b) bottles of $(<) on the wall!" ;
            }
            if ( $(b) = 0 ) {
                EXIT "No more $(<)!" ;
            }
            ECHO "$(b) bottles of $(<) on the wall. $(b) bottles of $(<). Take one down," ;
            ECHO "pass it around..." ;
        }
    }
}

Drink beer ;
</PRE>
<HR>
<H2><A NAME="kermit">Kermit Script</A></H2>
<i>In case you missed it, Kermit is the communications program that
seems to have been ported to just about everything, from the Timex Sinclair
to the Cray II.</i>
<PRE>
comment --- 99 bottles of beer, in Kermit scripting language.
comment --- Execute by using the TAKE command in Kermit, or naming
comment --- this file with the default initialization file name.
comment --- 23-Sep-1997 --- Scott Snadow, snadow@eisner.decus.org

set count 99
:loop
if < \v(count) 99 echo \v(count) bottle(s) of beer on the wall.
echo
echo \v(count) bottle(s) of beer on the wall, \v(count) bottle(s) of beer.
echo Take one down, pass it around,
if count goto loop
echo No bottles of beer on the wall.
</PRE>
<HR>
<P>
<P>
<UL>
<H2><A NAME="navel">Navel</A></H2>
<PRE>
# Bottles of beer in Navel
  Greg Michaelson
  greg@cee.hw.ac.uk #

def itos n = if n=0 then "0" else itos1 "" n;
def itos1 l n = if n=0 then l else itos1 (char (n%10+'0')):l n/10;
def verse n = {(itos n) " bottle(s) of beer on the wall\n"
               (itos n) " bottle(s) of beer on the wall\n"
               "Take one down and pass it around\n"
               (itos n-1) " bottle(s) of beer on the wall\n"};
def verses n = 
 if n=0
 then ()
 else
  let v = write (?(verse n))
  in verses n-1;
</PRE>
<HR>
<H2><A NAME="postscript">Postscript</A></H2>
<i>Postscript has two significant "modes."  One is interactive, the other
is document printing/typesetting.  Belows are samples of both kinds of code.
</i>
<PRE>
% How to do 99 Bottles of Beer in Postscript.
% This doesn't go out to the printer. You'd need to hook a serial port
% to your LaserPrinter or Postscript typesetter
/beer {
  /bottles 7 string def
  99 -1 1
  { dup bottles cvs print ( bottles of beer on the wall, )
  bottles print (bottles of beer.  Take one down, pass it around, )
  1 sub bottles cvs print ( bottles of beer on the wall. )
  } for 
  (No more bottles of beer on the wall, no more bottles of beer.  )
  (Go to the store and buy some more... 99 bottles of beer) } def
</PRE>
<HR>
<H2><A NAME="pascal">Pascal</A></H2>
<PRE>
(* Pascal version of 99 Bottles of beer *)
program BottlesOfBeers(input, output);
var
  bottles: integer;
begin
  bottles := 99;
  repeat
    WriteLn(bottles, ' bottles of beer on the wall, ',
            bottles, ' bottles of beer.');
    Write('Take one down, pass it around, ');
    bottles := bottles-1;
    WriteLn(bottles, ' bottles of beer on the wall.');
  until (bottles = 1);
  WriteLn('1 bottle of beer on the wall, one bottle of beer.');
  WriteLn('Take one down, pass it around,'
          ' no more bottles of beer on the wall')
end.
</PRE>
<i> ---- Printable version ---- </i>
<PRE>
     %!PS
     
     % The 99 bottles of beer song in PostScript. This file
     % can be sent to a PostScript printer (it'll be about
     % eight pages or so...)
     
     % Stuart Morris
     
     % ------------- Variables & Procedures ------------
     
     /LM 72 def           % left margin
     /ypos 720 def        % initial top position
     /BM 72 def           % bottom margin
     /lineheight 18 def   % height of a line of text
     
     % starts a new line
     
     /crlf
     {
       ypos lineheight sub
       /ypos exch def
       LM ypos moveto
         
     } def
     
     % starts a new page if current one is full
     
     /newpage? 
     {
       ypos BM lt
       {
         showpage
         /ypos 720 def
         LM ypos moveto
     
       } if
     
     } def
     
     % returns the correct syntax of the bottle
     % string ("bottle" if one, "bottles" otherwise)
     
     /bottlestring  % stack: number of bottles
     {
       1 eq
       {
         ( bottle of beer)
       }
       {
         ( bottles of beer)
     
       } ifelse
     
     } def
     
     % ------------- Main Program ----------------
     
     LM ypos moveto
     
     /Times-Roman findfont 
       lineheight 2 sub scalefont 
       setfont
     
     99 -1 1
     {
       /numbottles 2 string def
       dup numbottles cvs show
       
       dup bottlestring show ( on the wall, ) show
       numbottles show dup bottlestring show (,) show
       crlf
     
       (Take one down, pass it around, ) show
       1 sub dup numbottles cvs show
       
       bottlestring show ( on the wall.) show
       crlf crlf
       newpage?
     
     } for
     
     showpage
</PRE>
<HR>
<H2><A NAME="rexx">REXX</A></H2>
<PRE>
/* Rexx Version of the Bottles program */
/* by Lee Stewart (ls@sweng.stortek.com) */
   Trace Off;
   Do Forever;
      Do i = 99 To 1 By -1;
         If i &gt; 1 Then pl = 's';
                  Else pl = '';
         Say i 'bottle'pl 'of beer on the wall,' i 'bottle'pl 'of beer';
         Say 'Take one down, pass it around';
         End;
      Say 'No more bottles of beer on the wall, no more bottles of beer';
      Say 'Go to the store and buy some more';
      End;
</PRE>
<HR>
<H2><A NAME="pli">PL/I</A></H2>
<PRE>

/* And here is the PL/I version: */

 BOTTLES: PROC OPTIONS(MAIN);

   DCL NUM_BOT FIXED DEC(3);
   DCL PHRASE1 CHAR(100) VAR;
   DCL PHRASE2 CHAR(100) VAR;
   DCL PHRASE3 CHAR(100) VAR;

   DO NUM_BOT = 100 TO 1 BY -1;

      PHRASE1 = NUM_BOT||' Bottles of Beer on the wall,';
      PHRASE2 = NUM_BOT||' Bottles of Beer';
      PHRASE3 = 'Take one down and pass it around';
      DISPLAY(PHRASE1||PHRASE2);
      DISPLAY(PHRASE3);
   END;
   PHRASE1 = 'No more Bottles of Beer on the wall, ';
   PHRASE2 = 'No more Bottles of Beer';
   PHRASE3 = 'Go to the store and buy some more';
   DISPLAY(PHRASE1||PHRASE2);
   DISPLAY(PHRASE3);
 END BOTTLES;

</PRE>
<H2><A NAME="rpg400">RPG/400</A></H2>
<PRE>


     H*
     H* RPG/400 VERSION OF THE BOTTLES PROGRAM *
     H*
     FSCREEN  O   F      80            WORKSTN
     C                     MOVE 100       X       30
     C           X         DOWGE0
     C                     EXCPT
     C                     SUB  1         X
     C                     END
     C                     SETON                     LR
     OSCREEN  E
     O                         X          3
     O                                   26 'BOTTLES OF BEER ON THE'
     O                                   31 'WALL,'
     O                         X         36
     O                                   53 'BOTTLES OF BEER'
     O        E
     O                                   22 'TAKE ONE DOWN AND PASS'
     O                                   32 'IT AROUND'

</PRE>
<HR>
<H2><A NAME="python">Python</A></H2>
<PRE>
#!/usr/local/bin/python
#   python version of 99 bottles of beer, compact edition
#   by Fredrik Lundh (fredrik_lundh@ivab.se)

def bottle(n):
    try:
        return { 0: "no more bottles",
                 1: "1 bottle"} [n] + " of beer"
    except KeyError: return "%d bottles of beer" % n

for i in range(99, 0, -1):
    b1, b0 = bottle(i), bottle(i-1)
    print "%(b1)s on the wall, %(b1)s,\n"\
	  "take one down, pass it around,\n"\
	  "%(b0)s on the wall." % locals()
</PRE>
<HR>
<H2><A NAME="perl">Perl</A></H2>
<i>The second one is intended to be
the author's .sig for his email.</i>
<PRE>
#! /usr/bin/perl
# Jim Menard     jimm@{bbn,io}.com     (617) 873-4326    http://www.io.com/~jimm/
$nBottles = $ARGV[0];
$nBottles = 100 if $nBottles eq '' || $nBottles &lt; 0;

foreach (reverse(1 .. $nBottles)) {
    $s = ($_ == 1) ? "" : "s";
    $oneLessS = ($_ == 2) ? "" : "s";
    print "\n$_ bottle$s of beer on the wall,\n";
    print "$_ bottle$s of beer,\n";
    print "Take one down, pass it around,\n";
    print $_ - 1, " bottle$oneLessS of beer on the wall\n";
}
print "\n*burp*\n";
</PRE>
<i>Signature version</i>
<PRE>
#!/usr/bin/perl -iake_one_down_pass_it_around:_bottles_of_beer:_on_the_wall:99
for(($t,$a,$b,$i)=split/:/,$^I;$i;print){$_="-$i$a$b,-$i$a,-T$t,-".--$i."$a$b
";s/(-1_.*?e)s/$1/g;y/_-/ \n/}#     by Randolph Chung and Joey Hess

</PRE>
<HR>
<H2><A NAME="prolog">Prolog</A></H2>
<PRE>
/*
  99 bottles of beer in Prolog

  Rob van de Pol
  R.vandePol@voeding.tno.nl
  TNO Nutrition and Food Research Institute
  The Netherlands
*/

domains
  count = integer

predicates
  bottles(count)

clauses
  bottles(1) :-
    write ("1 bottle of beer on the wall, 1 bottle of beer,\n"),
    write ("Take one down, and pass it around,\n"),
    write ("Now they are alle gone.").
  bottles(X) :-
    write ( X , " bottles of beer on the wall, " ,
            X , " bottles of beer,\n"),
    write ("Take one down, and pass it around,\n"),
    X1 = X - 1,
    write ( X1 , " bottles of beer on the wall.\n",
    bottles(X1).

goal
  bottles(99)

</PRE>
<HR>
<H2><A NAME="nroff">NROFF</A></H2>
<I>nroff is a text formatting macro language common under UNIX</I>
<PRE>
.\" Tim Goodwin &lt;tim@pipex.net&gt;
.nr BO 99
.de BP
.if \\n(BO=0 No more
.if !\\n(BO=0 \\n(BO
.if \\n(BO=1 bottle
.if !\\n(BO=1 bottles
of beer
..
.de WP
.BP
on the wall
..
.de BE
.WP
.br
.BP
.br
Take one down, pass it around
.br
.nr BO \\n(BO-1
.WP
.sp
.if \\n(BO>0 .BE
..
.BE

</PRE>
<HR>
<H2><A NAME="prograph">Prograph</A></H2>
<I><a href=http://www.pictorius.com>Click</a> for more info.</I>
<P>
<IMG src=prograph.gif>
<HR>
<H2><A NAME="oberon">Oberon</A></H2>
<PRE>
MODULE BottlesOfBeers; (* Andrejs Jansons 27.10.95 *)

      IMPORT Out;

      PROCEDURE Start*;
           VAR
                bottles: INTEGER;
           BEGIN
                bottles := 99;

                REPEAT
                    Out.Int(bottles, 2);
                    Out.String(" bottles of beer on the wall, ");
                    Out.Int(bottles, 2);
                    Out.String(" bottles of beer.");
                    Out.Ln;
                    Out.String("Take one down, pass it around, ");

                    DEC(bottles);

                    Out.Int(bottles, 2);
                    Out.String(" bottles of beer on the wall.");
                    Out.Ln
                UNTIL bottles = 1;

                Out.String("1 bottle of beer on the wall, one bottle of beer.");
                Out.Ln;
                Out.String("Take one down, pass it around,");
                Out.String(" no more bottles of beer on the wall");
                Out.Ln
           END Start;

END BottlesOfBeers.
</PRE>
<P>
<i>This is a noteworty Object Oriented version in Oberon:</i>
<PRE>
MODULE BeerSong;

(* An object-oriented beer song in Oberon-2              *)
(* Contributed by Michael Griebling (mgriebling@bix.com) *)

IMPORT O:=Out;

TYPE
  WallObject* = RECORD beer-: SHORTINT END;

VAR
  BeerWall : WallObject;
  
  PROCEDURE (VAR wall: WallObject) LineEmUp*;
  BEGIN wall.beer := 99
  END LineEmUp;
  
  PROCEDURE (VAR wall: WallObject) PassOneAround*;
  BEGIN DEC(wall.beer)
  END PassOneAround;
  
  PROCEDURE (VAR wall: WallObject) HasMoreBeer* () : BOOLEAN;
  BEGIN RETURN wall.beer &gt; 0
  END HasMoreBeer;
  
  PROCEDURE SingOf(beer: SHORTINT);
  BEGIN 
    IF beer = 0 THEN O.String("No more") ELSE O.Int(beer, 1) END; 
    O.String(" bottle"); IF beer#1 THEN O.Char("s") END; O.String(" of beer")
  END SingOf;
     
  PROCEDURE (VAR wall: WallObject) SingVerse*;    
  BEGIN 
    SingOf(wall.beer); O.String(" on the wall, "); SingOf(wall.beer); O.Ln;
    O.String("Take one down and pass it around,"); O.Ln;
    SingOf(wall.beer-1); O.String(" on the wall."); O.Ln; O.Ln
  END SingVerse;

BEGIN
  BeerWall.LineEmUp;
  WHILE BeerWall.HasMoreBeer() DO BeerWall.SingVerse; BeerWall.PassOneAround END
END BeerSong.
</PRE>
<HR>
<H2><A NAME="pop">Pop</A></H2>
<PRE>
define beer(n);

    define :inline PLURAL(N);
        (N==1 and nullstring or "s")
    enddefine;

    lvars i;
    for i from n by -1 to 1 do;
        nl(1);
        nprintf(PLURAL(i), i, '%P bottle%P of beer on the wall.');
        nprintf(PLURAL(i), i, '%P bottle%P of beer!');
        nprintf(i==1 and "it" or "one", 'Take %P down, pass it around.');
        if i>1 then
            nprintf(PLURAL(i-1), i-1, '%P more bottle%S of beer on the wall.');
        else
            npr('No more bottles of beer on the wall.');
        endif;
    endfor;

enddefine;

beer(100);
</PRE>
<HR>
<H2><A NAME="progress">Progress</A></H2>
<i><a href=http://www.progress.com>Progress</a>
is a database system that is used to create enterprise 
database solutions.</i>
<PRE>
/* Progress 4GL version of 99 Bottles of Beer.
 * programmer: Rich Uchytil  rich@cray.com
 * 10/30/95
 */

def var i as int no-undo format "z9".

do i = 99 to 1 by -1:
  disp i "bottles of beer on the wall," skip
       i @ x as int format "z9" "bottles of beer" skip
       "Take one down and pass it around," skip
       i - 1 format "z9" "bottles of beer on the wall."
  with no-labels no-box no-attr 1 down.
  pause 1 no-message.  /* needed otherwise it would run too fast */
end.

</PRE>
<HR>
<H2><A NAME="pilot">Pilot</A></H2>
<PRE>
R: PILOT version of 99 Bottles of Beer
 : hacked by Akira KIDA, &lt;SDI00379@niftyserve.or.jp&gt;

C:BOTTLES=99

U:*BEERS
*LOOP
T:$T of beer on the wall, $T.
T:Take one down, pass it around.
C:BOTTLES=BOTTLES-1
U:*BEERS
T:$T on the wall.
T:
J(BOTTLES>0):*LOOP
E:

*BEERS
C(BOTTLES=0):$T=No more bottles
C(BOTTLES=1):$T=1 bottle
C(BOTTLES>1):$T=#BOTTLES bottles
E:
</PRE>
<HR>
<H2><A NAME="pvwave">PV-Wave</A></H2>
<i>PV-Wave, also known as IDL, is a language designed for visual data analysis.
</i>
<PRE>
;
; 99 bottles of beer
; V1
; Author: George M.Sigut  (sigut@bs.id.ethz.ch)
;
; yes, I DO know the second loop could be unrolled
;
ninety_nine = 99
texta = ' bottles of beer'
textb = ' bottle of beer'
textf = ' no more'
;
number1 = strcompress(string(ninety_nine))
text1   = texta
number2 = strcompress(string(ninety_nine-1))
text2   = texta
for i=ninety_nine,3,-1 do begin &$
  print,number1,text1,' on the wall' &$
  print,number1,text1 &$
  print,' you take one down & pass it around' &$
  print,number2,text2 &$
  print &$
  number1 = number2 &$
  number2 = strcompress(string(i-2)) &$
endfor
;
text1 = texta
text2 = textb
for i=2,1,-1 do begin &$
  print,number1,text1,' on the wall' &$
  print,number1,text1 &$
  print,' you take one down & pass it around' &$
  print,number2,text2 &$
  print &$
  number1 = number2 &$
  text1   = textb &$
  number2 = textf &$
  text2   = texta &$
endfor
;

;  ---------- Variant more in keeping with the language's style -----

;
; 99 bottles of beer
; V2
;
ninety_nine = 99
texta = ' bottles of beer'
textb = ' bottle of beer'
textf = ' no more'
;
full_text = strarr(1,4,ninety_nine)
;
full_text(0,1,*) = strcompress(string(ninety_nine-indgen(ninety_nine))) + texta
full_text(0,0,*) = full_text(0,1,*) + ' on the wall'
full_text(0,2,*) = ' you take one down & pass it around'
full_text(0,3,0:ninety_nine-2)=full_text(0,1,1:ninety_nine-1)
;
full_text(0,3,ninety_nine-2) = strcompress(1)+textb
full_text(0,0,ninety_nine-1) = full_text(0,3,ninety_nine-2)+' on the wall'
full_text(0,1,ninety_nine-1) = full_text(0,3,ninety_nine-2)
full_text(0,3,ninety_nine-1) = textf+texta
;
print,full_text
;

</PRE>
<HR>
<H2><A NAME="natural">Natural</A></H2>
<PRE>
* PGM-ID: BEER
* AUTHOR: CHRIS BEDNARA
* COMMENT: NATURAL '99 BOTTLES OF BEER ON THE WALL' CODE
*
*-------------------------------------------------------
DEFINE DATA
	LOCAL
	  01 #BOTTLES  (I2)
END-DEFINE
*
FOR #BOTTLES 99 TO 2 STEP -1
	IF #BOTTLES &lt; 98
	  WRITE #BOTTLES ' BOTTLES OF BEER ON THE WALL'
	  WRITE ' '
	END-IF
*	
	WRITE #BOTTLES ' BOTTLES OF BEER ON THE WALL'
	WRITE #BOTTLES ' BOTTLES OF BEER'
	WRITE 'TAKE ONE DOWN, PASS IT AROUND'
END-FOR
*
WRITE '1 BOTTLE OF BEER ON THE WALL'
WRITE ' '
WRITE '1 BOTTLE OF BEER ON THE WALL'
WRITE '1 BOTTLE OF BEER'
WRITE 'TAKE IT DOWN, PASS IT AROUND'
WRITE 'NO MORE BOTTLES OF BEER ON THE WALL'
WRITE ' '
WRITE 'NO MORE BOTTLES OF BEER ON THE WALL'
WRITE 'NO MORE BOTTLES OF BEER'
WRITE 'GO TO THE STORE AND BUY SOME MORE'
WRITE '99 BOTTLES OF BEER'
END
WRITE 'TAKE ONE DOWN, PASS IT AROUND'
</PRE>
<HR>
<H2><A NAME="nial">NIAL</A></H2>
<i>
Nial stands for Nested Interactive Array Language, which incorporates
ideas from APL2, Lisp, FP and structured programming. Q'Nial is a Nial
programming system developed at Queen's University in Canada

<a href="http://www.qucis.queensu.ca/home/nsl/info.html">Click here</a> 
for more info.
</i>
<PRE>
% Nial (Q'Nial) version of 99 bottles of beer
%;
% loaddef "beer;
% beer 99;
%;
% Hacked by Akira KIDA, SDI00379@niftyserve.or.jp;

bottles IS OPERATION A {
	IF A = 0 THEN
		'No more bottles'
	ELSEIF A = 1 THEN
		link (sketch A) ' bottle'
	ELSE
		link (sketch A) ' bottles'
	ENDIF
}

beer IS OPERATION A {
	FOR x WITH reverse count A DO
		write link (bottles x) ' of beer on the wall, '
			(bottles x) '.';
		write 'Take one down, pass it around.';
		write link (bottles (x - 1)) ' of beer on the wall.';
		write '';
	ENDFOR;
}

</PRE>
<HR>
<H2><A NAME="opl">OPL</A></H2>
<I> OPL (Organiser Programming Language) is the language used by Psion
palmtops.</i>
<PRE>
REM ********************************************************************
REM *                        99 Bottles of Beer                        *
REM *                                                                  *
REM * A portable version for those who need this vital application     *
REM * with them at all times. The following is written in Psion OPL,   *
REM * the language used in the popular Series 3 and Series 3a palmtops *
REM * (and other previous Psion products).                             *
REM *                                                                  *
REM * by Dave Wilson, dawilson@brooktree.com                           *
REM *                                                                  *
REM ********************************************************************

PROC Main:
   LOCAL bottles%
   LOCAL bottle$(10)
   CLS
   bottles%=99
   bottle$=" bottles"
   PRINT "99 Bottles of Beer"
   PRINT
   WHILE(bottles% &gt; 0)
      PRINT bottles%;bottle$;" of beer on the wall,"
      PRINT bottles%;bottle$;" of beer on the wall."
      PRINT "Take one down and pass it around,"
      bottles%=bottles%-1
      IF(bottles% = 1)
         bottle$=" bottle"
      ENDIF
      IF(bottles% <> 0)
         PRINT "There'll be ";bottles%;bottles$;" of beer on the wall."
      ELSE
         PRINT "There'll be no bottles of beer on the wall."
      ENDIF
      PRINT
   ENDWH
   PAUSE 0
ENDP

</PRE>
<HR>
<H2><A NAME="newlib">NEWLIB</A></H2>
<i>NEWLIB is a programming aid that operates as a command processor
in the Time Sharing Option (TSO) environment.  (Mostly based on PL/I,
therefore the similarity.)  It is used at DESY/Hamburg and KEK/Tsukuba.</i>
<PRE>
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$   21/02/96 602211216  MEMBER NAME  &lt;&lt;EDTCL  (SPECTRUM)    CLIST   
$ NEWLIB VERSION OF 99 BOTTLES OF BEER                              
$ R.P.HOFMANN F15RPH@DSYIBM.DESY.DE                                 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
STORE                                                                
ESC := '%'                                                           
DO N0 = 1 TO 99                                                      
  N1 := 100-%N0                                                      
  IF N1 &gt; 1 THEN                                                     
    IF N0 &gt; 1  SHOW N1||' BOTTLES OF BEER ON THE WALL'               
    SHOW N1||' BOTTLES OF BEER ON THE WALL'                          
    SHOW N1||' BOTTLES OF BEER'                                      
  ELSE                                                               
    SHOW '1 BOTTLE OF BEER ON THE WALL'                              
    SHOW '1 BOTTLE OF BEER ON THE WALL'                              
    SHOW '1 BOTTLE OF BEER'                                          
  ENDIF                                                              
  SHOW 'TAKE 1 DOWN AND PASS IT ALL AROUND'                          
END                                                                  
SHOW '0 BOTTLES OF BEER ON THE WALL'                                 
RESTORE                                                              
</PRE>
<HR>
<H2><A NAME="posix">Posix</A></H2>
<i>Posix is yet another U**x shell.</i>
<PRE>
#!/bin/sh
# POSIX shell version of 99 Bottles
# Dave Plonka - plonka@carroll1.cc.edu

typeset -i n=99
typeset bottles=bottles
typeset no

while let n
do
   echo "${n?} ${bottles?} of beer on the wall,"
   echo "${n?} ${bottles?} of beer,"
   echo "take one down, pass it around,"
   n=n-1
   case ${n?} in
   0)
      no=no
      bottles=${bottles%s}s
      ;;
   1)
      bottles=${bottles%s}
      ;;
   esac
   echo "${no:-${n}} ${bottles?} of beer on the wall."
   echo
done

exit
</PRE>
<HR>
<H2><A NAME="qbasic">Quick Basic</A></H2>
<i></i>
<PRE>
'99 Bottles of Beer on the Wall
'Patrick Fleming   http://chem-www.mps.ohio-state.edu/~pfleming/

CLS

n = 100
DO UNTIL n = 1
     n = n - 1
     PRINT n; "bottle";
     IF n <> 1 THEN PRINT "s";
     PRINT " of beer on the wall . . ."
     PRINT n; "bottle";
     IF n <> 1 THEN PRINT "s";
     PRINT " of beer!"
     PRINT "Take one down, pass it around . . ."
     PRINT n - 1; "bottle";
     IF n - 1 <> 1 THEN PRINT "s";
     PRINT " of beer on the wall!"
     PRINT
LOOP

END
</PRE>
<HR>
<H2><A NAME="rapid">Rapid</A></H2>
<i>Rapid is a a prototyping language developed by 
<a href=http://www.emultek.com>Emultek</a>.  There
were several screen shots associated with this, but this one is
the most obviously the programming language part of it.</i>
<P>
<IMG src=rapid.gif>
<HR>
<H2><A NAME="pal">PAL</A></H2>
<i>PAL is Prodigy Application Language.  I listed this one as unique
simply because you don't often get a peek at a truly proprietary
language.  This can't be compiled by anyone other than Prodigy
employees.</i>
<PRE>
/*=========================================================================*/
/*                                                                         */        
/*                       PRODIGY SERVICES COMPANY                          */
/*                                                                         */
/*  Author:        Kim Moser (kmoser@prodigy.com)                          */
/*  Application:   99 Bottles of Beer on the Wall                          */
/*  Program Name:  XXXXBEER.PGM                                            */
/*  Program Type:  Element preprocessor                                    */
/*  File Name:     xxxxbeer.s                                              */
/*  Version:       0.0                                                     */
/*  Contents:      PAL                                                     */                                 
/*=========================================================================*/
/* PROGRAM DESCRIPTION: This function fills PEVs 10-110 with 99 verses     */
/*  of the "99 Bottles of Beer on the Wall" song (one verse per PEV),      */
/*  appends these verses to the file whose name was given in P1 (the       */
/*  first parameter), then opens a window warning you to buy more beer.    */
/*                                                                         */
/*  The program is smart enough to pluralize "beer" when refering to       */
/*  more than one, and says "no" when refering to 0 bottles.               */
/*                                                                         */
/*  The output is as follows:                                              */
/*  99 bottles of beer on the wall, 99 bottles of beer.                    */
/*  Take one down, pass it around, 98 bottles of beer on the wall.         */
/*  ...                                                                    */
/*  1 bottle of beer on the wall, 1 bottle of beer.                        */
/*  Take one down, pass it around, no bottles of beer on the wall.         */
/*  Time to buy more beer!                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/* MAINTENANCE LOG:                                                        */
/*  PROGRAMMER        DATE        DESCRIPTION OF CHANGE                    */
/*   Kim Moser      23-Oct-96      Creation.                               */
/*=========================================================================*/

#define DISPLAY_PEV  10

#define Q_CTX_NAME "beer_ctx"
context beer_ctx {
    var
    ctx_fp,                /* File pointer: where to write the song */
    ctx_bottle,            /* " bottle" */
    ctx_bottle_of_beer,    /* " bottle of beer" */
    ctx_bottles_of_beer,   /* " bottles of beer" */
    ctx_on_the_wall;       /* " on the wall" */
}

#define DEFAULT_FNAME    "beer.txt"

"XXXXBEERPGM\00\0C"(var fname)
{
    var i;
    var of_beer;
    var sentence;

    if (open_one_context(Q_CTX_NAME) > 1) {
        /* Error opening context */
        return (-1);
    }

    /* Initialize context: */
    /* Reduce string overhead by putting these phrases in variables: */
    of_beer = " of beer";
    ctx_bottle = " bottle";
    ctx_bottle_of_beer = string(ctx_bottle, of_beer);
    ctx_bottles_of_beer = string(ctx_bottle, "s", of_beer);
    ctx_on_the_wall = " on the wall";

    if (fname ==$ "") {
        /* No filename specified */
        fname = DEFAULT_FNAME;
    }

    if (open(fname, F_APPEND, ctx_fp) == 0) {
        for (i=99; i > 0; i-=1) {
            sentence = bottles_sentence(i);

            &0[DISPLAY_PEV + (100-i)] = sentence;
            write_line(ctx_fp, sentence);
        }
        write_line(ctx_fp, "Time to buy more beer!\n");
        close(ctx_fp);
    }

    close_all_contexts(Q_CTX_NAME);

    open_window("XXXXBEERWND\00\0E");  /* Warning: Time to buy more beer */
}

bottles_sentence(var n_bottles)
{
    var bob1, bob2; /* " bottles of beer" or " bottle of beer" */

    bob1 = bob(n_bottles);
    bob2 = bob(n_bottles - 1);

    return (
        string(
            n_bottles,
            bob1,
            ctx_on_the_wall,
            ", ",
            n_bottles,
            bob1,
            ".\nTake one down, pass it around, ",
            (n_bottles-1 ? n_bottles-1 : "no"),
            bob2,
            ctx_on_the_wall,
            "."
        )
    );
}

bob(var n_bottles)
{
    return (n_bottles==1 ? ctx_bottle_of_beer : ctx_bottles_of_beer);
}
</PRE>
<HR>
<H2><A NAME="plex">PLEX</A></H2>
<i>PLEX (Programming Language for EXchanges) is a real-time language
developed in 1970 by Ericsson to program telephony exchanges.</i>
<PRE>
! The main program "99 bottles ..." programmed in PLEX  !
! Programmer Staale Andersen   etosta@eto.ericsson.se   !

! Comment: The need for an own parameterlist and a signal survey, !
! leads to the whole beer program beeing in 3 parts.              !



DOCUMENT BEERPROGRAM;

DECLARE;
          GLOBAL NSYMB COCA99 (#FFFF);
          GLOBAL STRING BEERS (7);
          STRING VARIABLE ONWALL1 31 DS;
          STRING VARIABLE ONWALL2 63 DS;
          STRING VARIABLE BOTTLES 31 DS;
          STRING VARIABLE TAKEDOWN 63 DS;
          VARIABLE CBEER 16 DS;
          VARIABLE CIOID 16 DS;
          VARIABLE TIOID 16;
          VARIABLE TSTARTPHASE 16;
          VARIABLE TSIGNALKEY 16;
          VARIABLE TBLOCKINFO 16;

END DECLARE;
PROGRAM BEERPROGRAM;
PLEX;

          ENTER STTOR  WITH
                    +,                   
                    TSTARTPHASE,         
                    +,                   
                    +,                   
                    +,                   
                    +,                   
                    TSIGNALKEY;          

          TBLOCKINFO = #100;
 
          SEND STTORRY  WITH
                          TSIGNALKEY,    
                          TBLOCKINFO,    
                          5,             
                          255;           
 
                EXIT;
  
          COMMAND BEERS TYPE COCA99,
            ID IS TIOID;
          CIOID = TIOID;
          ONWALL1 = " BOTTLES OF BEER ON A WALL, ";
          ONWALL2 = " BOTTLES OF BEER ON A WALL.";
          BOTTLES = " BOTTLES OF BEER";
          TAKEDOWN = "TAKE ONE DOWN AND PASS IT AROUND, ";
          ON CBEER FROM 99 DOWNTO 1 DO
            CASE CBEER IS
            WHEN 1 DO
              BOTTLES = " BOTTLE OF BEER";
              ONWALL1 = " BOTTLE OF BEER ON A WALL, ";
              ONWALL2 = "NO MORE BOTTLES OF BEER ON A WALL.";
            WHEN 2 DO
              ONWALL2 = " BOTTLE OF BEER ON A WALL.";
            OTHERWISE DO;
            ESAC;
            INSERT VALUE CBEER, ID IS CIOID,
              FORMAT IS 5;
            INSERT STRING ONWALL1, ID IS CIOID;
            INSERT VALUE CBEER, ID IS CIOID,
                FORMAT IS 5;
            INSERT STRING BOTTLES, ID IS CIOID;
            WRITE AFTER 1 NL, ID IS CIOID,
              ABRANCH IS ERROR;
            
            INSERT STRING TAKEDOWN, ID IS CIOID;
            IF CBEER /= 1 THEN
              INSERT VALUE (CBEER-1), ID IS CIOID,
                FORMAT IS 5;
            FI;
            INSERT STRING ONWALL2, ID IS CIOID;
            WRITE AFTER 1 NL, ID IS CIOID,
              ABRANCH IS ERROR;
            
          NO;
          
    ERROR)
          RELEASE DEVICE, ID IS CIOID,
            ABRANCH IS EXIT; 
    EXIT)
          EXIT;

END PROGRAM;          

DATA;

END DATA;          

*END;

ID BEERPROGRAM TYPE DOCUMENT;
CLA 19055;
NUM CAA 100 99;
REV A;
DAT 96-12-12;
DES ETO/TX/M/N STA;
RES ETO/TX/M/N STA;
APP ETO/TX/M/N TV;
END ID;

! The source parameter list !

DOCUMENT BEERSPARAM;

BLOCK   BEER;
TYPE     BTBEER;
TYPEEXT  BTEXTBEER;

USE     BEERPROGRAM;

NSYMB     BTBEER = #8000;   
NSYMB     BTEXTBEER= #4000;  

STRING BEERS = "BEERS";
NSYMB COCA99 = #0;


END BLOCK;
*END;
ID BEERSPARAM TYPE DOCUMENT;
CLA 19073;
NUM CAA 100 99;
REV A;
DAT 96-12-13;
DES ETO/TX/M/N STA;
RES ETO/TX/M/N STA;
APP ETO/TX/M/N TV;
END ID;

! Signal Survey  !
DOCUMENT BEERSURVEY;
SIGNALSURVEY;
USE BLOCK BEER;

STTOR          ,  R     ,  723/15514 - APZ210                  ;
STTORRY        ,  S     ,  724/15514 - APZ210                  ;

END SIGNALSURVEY;
*END;
ID BEERSURVEY TYPE DOCUMENT;
CLA 15514;
NUM CAA 100 99;
REV A;
DAT 96-12-13;
DES ETO/TX/M/N STA;
RES ETO/TX/M/N STA;
APP ETO/ETOTX/M/N TV;
END ID;
</PRE>
<HR>
<H2><A NAME="obj">OBJ</A></H2>
<i>OBJ is an algebraic specification language.</i>
<PRE>
*** OBJ version of 99 bottles of beer
*** programmer: Grigore Rosu  grosu@cs.ucsd.edu
*** creator of OBJ language: Joseph Goguen

obj STRING is sort String .
  ops We like some beer on the wall.  : -> String .
  ops Take one bottle of wall down ,  : -> String .
  ops And pass it arround the beer.   : -> String .
  ops Does anybody want bottles more? : -> String .
endo

obj LIST[X :: TRIV] is
  sort List .
  subsort Elt < List .
  op __ : List List -> List [assoc] .
endo

make CHUG is LIST [ STRING + NAT ] endm

obj BEER is protecting CHUG .
  subsort Nat < String .
  ops beers puke : Nat -> List .
  op bottle? : Nat -> String .
  var N : Nat .
  eq beers(0) = Does anybody want some more? .
  cq beers(N) = puke(N) beers(p N) if N > 0 .
  eq puke(N) = N bottle?(N) of beer on the wall , N bottle?(N) of beer.
   Take one down , pass it arround , (p N) bottle?(p N) of beer on the wall. .
  cq bottle?(N) = bottle  if N == 1 .
  cq bottle?(N) = bottles if N =/= 1 .
endo

red beers(99) .

</PRE>
<HR>
<H2><A NAME="povray">POV-Ray</A></H2>
<i>POV-Ray is a ray-tracing program.</i>
<PRE>
// povray 3 file for the 99 bottles of beer ...

#declare S1 = " bottles"
#declare L1 = " of beer on the wall,\n"
#declare L2 = " of beer.\n"
#declare L3 = "Take one down and pass it around,\n"
#declare L4 = " of beer on the wall.\n\n"

#declare Beer = 99
#declare S2 = concat(str(Beer,0,0),S1)

#render "\n"

#while (Beer > 0)
  #render concat(S2,L1)
  #render concat(S2,L2)
  #render L3

  #declare Beer = Beer - 1

  #if (Beer = 1)
    #declare S2 = "1 bottle"
  #else
    #if (Beer = 0)
      #declare S2 = "No more bottles"
    #else
      #declare S2 = concat(str(Beer,0,0),S1)
    #end
  #end

  #render concat(S2,L4)
#end

sphere { 0, 1 pigment { colour rgb &lt;1,0,0&gt; } }

light_source { x*2, colour rgb 1 }

camera {
  perspective
  location x*2
  look_at 0
}
</PRE>
<HR>
<H2><A NAME="orthogonal">Orthogonal</A></H2>
<PRE>
; 99 Bottles of Beer on the Wall
;    for Orthogonal
;        written by Brian Raiter 5/96

:set bX = 7
:set bY = 20

[0,0]
99  1   cw
        0           cw  0   ':' 'd' 'n' 'u' 'o' 'r' ' ' 't' 'i' ' ' cw
        99          cw  0   ':' 'e' 'r' 'o' 'm' ' ' 'e' 'm' cw      's'
        1           ?                                       'o'     's'
        99          !                                       's'     'a'
    cw  J   c   0   cw  ?   c   0   s   '.' 0   ccw ?   s   ' ' ccw 'p'
    ~   d   cw  ' ' J   0   d   s   ';' ' ' 0   cw          'y' 'b' ' '
    0   0   'o'     'r'                                     'u' 'o' ','
    ~   'l' 'n'     'e'                                     'b' 't' 'n'
    0   'l' ' '     'e'                                     ' ' 't' 'w'
    @   'a' 't'     'b'                                     ',' 'l' 'o'
    ~   'w' 'h'     ccw ' ' 'f' 'o' ' ' bY  bX  =   ?   's' 'e' ccw 'd'
    1   ' ' 'e'                                             'r'     ' '
    @   ccw ccw     cw  'l' 'l' 'a' 'w' ' ' 'e' 'h' 't' cw  'o'     bY
    ~               '.' cw  's' 'e' 'l' 't' 't' 'o' cw  ' ' 't'     bX
    0               0   ' ' cw  c   0   ret         'b' 'n' 's'     =
    ~               c   'o' cw  0   s   d   99  ' ' cw  'o' ' '     ?
    1               0   cw  'f' ' ' 'b' 'e' 'e' 'r' ' ' cw  'e'     ccw cw
    @               cw  s   'G' 'o' ' ' 't' 'o' ' ' 't' 'h' cw      't' 'e'
    #                                                               'i' 'n'
    cw  bX  bY  -   1   @   98  nop c   0   s   'T' 'a' 'k' 'e' ' ' H   'o'
                                                                    cw  cw
</PRE>
<HR>
<H2><A NAME="plm80">PL/M-80</A></H2>
<i></i>
<PRE>
/*
 * 99 bottles of beer in PL/M-80
 *
 * by John Durbetaki using AEDIT
 *
 */
Ninety$Nine:
Do;

declare as              LITERALLY   'LITERALLY'
declare CRLF            as          '0Dh,0Ah'

declare Beers           BYTE DATA(99);
declare Message1(*)     BYTE DATA(' of beer on the wall,',CRLF);
declare Message2(*)     BYTE DATA(' of beeeeer . . . . ,',CRLF);
declare Message3(*)     BYTE DATA('Take one down, pass it around,',CRLF);
declare Message4(*)     BYTE DATA(' of beer on the wall.',CRLF);
declare End$Message(*)  BYTE DATA(CRLF,'Time to buy more beer!',CRLF);
declare STATUS          BYTE;
declare How$Many(128)   BYTE;
declare How$Many$Count  BYTE;

Copy: PROCEDURE(Ap,Bp,Count);
    declare Ap              ADDRESS;
    declare A BASED Ap      BYTE;
    declare Bp              ADDRESS;
    declare B BASED Bp      BYTE;
    declare Count           BYTE;

    DO WHILE Count > 0;
        B=A;
        Ap=Ap+1;
        Bp=Bp+1;
        Count=Count-1;
        END;
    END;

Make$How$Many: PROCEDURE(Beers);
    declare Beers           BYTE;

    if Beers = 0 THEN DO;
        CALL Copy(.('No more bottles'),.How$Many(0),How$Many$Count=15);
        END;
    else if Beers = 1 THEN DO;
        CALL Copy(.('One more bottle'),.How$Many(0),How$Many$Count=15);
        END;
    else DO;
        if Beers > 10 THEN DO;
            How$Many(0)='0'+(Beers/10);
            How$Many(1)='0'+(Beers MOD 10);
            CALL Copy(.(' bottles'),.How$Many(2),8);
            How$Many$Count=10;
            END;
        else DO;
            How$Many(0)='0'+Beers;
            CALL Copy(.(' bottles'),.How$Many(1),8);
            How$Many$Count=9;
            END;
        END;
    END;

Chug: PROCEDURE(Beers);
    declare Beers           BYTE;

    CALL Make$How$Many(Beers);
    CALL WRITE(0,.How$Many,Count,.STATUS);
    CALL WRITE(0,.Message1,SIZE(Message1),.STATUS);
    CALL WRITE(0,.How$Many,Count,.STATUS);
    CALL WRITE(0,.Message2,SIZE(Message2),.STATUS);
    CALL WRITE(0,.Message3,SIZE(Message3),.STATUS);
    CALL Make$How$Many(Beers-1);
    CALL WRITE(0,.How$Many,Count,.STATUS);
    CALL WRITE(0,.Message4,SIZE(Message4),.STATUS);
    END;

    DO WHILE Beers > 0;
        CALL Chug(Beers);
        Beers=Beers-1;
        END;
    CALL WRITE(0,.End$Message,SIZE(End$Message),.STATUS);
    END;
</PRE>
<HR>
<H2><A NAME="newtonscript">NewtonScript</A></H2>
<i>NewtonScript is an object-oriented language that runs on
Apple Newton MessagePads.  You can get a Steve Weyer's free compiler
for it at <a href=http://www.netaxs.com/~weyer/newton/newtdev.htm>http://www.netaxs.com/~weyer/newton/newtdev.htm</a>.</i>
<PRE>
// A simple NewtonScript program to 99 Bottles.
// Armen Nakashian, 3/13/97 armen@yawara.anime.net

BeerSong
{
Drink:func()
for b:=99 to 1 do
begin   
        print(bob(b) & " on the wall, " & bob(b) & ".");

        print("Take one down, pass it around, " & bob(b-1) & " on the
wall.");
end,

bob:func(i):
        if i==0 then return "no more bottles of beer",
        else if i==1 then return "1 bottle of beer",
        else return i & " bottles of beer",
}

</PRE>
<HR>
<H2><A NAME="occam">Occam</A></H2>
<i></i>
<PRE>
-- compiled with the University of Kent "kroc" compiler
-- Tony Curtis <Tony.Curtis@vcpc.univie.ac.at> 1997
--
PROC beer (CHAN OF BYTE key, screen, error)
 
  VAL INT BEERS IS 99 :                       -- big fridge!
 
  #USE "tty_utils.tco"
  PROC sorp (VAL INT n, CHAN OF BYTE out)     -- singular or plural?
    IF
      n > 1
        out.string ("s", 1, out)
      TRUE
        SKIP
  :
  PROC sayit (VAL INT n, CHAN OF BYTE out)     -- text for each iteration
    SEQ
      out.number (n, 1, out)
      out.string (" bottle", 1, out)
      sorp (n, out)
      out.string (" of beer on the wall, ", 1, out)
      out.number (n, 1, out)
      out.string (" bottle", 1, out)
      sorp (n, out)
      out.string (" of beer.", 1, out)
      out.string ("*c*n", 1, out)
      out.string ("Take one down, pass it around, ", 1, out)
      VAL INT next IS  n - 1 :
      IF
        next > 0
          SEQ
            out.number (next, 1, out)
            out.string (" bottle", 1, out)
            sorp (next, out)
            out.string (" of beer on the wall.", 1, out)
        TRUE
          out.string ("no bottles of beer on the wall.", 1, out)
      out.string ("*c*n", 1, out)
  :
  PROC beers (VAL INT nbeers, CHAN OF BYTE out)
    INT b :
    SEQ
      b := nbeers
      WHILE b > 0
        SEQ
          sayit (b, out)
          b := b - 1
  :
  beers (BEERS, screen)
:
</PRE>
<HR>
<H2><A NAME="plsql">PL/SQL</A></H2>
<i>PL/SQL is a programming language that resides in an Oracle database. As 
PL/SQL has no standard input or output this version is written to be run 
from the SQLPlus command line using an anonymous PL/SQL block.</i>
<PRE>
/* Start of code */
set serveroutput on

DECLARE
        counter         NUMBER;
BEGIN
        dbms_output.enable;

        FOR counter IN REVERSE 1..99 LOOP
                dbms_output.put_line(counter || ' bottles of beer on the wall,');
                dbms_output.put_line(counter || ' bottles of beer.');
                dbms_output.put_line('Take one down, pass it around,');
                
                IF (counter != 1) THEN
                        dbms_output.put_line(counter - 1 || ' bottles of beer on the wall.');
                ELSE
                        dbms_output.put_line('No more beers.');
                END IF;
        END LOOP;
END;
/
/* End of code (The "/" in the line above is very important) */
</PRE>
<HR>
<H2><A NAME="phfi">PH/FI</A></H2>
<i>PH/FI is a light, and powerful, interpreter for server-parsed ("dynamic"
this year, SSH since NCSA invented the thing ages ago) html which can be
used either as a CGI redirected processor or embbedded in Apache servers.
Its web site is <a HREF="http://php.iquest.net/">http://php.iquest.net/</a></i>.
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;
99 Bottles of beer.
&lt;/TITLE&gt;
&lt;META NAME="Author" CONTENT="Alejandro L&oacute;pez-Valencia"&gt;
&lt;META NAME="E-Mail" CONTENT="palopez@usa.net"&gt;
&lt;META NAME="Description" CONTENT="Written in PHP/FI 2.0"&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR="#FFFFFF"&gt;
&lt;?
/* Don't show the access information footer */
setshowinfo(0)
&gt;
&lt;?
/* Drink with the boys... */
$hic = 99;
while ($hic &gt; 0) (
	$huc = $hic - 1;

/* Waste CPU, but you are using a Cray, aren't you? */

	if ($hic = 1) (
		$huc = $hic;
	) ;

	if ($hic = 1) $bottles = "bottle" else $bottles = "bottles" ;

	echo $hic $bottles of beer on the wall, $hic $bottles of beer. &lt;BR&gt; ;
	echo Take one and pass it around, &lt;BR&gt; ;
	echo "$huc $bottles of beer on the wall. &lt;BR&gt;" ;
	$hic--;
)
/* Pass out */
echo No more bottles of beer on the wall. &lt;BR&gt; ;
echo No more bottles of beer... &lt;BR&gt; ;
echo Go to the store and buy some more... &lt;BR&gt; ;
echo 99 bottles of beer. &lt;BR&gt; ;
&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
<HR>
<H2><A NAME="ocl">OCL</A></H2>
<i>Operation Control Language is the JCL/batch/scripting language for the IBM
System 32/34/36 computer series.</i>.
<PRE>
** 99 Bottles of Beer on the Wall
// EVALUATE P1=99 P2='s'
// TAG MOREBEER
// * '?1? bottle?2? of beer on the wall,'
// * '?1? bottle?2? of beer,'
// IFF '?1?'='No more' * 'Take one down and pass it around,' 
// ELSE * 'Go to the store and get some more,'
// IFF '?1?'='No more' EVALUATE P1=?1?-1  * decrement the counter
// ELSE EVALUATE P1=99 * reseed counter
// IF ?1?>1 EVALUATE  * leave P2='s' (for efficiency - OCL is interpreted)
// ELSE IF ?1?=1 EVALUATE P2=''
// ELSE IF ?1?=0 EVALUATE P1='No more' P2='s'
// * '?1? bottle?2? of beer on the wall.'
// GOTO MOREBEER * ad infinitum
</PRE>
<HR>
<H2><A NAME="rc">RC</A></H2>
<i>rc shell script language.</i>.
<PRE>
#!/usr/local/bin/rc
# rc shell version of 99 bottles of beer
# by Tom Culliton (culliton@clark.net)

count = (99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78
         77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56
         55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34
         33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12
         11 10 9 8 7 6 5 4 3 2 1)
bottles = bottles; one = one
for (i in $count) {
        if (~ $i 1) {bottles = bottle; one = it}
        if (! ~ $i 99) {
                echo $i $bottles 'of beer on the wall.'
                echo
        }
        echo $i $bottles 'of beer on the wall,'
        echo $i $bottles 'of beer,'
        echo 'take' $one 'down and pass it around,'
}
echo 'no more bottles of beer on the wall!'
</PRE>
<HR>
<H2><A NAME="ramisexecutive">RAMIS Executive</A2></H2>
<i></i>
<PRE>
*-----------------------------------------------------------------------
* 99 BOTTLES OF BEER ON THE WALL - RAMIS EXECUTIVE VERSION
*-----------------------------------------------------------------------

CATALOGS BEER
&&COUNT/I2 = 99;
&&LOOP
&&BOTTLES/A7 = IF &COUNT GT 1 THEN 'BOTTLES' ELSE 'BOTTLE ';
&&PRINT &COUNT &BOTTLES OF BEER ON THE WALL, &COUNT &BOTTLES OF BEER
&&PRINT TAKE ONE DOWN, PASS IT AROUND
&&COUNT/I2 = &COUNT - 1;
&&IF &COUNT GT 0 GOTO LOOP;
&&PRINT NO MORE BOTTLES OF BEER ON THE WALL, NO MORE BOTTLES OF BEER
&&PRINT GO TO THE STORE AND BUY SOME MORE
END CATALOGS
EXEC BEER
</PRE>
<HR>
<H2><A NAME="ramissbx">RAMIS SBX</A2></H2>
<i></i>
<PRE>
*----------------------------------------------------------------------
* 99 BOTTLES OF BEER ON THE WALL - RAMIS SBX VERSION
*----------------------------------------------------------------------

PROCESS;
DECLARE COUNT AS I2;
DO FROM COUNT = 99 TO 2 BY -1;
    PRINT &COUNT BOTTLES OF BEER ON THE WALL, &COUNT BOTTLES OF BEER;
    PRINT TAKE ONE DOWN, PASS IT AROUND;
ENDDO;

PRINT  1 BOTTLE  OF BEER ON THE WALL,  1 BOTTLE  OF BEER;
PRINT TAKE ONE DOWN, PASS IT AROUND;
PRINT NO MORE BOTTLES OF BEER ON THE WALL, NO MORE BOTTLES OF BEER;
</PRE>
<HR>
<P>
<P>
<CENTER>
<FONT SIZE=2><I>Compilation Copyright 1995, 1996, 1997 Tim Robinson.  All Rights Reserved
<BR>Permission to copy enthusiastically granted to instructors of computer science
<BR>(who would like to demonstrate the styles of different programming languages
<BR>to their students) provided that the names of the contributors are retained.</I></FONT SIZE>
</CENTER>
<BR><A HREF=beer_s_z.html>More beer</A>
<BR><A HREF=../index.html>Back to the Funhouse</A>
<P>
<P>
<P>
&nbsp;
<HTML>
<HEAD>
   <TITLE>99 Bottles of Beer on the Wall (S-Z)</TITLE>
   <META NAME="Author" CONTENT="Tim Robinson">
</HEAD>
<BODY BACKGROUND="greenbar.gif" TEXT=#000000 BGCOLOR="#ffff00" LINK="#ff0000" VLINK="#007000" ALINK="#0077FF">
<UL>
<H2><A NAME="snobol">SNOBOL</A></H2>
<PRE>
* 99 BOTTLES OF BEER IN SNOBOL (UNTESTED)
         BEER = 99
MOREBEER OUTPUT = BEER ' BOTTLES OF BEER ON THE WALL'
         OUTPUT = BEER ' BOTTLES OF BEER'
         OUTPUT = 'TAKE ONE DOWN, PASS IT AROUND'
         BEER = BEER - 1
         OUTPUT = BEER ' BOTTLES OF BEER ON THE WALL'
         GT(BEER,0)   : S(MOREBEER)
         OUTPUT = 'NO MORE BOTTLES OF BEER ON THE WALL'
         OUTPUT = 'NO MORE BOTTLES OF BEER'
         OUTPUT = 'GO TO THE STORE AND BUY SOME MORE'
         OUTPUT = '99 BOTTLES OF BEER'
END
</PRE>
<HR>
<H2><A NAME="smalltalk">Smalltalk</A></H2>
<PRE>
"Programmer: patrick m. ryan - pryan@access.digex.net
"http://www.access.digex.net/~pryan

99 to: 1 by: -1 do: [ :i |
	i print. ' bottles of beer on the wall, ' print.
	i print. ' bottles of beer. ' print.
	'take one down, pass it around, ' print.
	(i-1) print. ' bottles of beer on the wall, ' print.
]
</PRE>
<HR>
<H2><A NAME="vaxdcl">Vax DCL</A></H2>
<PRE>

$ I=100
$ FIRSTLOOP:
$ IF (I.EQ. 1) THEN GOTO LAST_BOTTLE
$ WRITE SYS$OUTPUT I," BOTTLES OF BEER ON THE WALL"
$ WRITE SYS$OUTPUT I," BOTTLES OF BEER"
$ WRITE SYS$OUTPUT "IF ONE OF THEM SHOULD HAPPEN TO FALL"
$ WRITE SYS$OUTPUT I-1," BOTTLE OF BEER ON THE WALL"
$ WRITE SYS$OUTPUT "  "
$ I=I-1
$ GOTO FIRSTLOOP
$ LAST_BOTTLE:
$ WRITE SYS$OUTPUT "1 BOTTLE OF BEER ON THE WALL"
$ WRITE SYS$OUTPUT "1 BOTTLE OF BEER"
$ WRITE SYS$OUTPUT "IF IT SHOULD HAPPEN TO FALL"
$ WRITE SYS$OUTPUT "NO MORE BOTTLES OF BEER ON THE WALL"

</PRE>
<P>
<i>--- A noteworthy alternative</i>
<P>
<PRE>
; VMS DCL version of 99 Bottles of Beer
$ I=100
$ FIRSTLOOP:
$ C=0
$ L=1
$ PAUSE:
$ C=C+1
$ IF (I.EQ. 1) THEN GOTO LAST_BOTTLE
$ IF (C .EQ. 1500) THEN GOTO FIRSTCLEAN
$ GOTO PAUSE
$ FIRSTCLEAN:
$ GOTO WIPESCN
$ FIRSTLINE:
$ WRITE SYS$OUTPUT I," bottles of beer on the wall,"
$ C=0
$ L=2
$ FIRSTPAUSE:
$ C=C+1
$ IF (C .EQ. 2000) THEN GOTO SECONDCLEAN
$ GOTO FIRSTPAUSE
$ SECONDCLEAN:
$ GOTO WIPESCN
$ SECONDLINE:
$ WRITE SYS$OUTPUT I," bottles of beer."
$ C=0
$ L=3
$ SECONDPAUSE:
$ C=C+1
$ IF (C .EQ. 1500) THEN GOTO THIRDCLEAN
$ GOTO SECONDPAUSE
$ THIRDCLEAN:
$ GOTO WIPESCN
$ THIRDLINE:
$ WRITE SYS$OUTPUT "If one of them should happen to fall...."
$ C=0
$ L=4
$ THIRDPAUSE:
$ C=C+1
$ IF (C .EQ. 1500) THEN GOTO FOURTHCLEAN
$ GOTO THIRDPAUSE
$ FOURTHCLEAN:
$ GOTO WIPESCN
$ FOURTHLINE:
$ WRITE SYS$OUTPUT I-1," bottles of beer on the wall."
$ I=I-1
$ GOTO FIRSTLOOP
$ LAST_BOTTLE:
$ C=0
$ L=5
$ FOURTHPAUSE:
$ C=C+1
$ IF (C .EQ. 1500) THEN GOTO FITHCLEAN
$ GOTO FOURTHPAUSE
$ FITHCLEAN:
$ GOTO WIPESCN
$ FITHLINE:
$ WRITE SYS$OUTPUT "1 bottle of beer on the wall,"
$ C=0
$ L=6
$ FITHPAUSE:
$ C=C+1
$ IF (C .EQ. 1200) THEN GOTO SIXTHCLEAN
$ GOTO FITHPAUSE
$ SIXTHCLEAN:
$ GOTO WIPESCN
$ SIXTHLINE:
$ WRITE SYS$OUTPUT "1 bottle of beer..."
$ C=0
$ L=7
$ SIXTHPAUSE:
$ C=C+1
$ IF (C .EQ. 2200) THEN GOTO SEVENTHCLEAN
$ GOTO SIXTHPAUSE
$ SEVENTHCLEAN:
$ GOTO WIPESCN
$ SEVENTHLINE:
$ WRITE SYS$OUTPUT "If it should happen to fall...."
$ C=0
$ L=8
$ LASTPAUSE:
$ C=C+1
$ IF (C .EQ. 2000) THEN GOTO LASTCLEAN
$ GOTO LASTPAUSE
$ LASTCLEAN:
$ GOTO WIPESCN
$ LASTLINE:
$ WRITE SYS$OUTPUT "No more bottles of beer on the wall."
$ GOTO QUIT
$ WIPESCN:
$ C=0
$ WIPE:
$ C=C+1
$ WRITE SYS$OUTPUT " "
$ IF (C .EQ. 25) THEN GOTO SONGLINE
$ GOTO WIPE
$ SONGLINE:
$ IF (L .EQ. 1) THEN GOTO FIRSTLINE
$ IF (L .EQ. 2) THEN GOTO SECONDLINE
$ IF (L .EQ. 3) THEN GOTO THIRDLINE
$ IF (L .EQ. 4) THEN GOTO FOURTHLINE
$ IF (L .EQ. 5) THEN GOTO FITHLINE
$ IF (L .EQ. 6) THEN GOTO SIXTHLINE
$ IF (L .EQ. 7) THEN GOTO SEVENTHLINE
$ IF (L .EQ. 8) THEN GOTO LASTLINE
$ QUIT:
</PRE>
<HR>
<H2><A NAME="sas">SAS</A></H2>
<PRE>
/* SAS version of 99 bottles of beer        */
/* by Whitey (whitey@netcom.com) - 06/05/95 */

data _null_;
   do i = 99 to 1 by -1;
      put i 'bottles of beer on the wall,' i 'bottles of beer,';
      put 'take one down, pass it around,';
      j = i - 1;
      if j = 0 then
         put 'no more ' @;
      else
         put j @;
      put 'bottles of beer on the wall.';
   end;
run;
</PRE>
<HR>
<H2><A NAME="latex">TeX/LaTeX</A></H2>
<PRE>
%% TeX/LaTeX version of 99 bottles of Beer
%%
%% Craig J Copi - copi@oddjob.uchicago.edu
%%
\parindent=0pt
\newcount\beercurr
\def\beer#1{\beercurr=#1\let\next=\removebeer\removebeer}
\def\removebeer{
 \ifnum\beercurr>1 
   \the\beercurr\ bottles of beer on the wall,\par 
   \the\beercurr\ bottles of beer,\par 
   take one down, pass it around,\par 
   \advance\beercurr by -1 
   \the\beercurr\ bottle\ifnum1<\beercurr{s}\fi\ of beer on the wall.\par 
   \vskip 2ex\relax
 \else 
   1 bottle of beer on the wall,\par 1 bottle of beer,\par 
   take one down, pass it around,\par no bottles of beer on the wall.\par 
   \vskip .5ex
   Time to buy some more beer\ldots. \let\next=\relax
 \fi 
 \next}

\beer{99}
</PRE>
<HR>
<H2><A NAME="tutor">Tutor</A></H2>
<PRE>
*--- Chris Lopez - lopez@huey.vp.uiuc.edu ---*
*--- start of code ---*
define
        maxbeer = 99
        origin:n1
        beer            $$ # of beers remaining
        atloc           $$ where to start writing this line
        nextlin(x) = (x <= (x+100) $mod$ 3200)
*
mode    rewrite
calc    beer  <= maxbeer
        atloc <= 1
loop
.       at      nextlin(atloc)
.       showt   beer,2
.       * Warning: trailing space on following line
.       write    bottles of beer on the wall,
.       showt   beer,2
.       write    bottles of beer.
.       at      nextlin(atloc)
.       write   Take one down, pass it around.
outloop ((beer<=beer-1) &lt; 2)
.       showt   beer-1,2
.       write    bottles of beer.
endloop
*
write    1 bottle of beer.
at      nextlin(atloc)
write    1 Bottle of beer on the wall,  1 bottle of beer.
         Take it down, pass it around, no bottles of beer on the wall.
*
pause   keys=all
jumpout q

*--- end of code ---*
</PRE>
<HR>
<H2><A NAME="tcl">TCL</A></H2>
<PRE>
# Tcl version of 99 bottles of beer on the wall
# Author: Don Libes (libes@nist.gov)
#

proc bottles {i} {
	return "$i bottle[expr $i!=1?"s":""] of beer"
}

proc line123 {i} {
	puts "[bottles $i] on the wall,"
	puts "[bottles $i],"
	puts "take one down, pass it around,"
}

proc line4 {i} {
	puts "[bottles $i] on the wall.\n"
}

for {set i 99} {$i>0} {} {
	line123 $i
	incr i -1
	line4 $i
}

</PRE>
<HR>
<H2><A NAME="sml">SML</A></H2>
<I>See <A HREF="http://www.cs.Princeton.EDU/~appel/smlnj/">here</A> for more info</I>
<PRE>
(* SML version of 99 bottles of beer *)
(* written by Norvald - norvald@hsr.no *)
let
    val itoa = Makestring.intToStr
    fun getabeer 0 = (print "Go to the store and buy some more,\n";
		      print "99 bottles of beer on the wall.\n")
      | getabeer 1 = (print "1 bottle of beer on the wall,\n";
		      print "1 bottle of beer,\n";
		      print "Take one down, pass it around,\n";
		      print "0 bottle of beer on the wall.\n\n";
		      getabeer (0)) 
      | getabeer x = (print (itoa(x)^" bottles of beer on the wall,\n"); 
		      print (itoa(x)^" bottles of beer,\n");
		      print "Take one down, pass it around,\n";
		      print (itoa(x-1)^" bottles of beer on the wall.\n\n");
		      getabeer (x-1)) 
in
    getabeer 99;
end
</PRE>
<HR>
<H2><A NAME="sql">SQL</A></H2>
<PRE>
remark	99 bottles of beer with Oracle SQL*Plus
remark	R.vandePol@voeding.tno.nl	&lt; Rob van de Pol&gt;
remark
remark	assuming that YourTable contains at least 99 rows ;-)
remark
remark	RowNum is an Oracle psuedo column indicating the sequence the rows
remark	were selected.

SELECT 	TO_CHAR(100-rownum)||' bottles of beer on the wall, ' ||
		TO_CHAR(100-rownum)||' bottles of beer,' ,
	'take one down and pass it around, ' ,
	DECODE ( TO_CHAR(99-rownum) , '0' , 'No more' , TO_CHAR(99-rownum) )||
		' bottles of beer,'
FROM 	YourTable
WHERE 	rownum &lt; 100
</PRE>
<HR>
<H2><A NAME="scheme">Scheme</A></H2>
<PRE>
;;; Tim Goodwin (tim@pipex.net)

(define bottles
  (lambda (n)
    (cond ((= n 0) (display "No more bottles"))
          ((= n 1) (display "One bottle"))
          (else (display n) (display " bottles")))
    (display " of beer")))

(define beer
  (lambda (n)
    (if (> n 0)
        (begin
          (bottles n) (display " on the wall") (newline)
          (bottles n) (newline)
          (display "Take one down, pass it around") (newline)
          (bottles (- n 1)) (display " on the wall") (newline)
          (newline)
          (beer (- n 1))))))

(beer 99)
</PRE>
<HR>
<H2><A NAME="4dos">4DOS Batch</A></H2>
<PRE>
@ECHO OFF

:: BEER.BTM - 4DOS version 5.5 batch (btm) file
:: by Rodney M. Savard &lt;rodney.savard%phun@phunnet.org&gt;

SETLOCAL

SET plural=`s`

DO bottle = 99 TO 1 BY -1
   ECHOS %bottle% bottle%plural% of beer on the wall,
   ECHO  %bottle% bottle%plural% of beer.

   ECHOS Take one down, pass it around,

   IFF (%@EVAL[%bottle% - 1]) == (0) THEN
      ECHO  no more bottles of beer on the wall.
   ELSE
      IF (%@EVAL[%bottle% - 1]) == (1) UNSET plural
      ECHO  %@EVAL[%bottle% - 1] bottle%plural% of beer on the wall.
      ECHO.
   ENDIFF
ENDDO

ENDLOCAL
</PRE>
<HR>
<H2><A NAME="verilog">Verilog</A></H2>
<I>Verilog is a hardware modelling language.</I>
<PRE>
/***********************************************************
*    Module: 99 bottles of beer
* By Danny Mulligan
***********************************************************/
module beer;
    integer i;
    initial begin
        for (i=99; i>0; i=i-1)
        begin
            $display("%0d bottles of beer on the wall,", i);
            $display("%0d bottles of beer,", i);
            $display("Take one down and pass it around,");
            if (i==1)
                $display("No more bottles of beer on the wall.\n");
            else
                $display("%0d bottles of beer on the wall.\n", i-1);
        end
        $display("Go to the store and buy some more.");
    end
end
</PRE>
<HR>
<H2><A NAME="simula">Simula</A></H2>
<PRE>
BEGIN
  COMMENT
     Simula version of 99 beers
     Maciej Macowicz (mm@cpe.ipl.fr)
     Status: UNTESTED :)
  ;
  INTEGER bottles;

  FOR bottles:= 99 STEP -1 UNTIL 1 DO 
  BEGIN
    OutInt(bottles,1);
    OutText("bottle(s) of beer on the wall, ");
    OutInt(bottles,1);
    Outtext("bottle(s) of beer");
    OutImage;
    Outtext("Take one down, pass it around, ");
    OutInt(bottles,1);
    OutText("bottle(s) of beer on the wall, ");
  END;
  OutText("1 bottle of beer on the wall, one bottle of beer."); 
  Outimage;
  OutText("Take one down, pass it around, no more bottles of beer on the wall");
  OutImage
END    
</PRE>
<HR>
<H2><A NAME="sather">Sather</A></H2>
<i><a href=http://www.icsi.berkeley.edu/Sather>Click</a> for information.</i>
<PRE>
-- Sather for 99 Bottles of Beer
--
-- David Stoutamire (davids@icsi.berkeley.edu)

class MAIN is
   main is
      loop
         b::=99.downto!(1);
         #OUT + bob(b) + " on the wall, "
              + bob(b) + ".\n"
              + "Take one down, pass it around, "
              + bob(b-1) + " on the wall.\n\n";
      end
   end;

   bob(i:INT):STR is
      case i
      when 0 then return "no more bottles of beer";
      when 1 then return "1 bottle of beer";
      else return i.str + " bottles of beer";
      end
   end
end
</PRE>
<HR>
<H2><A NAME="vhdl">VHDL</A></H2>
<i><a href=http://www2.shef.ac.uk/uni/projects/vhicdl/index.html>VHDL</A> 
is VHSIC (Very High Speed Integrated Circuits)
Hardware Description Language used for hardware design and testing.</i>
<PRE>
--  This is the VHDL (ANSI/IEEE Std 1076 - 1993)
--  version of the beer song.
--  F. J. Ludicky, Sundstrand Aerospace

entity beer_song is
    port(bottles: out integer;
        words: out string(1 to 28);
        start_singing: in boolean);
end beer_song;

architecture silly of beer_song is
begin
    lets_sing: process
    begin
        wait on start_singing until start singing;
        for index_bottles in 99 downto 1 loop
                bottles <= index_bottles;
                words <= "bottles of beer on the wall,";
                wait for 5 sec;
                bottles <= index_bottles;
                words <= "bottles of beer,            ";
                wait for 5 sec;
                words <= "take one down,              ";
                wait for 5 sec;
                words <= "pass it around,             ";
                wait for 5 sec;
                bottles <= index_bottles - 1;
                words <= "bottles of beer on the wall."
                wait for 5 sec.
        end loop;
        assert false report "No more beer!" severity warning;
    end process lets_sing;
end silly;
</PRE>
<HR>
<H2><A NAME="superbase">Superbase</A></H2>
<PRE>
SUB main()
 REM "99 bottles of beer", Superbase SBL version
 REM written by Mark Pilgrim, f8dy@netaxs.com
 REM [ If my boss is reading this, I'd just like to reassure
 REM   him that I wrote this on my own time. -MP ]
 DIM i%%,beer$,bottle$
 OPEN WINDOW "99 bottles of beer"
 bottle$ = " bottles "
 beer$ = "99"
 FOR i%% = 99 TO 1 STEP - 1
   ? beer$ + bottle$ + "of beer on the wall,"
   ? beer$ + bottle$ + "of beer,"
   ? "Take " + IF (i%% &gt; 1,"one","it") + " down, pass it around,"
   IF i%% &gt; 1 THEN 
     beer$ = LTRIM$ ( TRIM$ ( STR$ (i%% - 1)))
     IF i%% = 2 THEN bottle$ = " bottle "
     ? beer$ + bottle$ + "of beer on the wall."
     ? 
   ELSE 
     ? "No more bottles of beer on the wall."
   END IF 
 NEXT 
 END SUB 
</PRE>
<HR>
<H2><A NAME="dc">Unix DC</A></H2>
<i>DC is Unix's desk calculator</i>
<PRE>
[ Sing the classic '99 Bottles of Beer', using the Unix dc utility.  ]sd
[                                                                    ]sd
[ Run this one by typing 'dc &lt; bottles.dc' at the Unix prompt, where ]sd
[ bottles.dc is the file containing these lines.                     ]sd
[ Author: Kevin Quick  kquick@iphase.com                             ]sd
[                                                                    ]sd
[ bottles of beer]sb[ on the wall]sw[,]sc
[take one down, pass it around]st[.]sp[no more]sk
[10 13lplwlbln1-10 13lclt10 13lclbln32lclwlbln]sl
[lzxPPPPlzxPPPPPPPPlzxPPPPP]so[lkP]sx[dZselyxsd]su
[d10le1-dse^ /d10/10*-48+P le0&lt;y]sy[d0=xd0&lt;u]sz
[llxloxln1-dsn0&lt;r]sr[Plf1-dsf0&lt;g]sg
99snlrx10P
</PRE>
<HR>
<H2><A NAME="trac">Trac</A></H2>
<PRE>
#(#*( TRAC version of 99 bottles of beer.                            ))
#(#*( written by Akira KIDA, SDI00379@niftyserve.or.jp               ))
#(#*(                                                                ))
#(#*( To run this, save the entire script as `beer.trac', and then   ))
#(#*( type three lines in order.                                     ))
#(#*(                                                                ))
#(#*(    #(ld,beer.trac)                                             ))
#(#*(    #(cl,beer,99)                                               ))
#(#*(    '                                                           ))
#(#*(                                                                ))
#(ds,bottle,(#(gr,1,B,(No more bottles),(#(gr,2,B,(B bottle),(B bottles))))))
#(ss,bottle,B)
#(ds,beer,(#(gr,1,B,,
(#(ps,#(cl,bottle,B) of beer on the wall(,) #(cl,bottle,B) of beer.(
)Take one down(,) pass it around.(
)#(cl,bottle,##(-,B,1)) of beer on the wall.(
)(
))#(cl,beer,##(-,B,1))))))
#(ss,beer,B)
</PRE>
<HR>
<H2><A NAME="sisal">Sisal</A></H2>
<i><a href=http://www.llnl.gov/sisal/SisalHomePage.html>Click</a>
for more information.</i>
<PRE>
% ------------------------------------------------------------
% The classic N bottles of beer problem.  The Sisal language
% is implicitly parallel and functional.  It is not really desigined
% for string processing (scientific numeric stuff is more like it!)
% The following program will run in parallel on Crays, the
% SGI Challenge, the Meiko, etc....  and run just swell on
% your average ordinary PC too.  More information on the Sisal
% language project can be found at
% 
% http://www.llnl.gov/sisal/SisalHomePage.html
%
% or contact sisal-info@sisal.llnl.gov
%
% Author: Pat Miller (patmiller@llnl.gov)
% 
% ------------------------------------------------------------

define main

type string = array[character];

% ------------------------------------------------------------
% OUCH -- have to really start from scratch
% ------------------------------------------------------------
function DigitToChar(d : integer returns character)
  character(integer('0')+d)
end function

% ------------------------------------------------------------
% Sisal has no I/O runtime library for strings so we
% can build up the ASCII representation a digit at a time
% The sign handling is there for completeness and is not needed
% to do the BEER problem
% ------------------------------------------------------------
function itoa(n : integer returns string)
  array_setl(
  let
    s := for initial
	   x := abs(n);
	   d := array[1: DigitToChar( mod(x,10) )];
         while x &gt; 10 repeat
	   x := old x / 10;
	   d := array_addl(old d,DigitToChar(mod(x,10)));
	 returns
	   value of d
	 end for
  in
    if n &lt; 0 then array_addl(s,'-') else s end if
  end let
  ,1)
end function

% ------------------------------------------------------------
% Produce one stanza of the 99 bottles of beer song.  Some care
% is taken to keep it grammatical
% ------------------------------------------------------------
function BottlesOfBeer(i : integer returns array[string])
  let
    s,bottles,preface,n,nextbottles :=
      if i = 1 then
	"1"," bottle","If that bottle","No more"," bottles"
      elseif i = 2 then
	itoa(2)," bottles","If one of those bottles",itoa(1)," bottle"
      else
	itoa(i)," bottles","If one of those bottles",itoa(i-1)," bottles"
      end if;
  in
    array[1:
      s || bottles || " of beer on the wall", 
      s || bottles || " of beer!",
      preface || " should happen to fall... ",
      n || nextbottles || " of beer on the wall!",
      ""
    ]
  end let
end function
  

% ------------------------------------------------------------
% This main loop executes in parallel stuffing the 4 lines
% of each stanza into an array holding the whole song
% ------------------------------------------------------------
function main(n : integer returns array[string])
  for i in 0,n-1
    howmany := n-i;
    stanza := BottlesOfBeer(howmany);
  returns value of catenate stanza
  end for ||
  array[1: "Time to buy more beer"]
end function
</PRE>
<HR>
<H2><A NAME="sed">sed</A></H2>
<I>The UNIX stream editor.  The creator of sed didn't think it's interesting to
edit empty files, so this needs some kind of input, e.g. 
<BR>echo '' | sed -f 99.sed</i>
<PRE>
1{
        s/.*/99 bottles of beer on the wall/
        h
        : x
        p
        s/ on.*//
        p
        s/.*/take :&: down, pass it around/
        /one/{
                s/:.*:/it/
                p
                g
                s/on\(.*le\)/no mor\1s/
                p
                s/.*//
                q
        }
        s/:.*:/one/
        p
        g
        y/1234567890/0123456789/
        /^.[0-8] /{
                s/^.//
                x
                s/\(.\).*/\1/
                G
                s/\n//
        }
        s/^0//
        s/^1\( .*le\)s/one\1/
        h
        p
        s/.*//
        p
        g
        b x
}
</PRE>
<HR>
<H2><A NAME="turing">Turing</A></H2>
<I><a href=http://www.turing.toronto.edu>Turing</a>
is a commercially supported language used in 50% of Ontario schools.</i>
<PRE>
%  Ric Holt  holt@csri.toronto.edu
%  Turing language version of 99 bottles of beer
for decreasing i : 99 .. 1
    put i, " bottle(s) of beer on the wall, ", i, " bottle(s) of beer"
    put "Take one down, pass it around, ", i - 1,
        " bottle(s) of beer on the wall"
end for
</PRE>
<HR>
<H2><A NAME="surf">Surf</A></H2>
<I><a href=http://www.hip.atr.co.jp/~ebg/>More information here.</a></i>
<PRE>
(begin 'SINGING

  (define HOW-MANY-BOTTLES
    (lambda (bottles where)
      (format stdout "%d bottle%d of beer%d\n"
	      (list (if (> bottles 0) bottles "No more")
		    (if (= bottles 1) "" "s")
		    where))))

  (recurse DRINKING (bottles 99)
    (how-many-bottles bottles " on the wall,")
    (how-many-bottles bottles ",")
    (if (= bottles 0)
	(display stdout "Go the the store, and buy some more!\n")
	(begin (display stdout "You take one down, pass it around,\n")
	       (how-many-bottles (- bottles 1) " on the wall.\n")
	       (drinking (- bottles 1)))))

  'GO-TO-THE-STORE)
</PRE>
<HR>
<H2><A NAME="surf">Surf</A></H2>
<I>The person who sent this was <A href=http://www.hip.atr.co.jp/~ebg/>Ed Gamble</A>
who promised more info on this language.  If it's not on his web page, pester him.</i>
<PRE>
(begin 'SINGING

  (define HOW-MANY-BOTTLES
    (lambda (bottles where)
      (format stdout "%d bottle%d of beer%d\n"
	      (list (if (> bottles 0) bottles "No more")
		    (if (= bottles 1) "" "s")
		    where))))

  (recurse DRINKING (bottles 99)
    (how-many-bottles bottles " on the wall,")
    (how-many-bottles bottles ",")
    (if (= bottles 0)
	(display stdout "Go the the store, and buy some more!\n")
	(begin (display stdout "You take one down, pass it around,\n")
	       (how-many-bottles (- bottles 1) " on the wall.\n")
	       (drinking (- bottles 1)))))

  'GO-TO-THE-STORE)
</PRE>
<HR>
<H2><A NAME="spitbol">SPITBOL</A></H2>
<PRE>
* MaxSPITBOL version (SPITBOL implementation on
* the Macintosh from Catspaw, Inc. (Salida, CO).
* NOTE:  I have no connection w/them other than being
* a long-time satisfied user of their product
* D.H.  &lt;hedges@pilot.njin.net&gt;

     p0 = "NO MORE" ;  p1 = " BOTTLE" ; p2 = "S" ; p3 = " OF BEER"
     p4 = " ON THE WALL" ; p5 = "TAKE ONE DOWN, PASS IT AROUND"

     b = 99
     p6 = ((NE(b,0) b, p0) p1 (NE(b,1) p2,) p3)
A1   OUTPUT = p6 p4 ; OUTPUT = p6 ; OUTPUT = p5
     b = b - 1
     p6 = ((NE(b,0) b, p0) p1 (NE(b,1) p2,) p3)
     OUTPUT = p6 p4 ; OUTPUT = ; NE(b,0)                   :S(A1)
END
</PRE>
<HR>
<H2><A NAME="zsh">zsh</A></H2>
<I>Yet another UNIX shell.</i>
<PRE>
#!/usr/local/bin/zsh
alias dec_beer='let beer="\$beer - 1"'
alias print_strophe='echo "$beer bottle$s of beer on the wall,"
	echo "$beer bottle$s of beer,"
	echo "take one down, pass it around,"
	dec_beer
	if [ "$beer" -eq "1" ]
	then
		unset s
	fi
	if [ "$beer" -eq "0" ]
	then
		beer="No"
		s="s"
	fi
	echo "$beer bottle$s of beer on the wall."
	echo'


beer=99
s="s"
while [ "$beer" -ne "No" ]
do
	print_strophe
done
</PRE>
<HR>
<H2><A NAME="sendmail">Sendmail</A></H2>
<I>Sendmail is used by mail systems for routing and controlling
e-mail delivery.  It was never really intended for general purpose
programming, but here you go.
</i>
<PRE>
# Save this to /tmp/foo.bar
# echo '49 9 9' | /usr/lib/sendmail -bt -d21 -C/tmp/foo.bar
# Sorry, Smail is too brain dead to run this.  Use sendmail instead.
# Programmed by: Felix von Leitner <leitner@inf.fu-berlin.de>

DH"take one down\, pass it around\,"
DG"bottles of beer"
DF"$G on the wall\."
DE"$G on the wall\,"
DN"No beer left\."

S45
R$- 2 $*	foo bar $1 1 $F
R$- 3 $*	$1 2 $F
R$- 4 $*	$1 3 $F
R$- 5 $*	$1 4 $F
R$- 6 $*	$1 5 $F
R$- 7 $*	$1 6 $F
R$- 8 $*	$1 7 $F
R$- 9 $*	$1 8 $F
R9 0 $*		8 9 $F
R8 0 $*		7 9 $F
R7 0 $*		6 9 $F
R6 0 $*		5 9 $F
R5 0 $*		4 9 $F
R4 0 $*		3 9 $F
R3 0 $*		2 9 $F
R2 0 $*		1 9 $F
R1 0 $*		0 9 $F
R$- 1 $*	$1 0 $F
Rfoo bar $- 1 $F	$1 1 $F
R0 0 $*		$N

S47
R$- $- $E	$1 $2 $G,

S48
R$- $-		$>47 $1 $2 $E
R$- $- $G,	$>45 $1 $2 $H
R$- $- $F	$1 $2
R$N		*burp*

S49
R$- $-					$>48 $1 $2
</PRE>
<HR>
<H2><A NAME="setl">SETL</A></H2>
<I>An online <a href=http://galt.nyu.edu/~bacon/setl-server.html>SETL server</a>
is available where you can run the program without the compiler.</i>
<PRE>
$ SETL version
$ written by Arion Lei (philipl@cs.ust.hk)
beer := {1,2..99};
(until beer={})
  print(#beer, " bottles of beer on the wall,");
  print(#beer, " bottles of beer.  Take one down, pass it around,");
  $ take an arbitrary one down
  beer less := arb beer;
  if beer/={} then
    print(#beer, " bottles of beer on the wall.");
  end if beer/={};
end until;
print("No more bottles of beer on the wall, no more bottles of beer.");
print("Go to the store and buy some more... 99 bottles of beer");
</PRE>
<HR>
<H2><A NAME="yorick">Yorick</A></H2>
<I>Click <a href=http://topaz.sensor.com/work/lang/yorick/>here</a>
for further information.</i>
<PRE>
/*  The Bottles of Beer song (c) 1996 Eric Korpela
 *   Yorick version-- Modeled after the IDL version.
 * USAGE:  bottles or bottles, number
 */

/* Set up our song structure............ */

struct _song {
  int n0;
  string s1;
  int n1;
  string s2,s3;
  int n2;
  string s4;
} 

func bottles( number )
{

  if (is_void(number)) { 
    number=99
    write,"BOTTLES: Defaulting to 99 bottles!"
  }
 
  song=array(_song(n0=0,s1=" bottles of beer on the wall.\n",n1=0,
                   s2=" bottles of beer.\n",
                   s3="You take one down and pass it around\n",
                   n2=0,
                   s4=" bottles of beer on the wall.\n"), number)

  /* put in the appropriate numbers */

  i=(number)-indgen(number)
  song(*).n0=i+1
  song(*).n1=i+1
  song(*).n2=i
 
  write,song.n0,song.s1,song.n1,song.s2,song.s3,song.n2,song.s4
 
}
</PRE>
<HR>
<H2><A NAME="vim">VIM</A></H2>
<i><a href=http://www.math.fu-berlin.de/~guckes/vim>VIM</a>
 is an editor language similar to <a href=#vi>vi</a>
The ^[ and ^X represent and Esc and Ctrl-X respecively</i>
<PRE>
:" This is a beer program for VIM.
:" Written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;
:" Run by :so! beer
i102 bottles^[0v$"bd
qzA of beer on the wall^Xq
qa"bp@zA,
   ^["bpA of beer.
^[q
qcATake one down, pass it around,
   ^["bp0^X03lv$"by@zA.

^[q
qd@a@cq
:0
dG98@dA1 bottle^[0v$"bd@aA1 bottles^[0v$"bd@c@aAGo to the store and buy some more,
   100 bottles^[@zA...^[

</PRE>
<HR>
<H2><A NAME="vi">vi</A></H2>
<i>vi is the classic, pre-emacs text editor for U**x.</i>
<PRE>
I
! 99 bottles of beer lyrics generation using vi macros!
! 
! instructions:
!  1. rename your .exrc (so you have no existing macros to conflict with mine)
!  2. vi outfile &lt; this_file &gt;/dev/null 2>&1
! the output will be in outfile
!
! Please note that this file is littered with control characters.
!   All ^V, and ^] and ^M character sequences are control characters.
!   The other occurrences of ^ are actually supposed to be there.
!
! I also might be the first to point out that I took the liberty of
! using 'bc' to do my recalculations (sorry).
!
! Scott Engberg
! 6/8/96
! Scott.Engberg@mfa.com
!
^[Gd1G
:set magic
:map F A bottles of beer on the wall^V^M
:map K A bottles of beer^V^M
:map H Atake one down pass it around^V^M
:map Q "aP
:map O "ayy
:map W A-1
:map E !!bc^V^M
:map S :s/^\([1-9]\)/\1/^V^M
:map R OF^V^[QK^V^[H^V^[QW^V^[EST
:map T R
i99^[R^[
G
?^0
dG
oNo more bottles of beer on the wall!^[
:wq!
</PRE>
<HR>
<H2><A NAME="vb">Visual Basic</A></H2>
<i></i>
<PRE>
   'Jeff Shepherd 9/12/96 <jeff@trg.saic.com>
   '99 Bottles of Beer for Visual Basic
   '(1) Start a new project, paste a single listbox on the form.
   '(2) Double-click on the form, paste the following code into
   'the Form_Load sub. (3) Hit F5 to run

   Dim n As Integer
   Dim s As String

   Width = 6000
   Height = Screen.Height * 2 / 3
   Top = (Screen.Height - Height) / 2
   Left = (Screen.Width - Width) / 2
   Caption = "99 Bottles of Beer"
   List1.Top = 0
   List1.Left = 0
   List1.Width = Form1.ScaleWidth
   List1.Height = Form1.ScaleHeight

   List1.AddItem s & "99 bottles of Beer on the wall,"
   List1.AddItem s & "99 bottles of Beeeer..."
   List1.AddItem "You take one down, pass it around..."
   For n = 98 To 1 Step -1
      s = IIf(n = 1, n & " final bottle", n & " bottles")
      List1.AddItem s & " of Beer on the wall."
      List1.AddItem ""
      List1.AddItem s & " of Beer on the wall,"
      List1.AddItem s & " of Beeeer..."
      List1.AddItem "You take one down, pass it around..."
   Next n
   List1.AddItem "No more bottles of Beer on the wall."
</PRE>
<HR>
<H2><A NAME="turingmachine">Turing Machine</A></H2>
<i>In the dawn of the computing era, Alan Turing proposed a type of computer.
This is an implementation of 99BoB for such a machine.  Full details available
at <a href=http://coli.uni-sb.de/~theiling/pub/Turing%20Machine/">
http://coli.uni-sb.de/~theiling/pub/Turing%20Machine/</a></i>
<PRE>
% `99 Bottles of Beer' on a Turing Machine

% written 6/97 by Henrik Theiling <theiling@coli.uni-sb.de>

%% This defines \delta, the transition function.  There are four entries
%% on each line:
%%   CurrentCharacter OldState    NewCharacterOrAction NewState
%%
%% Thus each line defines:
%%   \delta (CurrentCharacter,OldState) = (NewCharacterOrAction, NewState)
%%

% initialise tape with # cr "99" (#)
  #    0      ->    1
  #    1      cr    2
  cr   2      ->    3
  #    3      \9    3
  \9   3      ->    4
  #    4      \9    4
  \9   4      ->    10
  #    10     1000  10
  1000 10     <-    100

% write `bottle' or `bottles':
% check for `1'
  ?    100    ?    105
  \1   100    <-   102
  ?    102    ?    105
  cr   102    cr   120  % write `bottle', not `bottles'

% write `bottles' (first shift back to the left):
  \0   105    ->   105
  \1   105    ->   105
  \2   105    ->   105
  \3   105    ->   105
  \4   105    ->   105
  \5   105    ->   105
  \6   105    ->   105
  \7   105    ->   105
  \8   105    ->   105
  \9   105    ->   105
  ?    105    ->   106
  #    106    b    106
  b    106    ->   107
  #    107    o    107
  o    107    ->   108
  #    108    t    108
  t    108    ->   109
  #    109    t    110
  t    110    ->   111
  #    111    l    111
  l    111    ->   112
  #    112    e    112
  e    112    ->   113
  #    113    s    200

% write `bottle' (first shift back to the left):
  \1   120    ->   120
  cr   120    ->   120
  ?    120    ->   121
  #    121    b    121
  b    121    ->   122
  #    122    o    122
  o    122    ->   123
  #    123    t    123
  t    123    ->   124
  #    124    t    124
  t    124    ->   125
  #    125    l    125
  l    125    ->   126
  #    126    e    200

% return subroutine 1:
  ?    200    <-   200
  1000 200    #    1000
  2000 200    _    2000
  3000 200    _    3000
  5000 200    #    5000
  6000 200    _    6000
  7000 200    cr   7000
  9100 200    #    9100
  9200 200    _    9200
  9300 200    _    9300
  #    200    #    stop

% return subroutine 2:
  ?    210    ->   210
  4000 210    cr   4000
  8000 210    cr   8000
  9000 210    #    9000
  9400 210    cr   9400

%
% This is the main loop:
%
% 1000 is the return state for the first line after `bottle' or `bottles'
% has been written.
  #    1000   ->   1001
  ?    1001   ->   1001
  #    1001   2000 1002
  2000 1002   ->   300   % write `of beer'

  ?    2000   ->   2000
  #    2000   3000 2000
  3000 2000   ->   400   % write `on the wall'

  ?    3000   ->   3000
  #    3000   4000 500   % copy number

  ?    4000   ->   4000
  #    4000   5000 4000
  5000 4000   <-   100   % write `bottle' or `bottles'

  #    5000   ->   5001
  ?    5001   ->   5001
  #    5001   6000 5002
  6000 5002   ->   300   % write `of beer'

  ?    6000   ->   6000
  #    6000   7000 6000
  7000 6000   ->   700   % write `Take one away and pass it around,'

  ?    7000   ->   7000
  #    7000   8000 500   % copy number

  ?    8000   ->   8000
  #    8000   _    8001
  _    8001   ->   8001
  #    8001   9000 8001
  9000 8001   <-   8002   % decrement number
  _    8002   <-   800

  cr   9000   ->   9004   % zero: all zeros have been eliminated...
  #    9000   <-   9000
  _    9000   #    9001
  #    9001   <-   9000
  ?    9000   ->   9002
  #    9002   9100 9002
  9100 9002   <-   100   % write `bottle' or `bottles'

  #    9004   \0   9004
  \0   9004   ->   9000

  #    9100   ->   9101
  ?    9101   ->   9101
  #    9101   9200 9101
  9200 9101   ->   300    % write `of beer'

  ?    9200   ->   9200
  #    9200   9300 9200
  9300 9200   ->   400   % write `on the wall'

  ?    9300   ->   9300
  #    9300   .    9300  % write a full-stop
  .    9300   ->   9301
  #    9301   cr   9301  % and an additional newline
  cr   9301   ->   9302
  #    9302   9400 500   % copy number

  cr   9400   ->   9400
  \0   9400   ->   9400
  ?    9400   ->   9401
  ?    9401   ->   9401
  #    9401   1000 9401
  1000 9401   <-   100  % start again
  #    9400   <-   9900 % write `Time to go to the store.' and stop

  \0   9900   T    9900
  T    9900   ->   9901
  #    9901   i    9901
  i    9901   ->   9902
  #    9902   m    9902
  m    9902   ->   9903
  #    9903   e    9903
  e    9903   ->   9904
  #    9904   _    9904
  _    9904   ->   9905
  #    9905   t    9905
  t    9905   ->   9906
  #    9906   o    9906
  o    9906   ->   9907
  #    9907   _    9907
  _    9907   ->   9908
  #    9908   g    9908
  g    9908   ->   9909
  #    9909   o    9909
  o    9909   ->   9910
  #    9910   _    9910
  _    9910   ->   9911
  #    9911   t    9911
  t    9911   ->   9912
  #    9912   o    9912
  o    9912   ->   9913
  #    9913   _    9913
  _    9913   ->   9914
  #    9914   t    9914
  t    9914   ->   9915
  #    9915   h    9915
  h    9915   ->   9916
  #    9916   e    9916
  e    9916   ->   9917
  #    9917   _    9917
  _    9917   ->   9918
  #    9918   s    9918
  s    9918   ->   9919
  #    9919   t    9919
  t    9919   ->   9920
  #    9920   o    9920
  o    9920   ->   9921
  #    9921   r    9921
  r    9921   ->   9922
  #    9922   e    9922
  e    9922   ->   9923
  #    9923   .    200   % go back to the beginning and halt

% write `of beer':
  #    300    o    300
  o    300    ->   301
  #    301    f    301
  f    301    ->   302
  #    302    _    302
  _    302    ->   303
  #    303    b    303
  b    303    ->   304
  #    304    e    304
  e    304    ->   305
  #    305    e    305
  e    305    ->   306
  #    306    r    200 % return <-

% write `on the wall':
  #    400    o    400
  o    400    ->   401
  #    401    n    401
  n    401    ->   402
  #    402    _    402
  _    402    ->   403
  #    403    t    403
  t    403    ->   404
  #    404    h    404
  h    404    ->   405
  #    405    e    405
  e    405    ->   406
  #    406    _    406
  _    406    ->   407
  #    407    w    407
  w    407    ->   408
  #    408    a    408
  a    408    ->   409
  #    409    l    409
  l    409    ->   410
  #    410    l    200 % return <-

% write `Take one away and pass it around,':
  #    700    T    700
  T    700    ->   701
  #    701    a    701
  a    701    ->   702
  #    702    k    702
  k    702    ->   703
  #    703    e    703
  e    703    ->   704
  #    704    _    704
  _    704    ->   705
  #    705    o    705
  o    705    ->   706
  #    706    n    706
  n    706    ->   707
  #    707    e    707
  e    707    ->   708
  #    708    _    708
  _    708    ->   709
  #    709    a    709
  a    709    ->   710
  #    710    w    710
  w    710    ->   711
  #    711    a    711
  a    711    ->   712
  #    712    y    712
  y    712    ->   713
  #    713    _    713
  _    713    ->   714
  #    714    a    714
  a    714    ->   715
  #    715    n    715
  n    715    ->   716
  #    716    d    716
  d    716    ->   717
  #    717    _    717
  _    717    ->   718
  #    718    p    718
  p    718    ->   719
  #    719    a    719
  a    719    ->   720
  #    720    s    720
  s    720    ->   721
  #    721    s    721
  s    721    ->   722
  #    722    _    722
  _    722    ->   723
  #    723    i    723
  i    723    ->   724
  #    724    t    724
  t    724    ->   725
  #    725    _    725
  _    725    ->   726
  #    726    a    726
  a    726    ->   727
  #    727    r    727
  r    727    ->   728
  #    728    o    728
  o    728    ->   729
  #    729    u    729
  u    729    ->   730
  #    730    n    730
  n    730    ->   731
  #    731    d    731
  d    731    ->   732
  #    732    ,    200 % return <-

% decrement decimal number in ASCII format (hangs on underflow):
  \2   800    \1   210
  \3   800    \2   210
  \4   800    \3   210
  \5   800    \4   210
  \6   800    \5   210
  \7   800    \6   210
  \8   800    \7   210
  \9   800    \8   210
  \1   800    \0   802
  \0   800    \9   801
  \9   801    <-   800
  \0   802    <-   802
  ?    802    ->   210
  cr   802    ->   803
  \0   803    \9   803
  \9   803    ->   803
  _    803    <-   804
  \9   804    _    210

% copy number:
  ?    500    <-   500
  #    500    _    501
  ?    501    <-   501
  cr   501    ->   502
  \0   502    #    600
  \1   502    #    610
  \2   502    #    620
  \3   502    #    630
  \4   502    #    640
  \5   502    #    650
  \6   502    #    660
  \7   502    #    670
  \8   502    #    680
  \9   502    #    690
  _    502    ->   210 % return ->

% Copying ciphers:

% copy `0' to the right:
  #    600    ->   601
  ?    601    ->   601
  #    601    \0   602
  ?    602    <-   602
  #    602    \0   603
  \0   603    ->   502 % next cipher

% copy `1' to the right:
  #    610    ->   611
  ?    611    ->   611
  #    611    \1   612
  ?    612    <-   612
  #    612    \1   613
  \1   613    ->   502 % next cipher

% copy `2' to the right:
  #    620    ->   621
  ?    621    ->   621
  #    621    \2   622
  ?    622    <-   622
  #    622    \2   623
  \2   623    ->   502 % next cipher

% copy `3' to the right:
  #    630    ->   631
  ?    631    ->   631
  #    631    \3   632
  ?    632    <-   632
  #    632    \3   633
  \3   633    ->   502 % next cipher

% copy `4' to the right:
  #    640    ->   641
  ?    641    ->   641
  #    641    \4   642
  ?    642    <-   642
  #    642    \4   643
  \4   643    ->   502 % next cipher

% copy `5' to the right:
  #    650    ->   651
  ?    651    ->   651
  #    651    \5   652
  ?    652    <-   652
  #    652    \5   653
  \5   653    ->   502 % next cipher

% copy `6' to the right:
  #    660    ->   661
  ?    661    ->   661
  #    661    \6   662
  ?    662    <-   662
  #    662    \6   663
  \6   663    ->   502 % next cipher

% copy `7' to the right:
  #    670    ->   671
  ?    671    ->   671
  #    671    \7   672
  ?    672    <-   672
  #    672    \7   673
  \7   673    ->   502 % next cipher

% copy `8' to the right:
  #    680    ->   681
  ?    681    ->   681
  #    681    \8   682
  ?    682    <-   682
  #    682    \8   683
  \8   683    ->   502 % next cipher

% copy `9' to the right:
  #    690    ->   691
  ?    691    ->   691
  #    691    \9   692
  ?    692    <-   692
  #    692    \9   693
  \9   693    ->   502 % next cipher
</PRE>
<HR>
<H2><A NAME="tinyfugue">Tiny Fugue</A></H2>
<i><a href=http://tf.tcp.com/~hawkeye/tf/>Tiny Fugue</a>
 is a mud client language</i>
<PRE>
; 99 bottles of beer in TF macros.
; by Carey Evans.
;
; Type "/beer" to use after loading it.

/def beerecho = /echo - %{*}
/def beerbreath = /echo

; Uncomment the following lines instead to send to the MUD:
; /def beerecho = say %{*}
; /def beerbreath = :takes a deep breath.

/def beerbottles = \
    /if ({1} == 1) /echo 1 bottle of beer%; \
    /else /echo %{1} bottles of beer%; \
    /endif

/def beer1 = /beerecho $(/beerbottles %{1}) on the wall%2
/def beer2 = /beerecho $(/beerbottles %{1}).
/def beer3 = /beerecho Take one down and pass it around,

/def beer = \
    /let bottles=%{1-99}%; \
    /while ( bottles > 0 ) \
	/beer1 %{bottles} ,%; \
	/beer2 %{bottles}%; \
	/beer3%; \
	/let bottles=$[bottles - 1]%; \
	/if ( bottles == 0 ) /break%; /endif%; \
	/beer1 %{bottles} .%; \
	/beerbreath%; \
    /done%; \
    /beerecho No more bottles of beer on the wall.
</PRE>
<HR>
<H2><A NAME="sr">SR</A></H2>
<i>SR (Synchronizing Resources) is an educational language with
built-in multi-threading and multi-processing. The language is
available at <a href=ftp://ftp.cs.arizona.edu/sr/>ftp://ftp.cs.arizona.edu/sr/</a></i>
<PRE>
# SR version of 99 bottles of beer
# by David Larsson 
# mailto:f92dala@dd.chalmers.se    http://www.dd.chalmers.se/~f92dala
#
# This version demonstrates some of SR's concurrent aspects, simulating
# the (common?) situation where 99 people drink one bottle of beer each
# simultaneously, while singing exactly one verse of the song.
#
resource main()
    op sing_it(int; string[120])

    # Create 99 processes (or, rather, threads)
    # for the verses in the song
    process swing_it(bottle := 1 to 99)
        var bottle1_str, bottle2_str : string[15];

        if bottle > 2 ->
            bottle1_str := string(bottle) || " bottles";
            bottle2_str := string(bottle-1) || " bottles";
        [] bottle = 2 ->
            bottle1_str := "2 bottles";
            bottle2_str := "1 bottle";
        [] else ->
            bottle1_str := "1 bottle";
            bottle2_str := "No more bottles";
        fi
        
        # Send the verse back to the main thread
        send sing_it(bottle, 
                  bottle1_str || " of beer on the wall, "
                   || bottle1_str || " of beer...\n"  
                   || "Take one down and pass it around\n" 
                   || bottle2_str || " of beer on the wall\n");
    end swing_it

    # Make sure the verses get printed in the right order
    fa expected := 99 downto 1 ->
        in sing_it(bottle, verse) st bottle = expected ->
            write(verse);
        ni
    af

    # I guess the bartender sings this one
    write("Go to the store, buy some more!");
    write("99 bottles of beer on the wall");
end main
</PRE>
<HR>
<H2><A NAME="simscript">Simscript</A></H2>
<i>SIMSCRIPT is a simulation language from CACI and runs on PCs and VAXen.</i>
<PRE>
'' 99 Bottles of Beer using SIMSCRIPT
'' Author: Jeremy Konopka  <konopka@cs.uregina.ca>

PREAMBLE
        PROCESSES
                INCLUDE brewer, drinker
        RESOURCES
                INCLUDE bottle
        DEFINE countem AS A INTEGER VARIABLE

END

MAIN
        CREATE EVERY bottle(1)
        LET U.bottle(1) = 1
        LET countem=100
        ACTIVATE A brewer NOW
        START SIMULATION
        PRINT 1 LINE THUS
           No more bottles of beer on the wall.

END

PROCESS brewer
        FOR I=1 TO 99
        DO
                ACTIVATE A drinker NOW
        LOOP
END

PROCESS drinker

        REQUEST 1 bottle(1)
        RELINQUISH 1 bottle(1)
        LET countem = countem - 1

        IF countem > 1 
        PRINT 3 LINES WITH countem, countem THUS
          ** bottles of beer on the wall.
          ** bottles of beeeeer ...,
          Take one down, pass it around,
        ELSE
        PRINT 3 LINES WITH countem, countem THUS
          ** bottle of beer on the wall.
          ** bottle of beeeeer ...,
          Take it down, pass it around,
        ALWAYS
        IF countem > 2 
        PRINT 2 LINES WITH countem-1 THUS
          ** bottles of beer on the wall.

        ALWAYS
        IF countem = 2 
        PRINT 2 LINES THUS
          One more bottle of beer on the wall.

        ALWAYS
END
</PRE>
<HR>
<H2><A NAME="wordbasic">Word Basic</A></H2>
<i>For the Microsoft Word word processor.</i>
<PRE>
' Word Basic version of 99 bottles of beer
' by Cory Sandahl (sandahl@u.washington.edu) 12/10/96

Sub MAIN

FileNew .NewTemplate = 1, .Template = "Normal.DOT"
StartOfDocument
s$ = "s"

For NumberOfBeers = 99 To 1 Step - 1

    Insert Str$(NumberOfBeers) + " bottle" + s$ + " of beer on the wall," + Chr$(11)
    Insert Str$(NumberOfBeers) + " bottle" + s$ + " of beer..." + Chr$(11)
    Insert "Take one down, pass it around," + Chr$(11)
    
    If (NumberOfBeers - 1) < 2 Then
        s$ = ""
    End If

    Insert Str$(NumberOfBeers - 1) + " bottle" + s$ + " of beer on the wall. " + Chr$(11) + Chr$(11)

Next
Insert Chr$(11) + Chr$(11) + "No more beer.  Bye-bye."

End Sub
</PRE>
<HR>
<H2><A NAME="silk">Silk</A></H2>
<i>Silk is a language for generating web pages on the fly.</i>
<PRE>

&lt;%sub default()%&gt;
&lt;html&gt;&lt;title&gt;SilkyBeers&lt;/title&gt;&lt;body&gt;&lt;h1&gt;99 beers on the wall, silk style...&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;%
	nBeers = 99
	while (nBeers &gt; 0)
		?CStr(nBeers) & " bottles of beer on the wall,"
		?Cstr(nBeers) & " bottles of beer..."
		?"Take one down, pass it around,"
		nBeers = nBeers - 1
		?CStr(nBeers) & " bottles of beer on the wall.&lt;br&gt;"
	wend
%&gt;
&lt;/body&gt;&lt;/html&gt;
&lt;%end sub%&gt;

</PRE>
<HR>
<H2><A NAME="usertalk">Usertalk</A></H2>
<i>Macintosh scripting language</i>
<PRE>
on ninetyNineBottles() {
  local {
    lyrics = "";
    bottleStartCount = 99;
    bottleString = "";
    eol = "\r"};

  on numBottles(theCount) {
    local {
      s = ""};
    case theCount {
      0 {
        s = "No more bottles"};
      1 {
        s = "1 more bottle"}}
    else {
      s = theCount + " bottles"};
    return(s)};

  on finishVerse(theCount) {
    local {
      s = "Take one down and pass it around, " + eol};
    s = s + numBottles(theCount - 1) + " of beer on the wall."\
    + eol + eol;
    return(s)};

  for bottleCount = bottleStartCount downto 1 {
    bottleString = numBottles(bottleCount);
    lyrics = lyrics + bottleString + " of beer on the wall, "\
    + bottleString + " of beer." + eol + finishVerse(bottleCount)};
  lyrics = lyrics + "No more bottles of beer on the wall, "\
  + "no more bottles of beer." + eol\
  + "Go to the store and buy some more." + eol\
  + "99 bottles of beer on the wall.";
  return(lyrics)};

theLyrics = @workspace.lyrics99;

if not defined (theLyrics^) {
  new (wptextType, theLyrics)};

target.set (theLyrics);

wp.setText(ninetyNineBottles());

edit (theLyrics); open it in a window

window.zoom("workspace.lyrics99")
</PRE>
<HR>
<H2><A NAME="terse">Terse</A></H2>
<PRE>
\\\\\\\\
\ Beer \
\\\\\\\\
\
\   Program to print the lyrics to "99 Bottles of Beer on the Wall"
\   Runs under any version of DOS, 176 byte .COM file.
\
\   Written in TERSE by jim-neil@digital.net (Jim Neil).  TERSE is
\   an x86 specific language that has the same level of control as
\   assembly, with the look-and-feel and ease-of-use of a HLL.
\
\   For more information on TERSE, visit the TERSE website at:
\                      http://www.terse.com

main Group code,data;
Assume cs:main,ds:main;
O Equ <Offset main:>;

code Segment byte;
Org 0100h;

data Segment byte;
  ' m0 =" Bottle$";
  ' m1 =" of Beer on the Wall";
  ' nl =(10,13,'$');
  ' m2 =" of Beer", =(10,13);
  ' m3 ="Take one down and pass it around", =(10,13,'$');
data EndS;

Beer Proc;
  cx = 99;                      \ cx = number to do.
  {                             \ for cx = 99..1, do...
    dx = O(nl); ah = 9; !21h;   \ new line.
    al = cl; =.Bottles;         \ print number and "Bottle(s)".
    dx = O(m1); ah = 9; !21h;   \ output lyric line 1.
    al = cl; =.Bottles;         \ print number and "Bottle(s)".
    dx = O(m2); ah = 9; !21h;   \ output lyric lines 2-3.
    al = cl-; =.Bottles;        \ print number - 1 and "Bottle(s)".
    dx = O(m1); ah = 9; !21h;   \ output lyric line 4.
  }-.;                          \ loop till done...
  !20h;                         \ return to DOS.
Beer EndP;

\\\\\\\\\\\
\ Bottles \
\\\\\\\\\\\
\
\   Bottles prints "n Bottle(s)", controling plural based on the
\   value of n passed in al.
\
\   Entry Conditions:
\       al = n.
\       ah = Scratch;
\       dx = Scratch;
\
\   Exit Conditions:
\       ax = scratch.
\       dx = scratch.

Bottles Proc;
  =ax; =.BinDec;                \ print number of beers.
  dx = O(m0); ah = 9; !21h;     \ output "bottle".
  ax=; al - 1 ? <>              \ if not 1...
  { dl = 's'; ah = 2; !21h; };  \ make it plural.
  .=;                           \ and, return...
Bottles EndP;

\\\\\\\\\\
\ BinDec \
\\\\\\\\\\
\
\   BinDec prints a binary number (0-63h) in al to the screen
\   in decimal with leading zero supression.
\
\   Entry Conditions:
\       ah = scratch.
\       al = number to convert.
\       dx = scratch.
\
\   Exit Conditions:
\       ax = scratch.
\       dx = scratch.

BinDec Proc Near;
  "*; ax + '00'; dh = al;       \ split and convert, dh = save LSB.
  ah - '0' ? <>                 \ if MSB is non-zero...
  { dl = ah; ah = 2; !21h; };   \ then, output MSB.
  dl = dh; ah = 2; !21h;        \ output LSB.
  .=;                           \ and return...
BinDec EndP;

code EndS;
End Beer;
</PRE>
<HR>
<H2><A NAME="tintin">TinTin</A></H2>
<i>Yet another Mud client language like tinyfugue.</i>
<PRE>
#nop 99 Bottles of beer for TinTin++ (Mud Client)
#nop Coded 1997, Andrew Forster <bluemeat@mono.org>
#var {do} {#showme}
#nop (can use say if you want to sing to the mud :-) )
#alias {beer %0} {#math {wang} {%%0-1}; $do %0 bottles of beer on the
wall; $do %0 bottles of beer; $do take one down, pass it around,;
beerloop; nobeer;}
#nop The initial part of the beer call
#alias {beerloop} {bl $wang}
#nop a weird way of doing it, but the only way I can see of getting the
#nop maths to propagate into the beer statement.
#alias {bl %0} {#loop {%%0, 2} {$do %0 bottles of beer on the wall; $do
-------; $do %0 bottles of beer on the wall; $do %0 bottles of beer; $do
take one down, pass it around; $do one bottle of beer on the wall}}
#nop The main loop of the beer passing
#alias {nobeer} {$do --------; $do one bottle of beer on the wall; $do
one bottle of beer; $do take one down pass it around; $do fuck me
there's no beer left; }
#nop No beer left. So give up :-)
</PRE>
<HR>
<H2><A NAME="trumpet">Trumpet</A></H2>
<i>This is the scripting language used by the Trumpet Winsock dialer.</i>
<PRE>
#  99 Bottles of Beer on the Wall
#  Written by Andrew Turley aturley@sound.net
$para = " bottle"
$parb = " of beer on the wall,"
$parc = " of beer."
$pard = "Take one down, pass it around,"
$pare = " of beer on the wall."
$parf = "no bottles of beer on the wall!"
$pl = "s"
%beer = 99
repeat
  display %beer
  display $para
  if ! %beer = 1
    display $pl
  end
  display $parb\n
  display %beer
  display $para
  if ! %beer = 1
    display $pl
  end  
  display $parc\n
  display $pard\n
  %beer = %beer - 1
  if %beer > 0
    display %beer
    display $para
    if %beer > 1
      display $pl 
    end
    display $pare\n
  end
  if %beer = 0
    display $parf\n
  end
  display \n
until %beer = 0
</PRE>
<HR>
<H2><A NAME="vicc">VICC</A></H2>
<i>VICC is a Pascal-like language used in a Compilers course 
at Helsinki University of Technology</i>
<PRE>
// 99 Bottles of Beer in VICC = VICC's Intended for Compiler Courses
// (C) 1996 Juha Autero

DEFINE nl(tabify : Int) : Int
  IF tabify != 0 THEN
    WriteString("\n\t");
  ELSE
    WriteString("\n");
  END;
  RETURN 0;
END;

DEFINE beer(b : Int) : Int
  WriteInt(b);
  WriteString(" bottles of beer");
  RETURN 0;
END;

DEFINE Main() : Int
  DEFINE i : Int;
  i := 99;
  WHILE i >= 1 DO
    nl(1);
    beer(i);
    WriteString(" on the wall,");
    nl(1);
    beer(i);    
    WriteString(".");
    nl(1);
    WriteString("Take one down, pass it around");
    nl(1);
    beer(i - 1);
    WriteString(" on the wall.");
    nl(0);
    i := i - 1;
  DONE;
END;
</PRE>
<HR>
<H2><A NAME="ultramacros">UltraMacros</A></H2>
<i>This is a scripting language for AppleWorks word processor on the Apple ][.  Run
this by pressing the Solid-Apple-B key.  
(Code courtesy Scott Alfter (salfter@theonramp.net) )</i>
<PRE>
start
B:&lt;all&gt;&lt;oa-q esc&gt;1&lt;rtn&gt;3&lt;rtn&gt;1&lt;rtn&gt;BottlesOfBeer&lt;rtn x=99 begin print x&gt;
bottles of beer on the wall,&lt;rtn print x&gt; bottles of beer,&lt;rtn&gt;Take one
down, pass it around,&lt;rtn x=x-1 print x&gt; bottles of beer on the wall.&lt;rtn
rtn ifnot x=0 rpt elseoff&gt;!
</PRE>
<HR>
<H2><A NAME="troff">troff</A></H2>
<i>Similar to <A HREF="#nroff">nroff</A>, this is a text-formatting language.</i>
<PRE>
.\"
.\" 99 bottles of beer.
.\" [ntg]roff macro
.\" Jaap Akkerhuis
.\"
.if n .pl 1
.nr b 99 1
.nf
.ds b "of beer
.ds s, " \*b on the wall,
.ds t take one down, pass it around,
.ds s. " \*b on the wall.
.ds B " bottles
.de BB
.if \\nb=1 .rn BB xx
\\nb\\*B\\*(s, \\nb\\*B \\*b,
\\*t
.if \\n-b=1 .ds B " bottle
.if \\nb \\nb\\*B\\*(s.
.BB
..
.BB
no more\*Bs\*(s.
</PRE>
<HR>
<H2><A NAME="saul">SAUL</A></H2>
<i>Home-brew language.  See <a href=http://keaggy.intmed.mcw.edu/saul.html>
http://keaggy.intmed.mcw.edu/saul.html</a> for details</i>
<PRE>
;
; 99 Bottles of Beer in SAUL
;    (http://keaggy.intmed.mcw.edu/saul.html)
;
; RTK, rkneusel@post.its.mcw.edu, 10-Apr-97
;

       fixn(0)
       setn(n,99)
:loop, putn(n)
       disp(` bottles of beer on the wall, `)
       putn(n)
       disp(` bottles of beer.`)
       putc(13)
       disp(`Take one down, pass it around, `)
       subt(n,1,m)
       putn(m)
       comp(m,1)
       brne(:here)
       disp(` bottle of beer on the wall.`)
       jump(:there) 
:here, disp(` bottles of beer on the wall.`)
:there,putc(13)
       putc(13)
       comp(n,2)
       breq(:last)
       subt(n,1,n)
       jump(:loop)
:last, disp(`1 bottle of beer on the wall, 1 bottle of beer.`)
       putc(13)
       disp(`Take one down, pass it around, `)
       disp(`no more bottles of beer on the wall.`)  
       endp
</PRE>
<HR>
<H2><A NAME="transactsql">Transact SQL</A></H2>
<i>See also <a href=#sql>SQL</a>.</i>
<PRE>
/*	Microsoft Transact-SQL version of the beer song
**	Joseph Thoennes, thoennes@paranet.com
*/
set nocount on
create table #beer (bottle tinyint identity)
while (select isnull(max(bottle),0) from #beer) < 99 insert into #beer
default values
select ltrim(str(bottle)) + ' bottle' + case when bottle > 1 then 's' end
+ ' of beer on the wall, '
+ ltrim(str(bottle)) + ' bottle' + case when bottle > 1 then 's' end + '
of beer, take '
+ case when bottle > 1 then 'one' else 'it' end + ' down, pass it around,
'
+ case when bottle - 1 > 0 then ltrim(str(bottle - 1)) else 'no more' end
+ ' bottle' + case when bottle - 1 <> 1 then 's' end + ' of beer on the
wall.'
from #beer order by bottle desc
drop table #beer
</PRE>
<HR>
<H2><A NAME="teco">TECO</A></H2>
<i>TECO is a text-editor/programming-language that looks more like
line noise than something people are supposed to understand.  The ^A
is a literal Ctrl-A keystroke, and the ^[ is a literal ESC key.</i>
<PRE>
! -- TECO version of 99 Bottles of beer
  -- Hacked by Akira KIDA, &lt;SDI00379@niftyserve.or.jp&gt; !

hk@i#
qp-1"> qp:= ^A bottles^A '
qp-1"= qp:= ^A bottle^A '
qp"= ^ANo more bottles^A '
^A of beer^A
#hxbhk

@i#
qnup
qn<
   mb ^A on the wall, ^A
   mb ^A.
Take one down, pass it around.
^A
   qp-1up
   mb ^A on the wall.
^A
>#
hxmhk

99un
mmex^[^[
</PRE>
<HR>
<H2><A NAME="yacc">YACC</A></H2>
<i>I had my own notions of how this should work, but James was nice
enough to send this one, so here it is. YACC stands for "Yet Another
Compiler Compiler" and it's purpose is to create compiler grammars
and parse them.  Conventionally, YACC should read ordered text and
do something intelligent with it.  In this case, the code should be
driven by text that represents the beer to be consumed.  
<a href=beer_a_c.html#c>C</a> source code is generated by YACC to do the dirty
work.  This is a language that makes languages.  Consequently, it
is in a world unto itself.</i>

<PRE>
%{
/*
** 99 bottles of beer yacc-like
** by: James Copher jec@netcom.com
*/

#include<stdio.h>
static int bottles=99;
%}

%union{ int bottle; }
%token <bottle> BOTTLES NOMORE
%type <bottle> beer nomore
%start round

%%
round    : beer nomore {
            YYACCEPT;
        };
beer    : BOTTLES {
            printf("%d bottles of beer on the wall\n%d bottles of beer\n"
                "Take one down,\npass it around\n",$1,$1);
        }
        | beer BOTTLES {
            printf("%d bottle%s of beer on the wall\n\n"
                "%d bottle%s of beer on the wall\n%d bottle%s of beer\n"
                "Take one down\npass it around\n",
                $2,$2!=1?"s":"",$2,$2!=1?"s":"",$2,$2!=1?"s":"");
        };
nomore	: NOMORE {
            printf("No more bottles of beer on the wall\n");
        };
%%

yyerror(){}
yylex(){ if(bottles){ yylval.bottle=bottles--; return BOTTLES; } return NOMORE; }
main(){ yyparse(); }
</PRE>
<HR>
<H2><A NAME="4test">4Test</A></H2>
<i>4Test is the language used for GUI testing
by Segue Software's QA Partner.</i>
<PRE>
// 4Test Version of 99 Bottles of beer
//
// Eric DeCosta 
//
testcase bottles()
	INTEGER bottles
	for (bottles = 99; bottles >0;)
		print("{bottles}  bottle(s) of beer on the wall,")
		print("{bottles}  bottle(s) of beer.")
		print("Take one down, pass it around,")
		print("{--bottles} bottle(s) of beer on the wall.")
</PRE>
<HR>
<H2><A NAME="spss">SPSS</A></H2>
<i>SPSS is a statistical programming language.</i>
<PRE>
****************************************************************************
* File:			beer.sps
* Source Code:	SPSS 5.0
* System/OS:		HP/UNIX
* Written By:		Keith Chidsey (keithc@gsbc.com)
*
* Write out lyrics to "99 Bottles of Beer on the Wall" to file <beersong>.
****************************************************************************

FILE HANDLE    	DUMMY/NAME'BEER.SPS'/LRECL=80
FILE HANDLE    	BEERSONG/NAME'BEERSONG'/LRECL=80

DATA LIST 		FILE=DUMMY FIXED RECORDS=1/
				DUMMY(A1)

STRING			LYRIC1,LYRIC2,SPACE(A80)

LOOP			BOTTLES=99 TO 1 BY -1
COMPUTE		LYRIC1=CONCAT(STRING(BOTTLES,F2),
 				' BOTTLES OF BEER ON THE WALL, ',
				STRING(BOTTLES,F2),
				' BOTTLES OF BEER.')
COMPUTE		LYRIC2=CONCAT('TAKE ONE DOWN, PASS IT AROUND, ',
				STRING(BOTTLES-1,F2),
				' BOTTLES OF BEER ON THE WALL.')
WRITE			OUTFILE=BEERSONG RECORDS=3/
				LYRIC1/LYRIC2/SPACE
END LOOP
EXECUTE

FINISH
</PRE>
<HR>
<H2><A NAME="virc">VScript</A></H2>
<i>VScript version, a script language for Virc'96/97, an IRC
client for Windows 95.</i>
<PRE>
// BEER.VSC - Beer 1.0
// Developed under Visual IRC '96 1.00rc5a

Name Beer 1.0

// Aliases

Alias BEER
  @l $Bottle=99
  while ( $Bottle > 1 )
    TextOut clBlue $Bottle Bottles of beer on the wall,
    TextOut clBlue   $Bottle Bottles of beer.
    $Bottle--
    TextOut clBlue Take one down, pass it around,
    TextOut clBlue    $Bottle Bottles of beer on the wall.
    TextOut clBlue
  endwhile

  TextOut clRed 1 Bottle of Beer on the wall,
  TextOut clRed    1 Bottle of Beer.
  TextOut clRed Take One Down, Pass it around,
  TextOut clRed    No more bottles of Beer on the wall.

  -@ $Bottle
EndAlias
</PRE>
<HR>
<H2><A NAME="supertalk">SuperTalk</A2></H2>
<i></i>
<PRE>
-- Here's 99 Bottles of Beer on the Wall in the
-- SuperTalk language. Card field "NumberOfBottles"
-- has a 99 in it but the user can change this
-- before clicking on the start button.
-- 
-- Christine Keuper 
-- 


on mouseUp
  
  repeat until cd fld "NumberOfBottles" <= 1

    put cd fld "NumberOfBottles" && "bottles of beer on the wall," &&
      cd fld "NumberOfBottles" &&  "bottles of beer" & RETURN & 
      "You take one down and pass it around," && 
      cd fld "NumberOfBottles" - 1 && "bottles of beer on the wall." & 
      RETURN  & RETURN after cd fld "lyrics"

    subtract 1 from cd fld "NumberOfBottles"

  end repeat
  
  put cd fld "NumberOfBottles" && "bottle of beer on the wall," && 
    cd fld "NumberOfBottles" && "bottle of beer" & RETURN & 
    "You take one down and pass it around," && 
    cd fld "NumberOfBottles" - 1 && "bottles of beer on the wall." & 
    RETURN  & RETURN after cd fld "lyrics"

  subtract 1 from cd fld "NumberOfBottles"
  
end mouseUp
</PRE>
<HR>
<H2><A NAME="saol">SAOL</A2></H2>
<i>SAOL is the music-synthesis language which is part of the 
MPEG-4 standard.  There's a homepage for SAOL at
<A href=http://sound.media.mit.edu>http://sound.media.mit.edu</a></i>
<PRE>
Orchestra (beer.saol) :

global {
  srate 1000; // sip rate
  krate 100;  // beer rate
}

instr beer() {
  ksig drink;

  drink = kline(99,1,1);

  if (drink == 0) {
    kdump("No bottles of beer on the wall.");
    kdump("Everybody's drunk!");
    turnoff;
    }

  else {
    if (drink == 1) {
      kdump(drink," bottle of beer on the wall.");
      kdump(drink," bottle of beer.");
    } 
    else { 
      kdump(drink," bottles of beer on the wall.");
      kdump(drink," bottles of beer.");
    }
    kdump("Take one down, pass it around,");

    if (drink-1 == 1) {
      kdump(drink-1," bottle of beer on the wall.");
    } 
    else { 
      kdump(drink-1," bottles of beer on the wall.");
    }
    kdump();
  }
}

------------

Score (beer.sasl) :

0 beer 1
</PRE>
<HR>
<H2><A NAME="visualfoxpro">Visual Foxpro</A></H2>
<PRE>
********************************************
* TAKE1DN.PRG  (For Visual Foxpro)         *
* 99 Bottles: A simulation                 *
* Richard Katz                             *
* richkatz@earthlink.net                   *
********************************************

wall=createobject("dispcontainer")
wall.name="wall"
clear

**************************************
* First put the beer on the wall.
for i=1 to 99
    oname="b"+ltri(str(i))
    wall.addobject(oname,"bottle")
endfor

**************************************
* So we can get what's in the bottles...
obcont=wall.objects(1).content

***************************************
* And away we go.
do while wall.controlcount>0 
   ? wall.dispself(), "of",obcont,"on the",lower(wall.name)+","
   ? wall.dispself(), "of", obcont    
   wall.removeobject(wall.objects(wall.controlcount).name)
   ? wall.dispself(), "of", obcont
   if wall.controlcount>0
      ?? ",  Oh..."
   endif      
enddo   
define class dispcontainer as container
proc dispself

return ltri(str(this.controlcount))+" "+this.dispobj()
proc dispobj    
   if this.controlcount>0
      obout=lower(this.objects(1).class)
   else
      obout="nothing"
   endif
   if this.controlcount<>1
      obout=obout+"s"
   endif
return obout   
enddefine

define class bottle as custom
  content="beer"
  proc destroy
    ? "take one down, pass it around."
  endproc
enddefine
</PRE>
<HR>
<H2><A NAME="zzt">ZZT</A2></H2>
<i>An ansi gaming language, apparently with no looping constructs.  I trimmed
the middle section for simplicity.</i>
<PRE>
- -- - --- -- ---- ---- --------------------------------.
 keebler@wco.com - http://wco.com/~keebler/             |
 keebler/keebobler on IRC                               :
@Beerman
#cycle 1
#send chug
#end
:sing
bottles of beer!  Take one down, pass it around
#sleep 1
#zap chug
#send chug
#end
:chug
99 bottles of beer on the wall
99
#send sing
#end
:chug
98 bottles of beer on the wall
98
#send sing
#end
:chug
2 bottles of beer on the wall
2
#send sing
#end
:chug
1 bottles of beer on the wall
1
#send sing
#end
:chug
No more bottles of beer on the wall,
no more bottles of beer.
Go to the store, buy some more,
99 bottles of beer on the wall!
#die
#en</PRE>
<HR>
<P>
<P>
<CENTER>
<FONT SIZE=2><I>Compilation Copyright 1995, 1996, 1997 Tim Robinson.  All Rights Reserved
<BR>Permission to copy enthusiastically granted to instructors of computer science
<BR>(who would like to demonstrate the styles of different programming languages
<BR>to their students) provided that the names of the contributors are retained.</I></FONT SIZE>
</CENTER>
<BR><A HREF=../index.html>Back to the Funhouse</A>
<P>
<P>
<P>
&nbsp;

<HTML>
<HEAD>
<TITLE>UnixWorld Online: Tutorial: Article No. 009: Part 1</TITLE>
<META NAME="description" CONTENT="Unix Vi and Ex tutorial series, Part 1">
<META NAME="keywords" CONTENT="vi, ex, editor, unix, tutorial">
</HEAD>

<BODY
BGCOLOR="#cccc99"
TEXT="#000099"
LINK="#3333cc"
VLINK="#009966"
ALINK="#cc33ff"
BACKGROUND="/uworld/graphics/bkg2.gif">

<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 1</H1>

<A HREF="/uworld/copyrights/bsd-daemon.txt">



<H2>Part 1: Vi Editor Fundamentals</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter Alan
Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question
submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A 
HREF="009.html">table of contents</A>.]</P>

<UL>

<LI><A HREF="#section1">Why Vi?</A>

<UL>

<LI><A HREF="#heartwarming">A Heartwarming Edit</A>

<LI><A HREF="#plan">The Plan Of This Ongoing Tutorial</A>

</UL>

<LI><A HREF="#section2">The Editor's Basic Concepts</A>

<LI><A HREF="#section3">Search Patterns</A>

<UL>

<LI><A HREF="#search-from-here">Searching From Where You Are Now</A>

<LI><A HREF="#find-them-all">The Find-Them-All Search</A>

<LI><A HREF="#search-simple">Simple Search Patterns</A>

<LI><A HREF="#search-metachars">Metacharacters</A>

<LI><A HREF="#table">Table Of Search Pattern Metacharacters</A>

<LI><A HREF="#search-charclass">Character Classes</A>.

</UL>

<LI><A HREF="#next">What's Coming For The Next Installment</A>.

</UL>


<H3><A NAME="section1">Why Vi?</A></H3>

<P><A NAME="heartwarming"><STRONG>A HEARTWARMING
EDIT</STRONG></A>. Pity poor Hal, a corporate maintenance
programmer.  A large module of badly- broken, poorly-patched
legacy code -- the spaghetti variety -- finally broke down
completely yesterday, leaving one corporate division running at
half speed.  By dint of some inspired fixes during an all-nighter, 
Hal has the module up and running again this morning...but just
as he's ready to go out for food that isn't from a vending
machine, in walks the corporation's VP of IS, with a big
surprise.</P>



<P>``Nice work on that crash fix, Hal; but right now I need some
formatted technical data about it, in a hurry.  The Board of Directors'
Information Systems Committee has called a rush meeting this morning
to convince themselves they're on top of the problem.  I'll be in
the hotseat, and I need technical data I can put up on the video
projector to keep them occupied.</P>

<P>``They'll want me to discuss the logfile of errors that led up
to the crash . . . yes, I know that's in <CODE>/oltp/err/m7</CODE>,
but appending puts the latest report lines at the bottom of the file.
Those suits aren't interested in what they think is ancient history,
and they wouldn't be caught reading anything but a commuter train
timetable from the bottom up,
so you'll have to make a copy with the order of the lines reversed:
what was the last line becomes the first line, what was the second
to the last line is now line number two, and so on.</P>

<P>``And let's take a look at that logfile.</P>

<PRE>
374a12  44872  130295/074457  nonabort
5982d34  971  130295/221938  nonabort
853f7  2184  140295/102309  abort
 ...
</PRE>

<P>Hmmm.  Explaining the second column to them would be
advertising the fact that we knew this failure was just waiting
for a chance to happen.  So while you're at it, go through and
erase all but the first and last digits of each number in column
two.</P>

<P>``Oh, and when they get tired of that they'll want to
scrutinize the Lint report.  Last month I told them that our Lint
substitute was the greatest thing since Marilyn Monroe, so now
they'll want me to tell them why the messages it still generates
on this module aren't real hazards.  Just run Lint over the
revamped module; then combine the Lint output with a copy of the
source file by taking each message line like:</P>

<PRE>
Line 257: obsolete operator +=
</PRE>

<P>and putting the significant part at the end of the source line it
refers to.  And put a separator, like <CODE>XXX</CODE>, between
the source line and the message so I can page through quickly.
Nothing like a hefty dose of source code they can't begin to fathom
to make the meeting break up early.</P>

<P>``And get right on this.  The meeting starts in 35 minutes.''</P>



<P>Our VP walks away inwardly smiling, thinking he's getting out
of detailed explanations and putting all the blame on an
underling, just by demanding more editing than anyone could do in
the time available.  ``I'll tell the Information Systems
Committee that I made it perfectly clear to the programmer that
we needed this at 9:30, but when I asked him for it a minute ago
he said it wasn't finished and he wasn't sure when it would be.
Then I'll remark that those programmers just can't understand
that keeping management informed is every bit as important as
writing code!''</P>

<P>But Hal has a secret weapon against this squeeze play: an expert
knowledge of the Vi editor.</P>

<P>Reversing the order of the lines in a file is a piece of cake
with this editor.  The eight keystrokes in:</P>

<PRE>
<STRONG>:g/^/m0<EM>(ret)</EM></STRONG>
</PRE>

<P>
will do it.  Taking the digits out of the middle of the second column
throughout the file also requires just one command line:</P>

<PRE>
<STRONG>:%s/^\([^ ]*  [0-9]\)[0-9]*\([0-9]  \)/\1\2<EM>(ret)</EM></STRONG>
</PRE>

<P>And integrating the Lint messages into a copy of the source
code?  Even that can be automated with the Vi editor.  The editor
command:</P>

<PRE>
<STRONG>:%s/Line \([0-9][0-9]*\): \(.*\)/\1s;$; XXX \2<EM>(ret)</EM></STRONG>
</PRE>

<P>will turn that file of Lint messages into an editor script,
and running that script on a copy of the source file will mark it
up as requested.</P>

<P>Rather than being portrayed as a bungler, Hal can have it all
ready in a couple of minutes, just by typing a few lines.  He'll
even have time to guard against vice-presidential prevarication,
by disappearing into the coffee shop across the street and
reappearing just as the meeting is getting started, to tell the
VP (and everyone else in earshot), ``Those files you wanted are
in slash-temp-slash-hal''.</P>

<P><A NAME="plan"><STRONG>THE PLAN OF THIS ONGOING
TUTORIAL</STRONG></A>. I'm writing here for editor users who have
some fluency in Vi/Ex at the surface level.  That is, you know
how to do the ordinary things that are belabored in all the
``Introducing Vi'' books on the market, but rarely venture beyond
that level.</P>

<P>This tutorial series will explore a lot of other capabilities
that hardly anyone knows are in Vi/Ex.  That includes quite a few
tricks that may be built on editor functions we all use every day,
but which nonetheless are not obvious -- for instance, telling the
global command to mark every line it encounters.  I'll also be
clarifying the real nature of the many misunderstood aspects of
this editor.</P>

<P>To do all this, I'll be explaining things in more depth than
you might think warranted at first.  I'll also throw in exercises
wherever they seem helpful.  And to save you readers from gross
information overload, I'll write this tutorial in a large number
of fairly small modules, to be put up on our website at a calm,
reasonable pace.</P>


<H3><A NAME="section2">The Editor's Basic Concepts</A></H3>

<P>To get a real grasp on this editor's power, you need to know
the basic ideas embodied in it, and a few fundamental building
blocks that are used throughout its many functions.</P>

<P>One cause of editor misuse is that most users, even
experienced ones, don't really know what the editor is good at
and what it's not capable of.  Here's a quick rundown on its
capabilities.</P>

<P>First, it's strictly a general-purpose editor.  It doesn't
format the text; it doesn't have the handholding of a word
processor; it doesn't have built-in special facilities for
editing binaries, graphics, tables, outlines, or any programming
language except Lisp.</P>

<P>It's two editors in one.  Visual mode is a better full-screen
editor than most, and it runs faster than those rivals that have
a larger bag of screen-editing commands.  Line editing mode
dwarfs the ``global search and replace'' facilities found in word
processors and simple screen editors; its only rivals are 
non-visual editors like Sed where you must know in advance exactly
what you want to do.  But in the Vi/Ex editor, the two sides are
very closely linked, giving the editor a combination punch that
no other editor I've tried can rival.</P>

<P>Finally, this editor is at its best when used by people who
have taken the trouble to learn it thoroughly.  It's too capable
to be learned well in an hour or two, and too idiosyncratic to be
mastered in a week, and yet the power really is in it, for the
few who care to delve into it.  A large part of that power
requires custom-programming the editor: that's not easy or
straightforward, but what can be done by the skillful user goes
beyond the direct programmability of any editor except (possibly)
Emacs.</P>



<H3><A NAME="section3">Search Patterns</A></H3>

<P>In quite a few functions of this editor, you can use 
string-pattern searching to say where something is to be done or
how far some effect is to extend.  These search patterns are a
good example of an editor function that is very much in the Unix
style, but not exactly the same in detail as search patterns in
any other Unix utility.</P>

<P>Search patterns function in both line editing and visual
editing modes, and the work the same way in both, with just a few
exceptions.  But how you tell the editor you're typing in a
search pattern will vary with the circumstances.</P>

<P><A NAME="search-from-here"><STRONG>SEARCHING FROM WHERE YOU
ARE NOW</STRONG></A>. The more common use for search patterns is
to go to some new place in the file, or make some editing change
that will extend from your present position to the place the
pattern search finds.  (In line editing mode it's also possible
to have an action take place from one pattern's location to where
another pattern is found, but both searches still start from your
present location.)</P>

<P>If you want to search forward in the file from your present
location (toward the end of the file), precede the search pattern
with a slash (<CODE><STRONG>/</STRONG></CODE>) character, and
type another to end the pattern.  So if you want to move forward
to the next instance of the string ``j++'' in your file,
typing:</P>

<PRE>
<STRONG>/j++/<EM>(ret)</EM></STRONG>
</PRE>

<P>will do it.  And so will:</P>

<PRE>
<STRONG>/j++<EM>(ret)</EM></STRONG>
</PRE>

<P>When there is nothing between the pattern and the RETURN key,
the RETURN itself will indicate the end of the search pattern, so
the second slash is not necessary.  And if you are in visual
mode, the ESCAPE key works as well as RETURN does for ending
search input, so</P>

<PRE>
<STRONG>/j++<EM>(esc)</EM></STRONG>
</PRE>

<P>is yet another way to make the same request from visual mode.</P>

<P><A NAME="target04">To search backward (toward the start of the
file)</A>, begin and end with a question mark instead of a slash.
The same rules of abbreviation apply to backward searches, so</P>

<PRE><STRONG>
?j++?<EM>(ret)</EM>
?j++<EM>(ret)</EM>
?j++<EM>(esc)</EM>
</STRONG></PRE>

<P>are all ways to head backward in the file to the same pattern.</P>

<P>Either way, you've expressed both your request for a pattern
search and the direction the search is to take in just one
keystroke.  But don't assume that if you search backward, any
matching pattern the editor finds will be above your present
position in the file, and vice versa if you search forward.  The
editor looks there first, certainly, but if it gets to the top or
bottom line of the file and hasn't found a match yet, it wraps
around to the other end of the file and continues the search in
the same direction.  That is, if you used a question mark to
order a backward search and the editor searches all the way
through the top line of the file without finding a match, it will
go on to search the bottom line next, then the second-to-the-bottom 
line, and so on until (if necessary) it gets back to the point
where the search started.  Or if you were searching forward and
the editor found no match up through the very last line of the
file, it would next search the first line, then the second line,
etcetera.</P>

<P>If you don't want searches to go past either end of the file,
you'll need to type in a line mode command:</P>

<PRE>
<STRONG>:set nowrapscan<EM>(ret)</EM></STRONG>
</PRE>

<P>This will disable the wraparound searching during the present
session in the editor.  If you want to restore the wraparound
searching mechanism before you leave the editor, typing</P>

<PRE>
<STRONG>:set wrapscan<EM>(ret)</EM></STRONG>
</PRE>

<P>will do it, and you can turn this on and off as often as you like.</P>

<P><A NAME="find-them-all"><STRONG>THE FIND-THEM-ALL
SEARCH</STRONG></A>. Up to now, I've been considering searches
that find just one instance of the pattern; the one closest to
your current location in the file, in the direction you chose for
the search.  But there is another style of search, used primarily
by certain line editing mode commands, such as
<CODE>global</CODE> and <CODE>substitute</CODE>. This search
finds every line in the file (or in a selected part of the file)
that contains the pattern and operates on them all.</P>

<P>Don't get confused when using the <CODE>global</CODE> and
<CODE>substitute</CODE> commands.  You'll often use both styles of
search pattern in one command line.  But the find-one-instance
pattern or patterns will go before the command name or abbreviation,
while the find-them-all pattern will come just behind it.
For example, in the command:</P>

<PRE>
<STRONG>:?Chapter 10?,/The End/substitute/cat/dog/g<EM>(ret)</EM></STRONG>
</PRE>

<P>the first two patterns refer to the preceding line closest to
the current line that contains the string ``Chapter 10'' and the
closest following line containing the string ``The End''. Note
that each address finds only one line.  Combined with the
intervening comma, they indicate that the <CODE>substitute</CODE>
command is to operate on those two lines and all the lines in
between them.  But the patterns immediately after the
<CODE>substitute</CODE> command itself tell the command to find
every instance of the string ``cat'' withing that range of lines
and replace it with the string ``dog''.</P>

<P><A NAME="target02">Aside from the difference in meaning</A>, the
two styles also have different standards for the delimiters that
mark pattern beginnings and (sometimes) endings.  With a find-
them-all pattern, there's no need to indicate whether to search
forward or backward.  Thus, you aren't limited to slash and
question mark as your pattern delimiters.  Almost any punctuation
mark will do, because the editor takes note of the first
punctuation mark to appear after the command name, and regards it
as the delimiter in that instance.  So</P>

<PRE><STRONG>
:?Chapter 10?,/The End/substitute;cat;dog;g<EM>(ret)</EM>
:?Chapter 10?,/The End/substitute+cat+dog+g<EM>(ret)</EM>
:?Chapter 10?,/The End/substitute{cat{dog{g<EM>(ret)</EM>
</STRONG></PRE>

<P>are all equivalent to the substitution command above.  (It is
a good idea to avoid using punctuation characters that might have
a meaning in the command, such as an exclamation point, which
often appears as a switch at the end of a command name.)</P>

<P><A NAME="target03">The benefit of this liberty</A> comes when
the slash mark will appear as itself in the search pattern.  For
example, suppose our substitution command above was to find each
pair of consecutive slash marks in the text, and separate them
with a hyphen -- that is, change <CODE>//</CODE> to <CODE>/-/</CODE>. 
Obviously,</P>

<PRE>
<STRONG>:?Chapter 10?,/The End/substitute/////-//g<EM>(ret)</EM></STRONG>
</PRE>

<P>won't work; the command will only regard the first three slashes as
delimiters, and everything after that as extraneous characters at the
end of the command.  This can be solved by backslashing:</P>

<PRE>
<STRONG>:?Chapter 10?,/The End/substitute/\/\//\/-\//g<EM>(ret)</EM></STRONG>
</PRE>

<P>but this is even harder to type correctly than the first attempt was.
But with another punctuation mark as the separator</P>

<PRE>
<STRONG>:?Chapter 10?,/The End/substitute;//;/-/;g<EM>(ret)</EM></STRONG>
</PRE>

<P>the typing is easy and the final command is readable.</P>

<P><A NAME="search-simple"><STRONG>SIMPLE SEARCH
PATTERNS</STRONG></A>. The simplest search pattern is just a
string of characters you want the editor to find, exactly as
you've typed them in.  For instance: ``the cat''. But, already
there are several caveats:</P>

<OL>

<LI>This search finds a string of characters, which may or may not
be words by themselves.  That is, it may find its target in the middle
of the phrase ``we fed <EM>the cat</EM> boiled chicken'', or in
the middle of ``we sailed a li<EM>the cat</EM>amaran down the coast''.
It's all a matter of which it encounters first.

<LI>Whether the search calls ``The Cat'' a match or not depends
on how you've set an editor variable named
<VAR>ignorecase</VAR>. If you've left that variable in its
default setting, the capitalized version will not match.
If you want a capital letter to match its lower-case equivalent,
and vice versa, type in the line mode command.

<PRE>
<STRONG>:set ignorecase<EM>(ret)</EM></STRONG>
</PRE>

<P>To resume letting caps match only caps and vice versa, type</P>

<PRE>
<STRONG>:set noignorecase<EM>(ret)</EM></STRONG>
</PRE>

<LI>The search absolutely will not find a match where ``the''
occurs at the end of one line and ``cat'' is at the start of the
next line:

<PRE>
and with Michael's careful help, we prodded the
cat back into its cage.  Next afternoon several
</PRE>

<P>It makes no difference whether there is or isn't a space
character between one of the words and the linebreak.  Finding a
pattern that may break across a line ending is a practically
impossible task with this line-oriented editor.

<LI>Where the search starts depends on which editor mode you're using.
A search in visual mode starts with the character next to the cursor.
In line mode, the search starts with the line adjacent to the current
line.

</OL>

<P><A NAME="search-metachars"><STRONG>METACHARACTERS</STRONG></A>. 
Then there are search metacharacters or ``wild cards'':
characters that represent something other than themselves in the
search.  As an example, the metacharacters <CODE>.</CODE> and
<CODE>*</CODE> in</P>

<PRE>
<STRONG>/Then .ed paid me $50*!/<EM>(ret)</EM></STRONG>
</PRE>

<P>could cause the pattern to match any of:</P>

<PRE>
Then Ted paid me $5!
Then Red paid me $5000!
Then Ned paid me $50!
</PRE>

<P>or a myriad of other strings.  Metacharacters are what give
search patterns their real power, but they need to be well
understood.</P>

<P>To understand these, you must know the varied uses of the
backslash (<CODE>\</CODE>) metacharacter in turning the ``wild
card'' value of metacharacters on and off.</P>

<P>In many cases, the meta value of the metacharacter is on
whenever the character appears in a search pattern unless it is
preceded by a backslash; when the backslash is ahead of it the
meta value is turned off and the character simply represents
itself.  As an example, the backslash is a metacharacter by
itself, even if it precedes a character that never has a meta
value.  The only way to put an actual backslash in your search
pattern is to precede it with another backslash to remove its
meta value.  That is, to search for the pattern ``a\b'', type</P>

<PRE>
<STRONG>/a\\b/<EM>(ret)</EM></STRONG>
</PRE>

<P>as your search pattern.  If you type</P>

<PRE>
<STRONG>/a\b/<EM>(ret)</EM></STRONG>
</PRE>

<P>the backslash will be interpreted as a metacharacter without
any effect (since the letter b is never a metacharacter) and your
search pattern will find the string ``ab''.</P>

<P>Less-often-used metacharacters are used in exactly the
opposite way.  This sort of character represents only itself when
it appears by itself.  You must use a preceding backslash to turn
the meta value on.  For example, in</P>

<PRE>
<STRONG>/\&lt;cat/</STRONG>
</PRE>

<P>the left angle bracket (<CODE>&lt;</CODE>) is a metacharacter; in</P>

<PRE>
<STRONG>/&lt;cat/</STRONG>
</PRE>

<P>it only represents itself.  These special metacharacters are
pointed out in the list below.</P>

<P>Finally there is a third class, the most difficult to keep
track of.  Usually these metacharacters have their meta values on
in search patterns, and must be backslashed to make them
represent just themselves: like our first example, the backslash
character itself.  But if you've changed the default value of an
editor variable named <VAR>magic</VAR> to turn it off, they work
oppositely -- you then must backslash them to turn their meta value
on: like our second example, the left angle bracket.  (Not that
you are are likely to have any reason to turn <VAR>magic</VAR>
off.)  These oddities are also noted in the list below.</P>

<P><A NAME="target05">And don't forget the punctuation
character</A> that starts and ends your search pattern, whether
it is slash or question mark or something else.  Whatever it is,
if it is also to appear as a character in the pattern you are
searching for, you'll have to backslash it there to prevent the
editor thinking it is the end of the pattern.</P>

<P><A NAME="table"><STRONG>TABLE OF SEARCH PATTERN 
METACHARACTERS</STRONG></A></P>

<DL>

<DT><CODE><STRONG>.</STRONG></CODE>

<DD>A period in a search pattern matches any single character,
whether a letter of the alphabet (upper or lower case), a digit,
a punctuation mark, in fact, any ASCII character except the
newline.  So to find ``default value'' when it might be spelled
``default-value'' or ``default/value'' or ``default_value'',
etcetera, use <CODE><STRONG>/default.value/</STRONG></CODE> as
your search pattern.  When the editor variable <VAR>magic</VAR>
is turned off, you must backslash the period to give it its meta
value.

<DT><CODE><STRONG>*</STRONG></CODE>

<DD>An asterisk, plus the character that precedes it, match any
length string (even zero length) of the character that precedes
the asterisk.  So the search string
<CODE><STRONG>/ab*c/</STRONG></CODE> would match ``ac'' or
``abc'' or ``abbc'' or ``abbbc'', and so on.  (To find a string
with at least one ``b'' in it, use
<CODE><STRONG>/abb*c/</STRONG></CODE> as your search string.)
When the asterisk follows another metacharacter, the two match
any length string of characters that the metacharacter matches.
That means that <CODE><STRONG>/a.*b/</STRONG></CODE> will find
``a'' followed by ``b'' with anything (or nothing) between them.
When the editor variable <VAR>magic</VAR> is turned off, you must
backslash the asterisk to give it its meta value.

<DT><CODE><STRONG>^</STRONG></CODE>

<DD>A circumflex as the first character in a search pattern means
that a match will be found only if the matching string occurs at
the start of a line of text.  It doesn't represent any character
at the start of the line, of course, and a circumflex anywhere in
a search pattern except as the first character will have no meta
value.  So <CODE><STRONG>/^cat/</STRONG></CODE> will find
``cat'', but only at the start of a line, while
<CODE><STRONG>/cat^/</STRONG></CODE> will find ``cat^'' anywhere
in a line.

<DT><CODE><STRONG>$</STRONG></CODE>

<DD>A dollar sign as the last character in a search pattern means
the match must occur at the end of a line of text.  Otherwise
it's the same as circumflex, above.

<DT><A NAME="target06"><CODE><STRONG>\&lt;</STRONG></CODE></A>

<DD>At the start of a search pattern, a backslashed left-angle
bracket means the match can only occur at the start of a simple
word; at any other position in a search pattern it is not a
metacharacter.  (In this editor, a ``simple'' word is either a
string of one or more alphanumeric character(s) or a string of
one or more non-alphanumeric, non-whitespace character(s), so
``shouldn't'' contains three simple words.)  Thus
<CODE><STRONG>/\&lt;cat/</STRONG></CODE> will find the last three
characters in ``the cat'' or in ``tom-cat'', but not in
``tomcat''. To remove the meta value from the left angle bracket,
remove the preceding backslash:
<CODE><STRONG>/&lt;cat/</STRONG></CODE> will find ``&lt;cat''
regardless of what precedes it.

<DT><CODE><STRONG>\&gt;</STRONG></CODE>

<DD>At the end of a search pattern, a backslashed right angle
bracket means the match can occur only at the end of a simple
word.  Otherwise the same as the left angle bracket, above.

<DT><CODE><STRONG>~</STRONG></CODE>

<DD>The tilde represents the last string you put into a line by
means of a line mode <CODE>substitute</CODE> command, regardless
of whether you were in line mode then or ran it from visual mode
by preceding it with a colon
(``<CODE><STRONG>:</STRONG></CODE>''). For instance, if your last
line mode substitution command was
<CODE><STRONG>s/dog/cat/</STRONG></CODE> then a
<CODE><STRONG>/the ~/</STRONG></CODE> search pattern will find
``the cat''. But the input string of a <CODE>substitute</CODE>
command can use metacharacters of its own, and if your last use
involved any of those metacharacters then a tilde in your search
pattern will give you either an error message or a match that is
not what you expected.  When the editor variable <VAR>magic</VAR>
is turned off, you must backslash the tilde to give it its meta
value.

</DL>

<P><A NAME="search-charclass"><STRONG>CHARACTER
CLASSES</STRONG></A>. There is one metastring form (a
``multicharacter metacharacter'') used in search patterns.  When
several characters are enclosed within a set of brackets
(<CODE><STRONG>[]</STRONG></CODE>), the group matches any one
of the characters inside the brackets.  That is,
<CODE><STRONG>/part [123]/</STRONG></CODE> will match ``part 1'',
``part 2'' or ``part 3'', whichever the search comes to first.
One frequent use for this feature is in finding a string that may
or may not be capitalized, when the editor variable
<VAR>ignorecase</VAR> is turned off (as it is by default). Typing
<CODE><STRONG>/[Cc]at/</STRONG></CODE> will find either ``Cat''
or ``cat'', and <CODE><STRONG>/[Cc][Aa][Tt]/</STRONG></CODE> will
find those or ``CAT''. (In case there was a slip of the shift key
when ``CAT'' was typed in, the last pattern will even find
``CaT'', ``CAt'', etcetera.)</P>

<P>There's more power (and some complication) in another feature
of this metastring: there can be metacharacters inside it.
Inside the brackets, a circumflex as the first character reverses
the meaning.  Now the metastring matches any one character that
is NOT within the brackets.  A <CODE><STRONG>/^[^ ]/</STRONG></CODE>
search pattern finds a line that does not begin with a space character.
(You're so right if you think that the different meta values of the
circumflex inside and outside the character class brackets is not
one of the editor's best points.)  A circumflex that is not the
first character inside the brackets represents just an actual
circumflex.</P>

<P>A hyphen can be a metacharacter within the brackets, too.
When it's between two characters, and the first of the two other
characters has a lower ASCII value than the second, it's as if
you'd typed in all of the characters in the <A
HREF="/uworld/glossary.html#ascii-collating-sequence">ASCII
collating sequence</A> from the first to the second one,
inclusive.  So <CODE><STRONG>/[0-9]%/</STRONG></CODE> will find
any numeral followed by the percent sign (<CODE>%</CODE>), just
as <CODE><STRONG>/[0123456789]%/</STRONG></CODE> would.  A
<CODE><STRONG>/[a-z]/</STRONG></CODE> search pattern will match
any lower-case letter, and <CODE><STRONG>/[a-zA-Z]/</STRONG></CODE> 
matches any letter, capital or lower case.  These two internal
metacharacters can be combined: <CODE><STRONG>/[^A-Z]/</STRONG></CODE> 
will find any character except a capital letter.  A hyphen that
is either the first or the last character inside the brackets has
no meta value.  When a character-hyphen-character string has a
first character with a higher ASCII value than the last
character, the hyphen and the two characters that surround it are
all ignored by the pattern search, so 
<CODE><STRONG>/[ABz-a]/</STRONG></CODE> is the same as
<CODE><STRONG>/[AB]/</STRONG></CODE>.</P>

<P>Backslashing character classes is complex.  Within the
brackets you must backslash a right bracket that's part of the
class; otherwise the editor will mistake it for the bracket that
closes the class.  Of course you must backslash a backslash that
you want to be part of the class, and you can backslash a
circumflex at the start or a hyphen between two characters if you
want them in the class literally and don't want to move them
elsewhere in the construct.  Elsewhere in a search pattern you
will have to backslash a left bracket that you want to appear as
itself, or else the editor will take it as your attempt to begin
a character class.  Finally, if <VAR>magic</VAR> is turned off,
you'll have to backslash a left bracket when you do want it to
begin a character class.</P>

<H3><A NAME="next">Coming Up Next</A></H3>

<P>In the <A
HREF="009.part2.html">second part</A> of this tutorial, I'll be
following up on all this information about search patterns, by
showing the right ways to combine them with other elements to
generate command addresses.</P>

<HR>
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>



<H1>UnixWorld Online: Tutorial: Article No. 009: Part 2</H1>

<A HREF="/uworld/copyrights/bsd-daemon.txt">



<H2>The Vi/Ex Editor, Part 2: Line-Mode Addresses</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter Alan
Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question
submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>

<UL>

<LI><A HREF="009.part2.html#section1">Line-Mode Addressing</A></LI>
<LI><A HREF="009.part2.html#section2">Addressing a Section of Text</A></LI>
<LI><A HREF="009.part2.html#section3">Now You Try It</A></LI>
<LI><A HREF="009.part2.html#next">Coming Up Next</A></LI>

</UL>

<P>[<EM>Editor's note</EM>: We'll surround text to be typed with
actual double quotes, like: enter: "vi file1". Of course, don't
type the quotes unless so instructed.  We'll use ``balanced
quotes'', constructed using pairs of backward and forward quotes,
for all other purposes.]</P>

<P>Whenever you want to give an editor command that will operate on
text that's already in the file you're editing--to delete some text,
change lower-case letters to capitals, write to a file, etcetera--the
editor needs to know what part of the file to go to work on.
A few commands have their addresses built in, and most line-mode
commands have default addresses that the editor will use if you
don't give an address, but that still leaves a lot of occasions
where you need to know how to give the editor an address and
what address to give.</P>

<P>Many line-mode commands are almost identical to corresponding
commands in visual mode; many more do similar things in different
ways.  Most of the benefit of these duplicative command sets comes
from the totally-different addressing styles of line and visual
modes.  The differing address concepts mean that an edit
that would be difficult or impossible to do with one mode's
available addresses can be a piece of cake with an address form
found in the other mode.</P>

<P>Since I mention ``line mode'' so often, you may wonder whether
there really is a separate mode for line editing.  There surely
is--instead of filling your screen with text from the file you're
editing, this mode gives you a colon (<CODE>:</CODE>) prompt for
your line mode commands, and prints only an occasional line from
the file on your screen.  The feel of this mode is very much like
giving UNIX commands from your shell prompt.  Few people work in
line mode these days, largely because you can give most line-mode
commands from visual mode, but you can't give any visual-mode
commands while you are in line mode.  Or perhaps they just prefer
the comfortable WYSIWYG feeling of seeing the text on screen,
with changes appearing as they are made.</P>

<P>But there are times when you will need to work temporarily in
line mode.  To get to line mode when you first launch the editor,
invoke it by typing "ex" instead of "vi". To go to line mode
when you are already in the editor's visual mode, enter "Q". To
get back to visual mode, type "vi" followed by a carriage return.</P>

<P>Wondering why I didn't put a colon in front of that command to
return to visual mode, which is obviously a line-mode command?
Because you don't need to type that colon when you're giving a
command from within line mode.  It may even be harmful; the rule
is that if you type a colon at the start of a command from within
line mode, there must be nothing between the colon and the
command name or abbreviation.  Not an address, not even a space,
nothing at all.</P>

<P>So from this point on, I will display line-mode commands
without an initial colon, because you now know enough to type
that colon only if you're working in visual mode.  And I'll leave
off the tag at the end of a line-mode command that reminds you to
finish with a carriage return because you now realize that any
line-mode command, given from either line or visual mode, has to
end with a carriage return.</P>

<P>Some of you may ask why I show line-mode command lines in 
long-winded form, with spelled-out command names and lots of
whitespace instead of using abbreviations.  For instance, the two
command lines:</P>

<PRE><STRONG>
global /^/ move 0
g/^/m0
</STRONG></PRE>

<P>are identical in their effect, and the second is surely
faster to type, so why do I show the first form?  Because the
long version is much easier to follow when I'm demonstrating
a new concept, and almost everything here will be new to at least
some of you.  And it's a good idea to get to know the long forms,
because you'll soon be learning to write editor scripts, and
those scripts would be as cryptic as APL to future maintenance
programmers if you wrote them in terse style.  When I go over
the roster of line-mode commands, I'll tell you both the long
name and one or two short names for each.</P>


<H3><A NAME="section1">Line-Mode Addressing</A></H3>

<P><STRONG>A SINGLE ADDRESS</STRONG> is often all you need with a
line-mode command.  One address refers to just one line, which
tells a command like <CODE>delete</CODE> or
<CODE>substitute</CODE> to operate on that one line only.  A
command like <CODE>insert</CODE> or <CODE>read</CODE>, which puts
something immediately before or after a particular line, has no
use for more than one address.</P>


<P>A search pattern, as discussed in the <A
HREF="009.part1.html#search">first installment of this
tutorial</A>, is always an acceptable line-mode address.  You put
the address at the start of the command line, before the command
name (but after the initial colon if you are giving the command
from visual mode), so:</P>


<PRE><STRONG>
?the [cC]at? delete
</STRONG></PRE>

<P>will erase the last previous line that contains the string
``the cat'' or ``the Cat'', while:</P>

<PRE><STRONG>
/^GLOSSARY$/ read gloss.book
</STRONG></PRE>

<P>puts the contents of the file ``gloss.book'' right after
the next line in the file you're editing that contains only
the word ``GLOSSARY''.</P>

<P>There are two shorthand forms for reusing search patterns as
addresses.  Typing "??" or "//" tells the editor to use the
last search pattern you used previously, and your choice of
"??" or "//" will set the direction of the search, overriding
the direction you chose the previous time you used that search
pattern.  That is, if you type:</P>

<PRE><STRONG>
?the cat? yank
// delete
?? print
</STRONG></PRE>

<P>the second command will search forward, to remove the last
previous line containing the string ``the cat'', even though
your original use of that pattern was in a backward search.
The third command will search backward to find the line to print,
which (by coincidence) is the direction of the original search.</P>

<P>But the search pattern that those preceding abbreviations
reuse may not be a pattern you used to search for a line.
If you ran a <CODE>substitute</CODE> command after any
pattern searches for lines, then the pattern you gave the
<CODE>substitute</CODE> command to tell it what text to take
out of the line is the pattern that will be reused.  This is so
even if your <CODE>substitute</CODE> command began with a search
pattern to specify the line on which the substitution was to be
performed--the search to find the pattern to be replaced
within the line was run after the first search pattern had found
the line to operate on, so the search within the line was the
last pattern search run.  So if you were to type:</P>

<PRE><STRONG>
/the cat/ substitute /in the hat/on the mat
?? delete
</STRONG></PRE>

<P>the second command would, in this case, delete the last
previous line containing ``in the hat''. To be sure that the
pattern that gets reused is the last one used to find a line, use
the abbreviations "\?" and "\/" to search backward and
forward, respectively.  In all other respects these work just as
typing "??" and "//" do.</P>

<P><STRONG>A LINE NUMBER</STRONG> is also a valid line-mode
address.  The editor automatically numbers each line in the file
consecutively, and this numbering is dynamic--that is, whenever
you add or delete lines somewhere, the editor renumbers all the
lines following the insertion or deletion point.  So if you
change some text on line 46 in your file, and then delete lines
11 and 12, the line with the text you changed is now line 44.
And if you then add ten new lines after line 17, the line with
your changed text on it now automatically becomes line 54.</P>

<P>There is never a gap or an
overlap in the line number sequence, so the <EM>n</EM>th line
in the file is always line number <EM>n</EM>; that is, the 7th line
is always line number 7, and so on.  (There are several ways to
display these line numbers, which I will expound in a later
tutorial installment.)  To delete the 153rd line in your file,
just type:</P>

<PRE><STRONG>
153 delete
</STRONG></PRE>

<P>You don't use any delimiters around a line number, or around
any other address except a search pattern.</P>

<P>There are two symbolic line numbers and one fictional one that
can be used in line-mode addresses.  As long as there are any
lines in the buffer (that is, you haven't specified a 
not-yet-existent file to edit and failed to enter any text so
far), the editor regards you as being `on' one of them, usually
the last line affected by your latest command.  A period or dot
(<CODE><STRONG>.</STRONG></CODE>) is the symbolic address for
this line.  The last line in the file also has a symbolic
address: the dollar sign (<CODE><STRONG>$</STRONG></CODE>$). So
if you should type:</P>

<PRE><STRONG>
. write &gt;&gt; goodlines
$ delete
</STRONG></PRE>

<P>the first command would append a copy of just the line you
are on now to a file named ``goodlines'', while the second would
delete the last line in the file you are editing.</P>

<P>A few commands put text immediately after the line address you
give: the <CODE>append</CODE> command is one of them.  In order
to let them put their text at the very start of a file (if that
is where you want it), these commands can take the fictitious
line number zero (0) as their address.  So, if you want to type
some text that will appear ahead of anything already in the file,
you can do it with either of these command lines:</P>

<PRE><STRONG>
1 insert
0 append
</STRONG></PRE>

<P>(Note, though, that <CODE>insert</CODE> and <CODE>append</CODE>
are among the few line-mode commands that cannot be run from visual
mode by starting with a colon, because they occupy more than one line
including the text to be put in.)</P>

<P><STRONG>WRITING YOUR OWN LINE ADDRESSES</STRONG> is possible, too.
You can attach lower-case letters to lines as line addresses, and
change the attachments whenever you like.  You can even use a special
address that is automatically attached to the last line you jumped
off from.</P>

<P>There are ways to mark a particular line with a lower-case
letter of the alphabet, and those ways differ between line and
visual modes.  I'll be explaining all these ways in later
installments of this tutorial.  But once a line is marked, the
line-mode address that refers to that line is just the
single-quote character followed immediately by the lower-case
letter with which the line was marked.  So typing:</P>

<PRE><STRONG>
'b print
</STRONG></PRE>

<P>will display on the screen whatever line you have previously
marked with the letter b, no matter where the line is in relation
to where you are when you give the command.  No need to tell the
editor whether to search forward or backward; there can be only
one line at a time marked with any one letter, and the editor
will find that line regardless.</P>

<P>The editor does some line marking on its own, too.  Whenever
you move from one line to another by a non-relative address, the
editor marks the line you just left.  (A non-relative address
is one that isn't a known number of lines from where you were.)
So:</P>

<PRE><STRONG>
$
/the cat/
358
?glossary? +7
'b
</STRONG></PRE>

<P>are all non-relative addresses, and if you give any one of
them, the editor will mark the line you are leaving for future
reference.  Then you can return to that line just by typing
two successive single quotes:</P>

<PRE><STRONG>
''
</STRONG></PRE>

<P>as a line-mode address.  In theory, you can use this address
with any line-mode command.  But it is so difficult to know for
sure when you left a line via a non-relative address that this
address form is best saved for going back to where you were when
a mistake moves you far away, at least until you're a wizard
with this editor.</P>

<P><STRONG>MODIFYING ANY OF THESE ADDRESSES</STRONG> is possible,
and there are two ways to do this.  The simpler way is to offset
the address a certain number of lines forward or backward with
plus (<CODE>+</CODE>) or minus (<CODE>-</CODE>) signs.  The rule
is that each plus sign following an address tells the editor to
go one line farther forward in the file than the basic address,
while each minus sign means a line backward.  So these three
addresses all refer to the same line:</P>

<PRE><STRONG>
35
37 --
30 +++++
</STRONG></PRE>

<P>Not that you're likely to want to modify line-number addresses
with counts, unless you're weak in arithmetic and want the editor
to do the adding and subtracting for you.  But the count offsets
will work with any line-mode addresses, and are most often used with
search patterns.  In any event, there is a shorthand for these counts,
too.  A plus or minus sign immediately followed by a number (single or
multiple digits) is equivalent to a string of plus or minus signs equal
to that number, so that these two addresses are the same:</P>

<PRE><STRONG>
/^register long/ ++++
/^register long/ +4
</STRONG></PRE>

<P>Take note that the ``4'' in the second example does not mean
``line number 4'', as it would if it appeared by itself as an
address.  After a plus or minus sign, a number is a count forward
or backward from where the primary address lands (or if there is
no primary address before the count, from the line you are on
when you run the command).</P>

<P>Note also that this is one of the few places in line-mode
commands where you may not insert a blank space.  The number must
start in the very next character position after the plus or minus
sign.  If you violate this rule, the editor will uncomplainingly
operate on some line that definitely is not the line you
expected.</P>

<P>The second style of address modifier is used where you want to
do a search that's complex.  Let's say you want to go forward in
the file to delete a line that starts with ``WARNING!'', but not
the first such line the editor would encounter; you want the second
instance.  Either of these command lines will do it:</P>

<PRE><STRONG>
/^WARNING!/ ; /^WARNING!/ delete
/^WARNING!/ ; // delete
</STRONG></PRE>

<P>A semicolon (<CODE>;</CODE>) between two search patterns tells
the editor to find the location of the first pattern in the usual
way, then start searching from that location for the second
pattern.  In this case, the first search pattern turned up the
first instance of a line starting with ``WARNING!'', and the
second search pattern led the editor on to the second instance.</P>

<P>A very significant point here is that this combination of two
search patterns, either of which could be a line address in
itself, does not tell the editor to delete two lines.  The
semicolon means that the first pattern is merely a way station,
and that the single line found by the second search pattern is
the only line to be deleted.  In brief, what looks like addresses
for two lines is actually only an address for one.  (This is not
what the official documentation for this editor says, but the
documentation is just plain wrong on this point.)</P>

<P>But that's just the start of what you can do.  You are not
restricted to just two addresses.  I've used up to ten of them,
all separated by semicolons, to reach one specific line.  As an
example:</P>

<PRE><STRONG>
?^Chapter 3$? ; /^Bibliography$/ ; /^Spinoza/ ; /Monads/
</STRONG></PRE>

<P>will bring me to the title line of Spinoza's first work with
``Monads'' in the title, in the bibliography for Chapter 3.</P>

<P>Nor are you limited to search pattern addresses when putting
together a semicolon-separated address
string.  If you want to reach the first line following line 462
that contains the word ``union'', typing:</P>

<PRE><STRONG>
462 ; /\&lt;union\&gt;/
</STRONG></PRE>

<P>will bring you there.  And any of the addresses can take
numerical offsets, so:</P>

<PRE><STRONG>
462 +137 ; /register int/ ---
</STRONG></PRE>

<P>is also a legitimate address string.</P>

<P>But there are two unfortunate limitations on using
semicolon-separated address strings.  The lesser problem is that
such a string can use ``line zero'' as an address only if the
command following the address string could take line zero by
itself as its address.  That is, you can't even start at line
zero and then proceed elsewhere with additional addresses, unless
the command can operate from line zero.  So:</P>

<PRE><STRONG>
0 ; /Spinoza/ +++ ; /Kant/ delete
</STRONG></PRE>

<P>which looks like a reasonable way to be sure your search will
find the very first ``Spinoza'' in your file, will actually fail
with an error message about an illegal address.</P>

<P>The larger misfortune is that each address in a 
semicolon-separated string must be farther down in the file than
the one that precedes it.  (This means the actual location found,
after applying any plus-sign or minus-sign offset.)  You cannot
move backward within the series of way points.</P>

<P>But that does not mean that you cannot use a backward search
pattern within the string.  The first address can be a backward
search, of course.  And a subsequent address can search backward
if you are certain that the line it finds will actually be more
forward in the file.  For example, you may know that a certain
backward search will wrap around to the bottom end of the file
before it finds a match.  A common example would be:</P>

<PRE><STRONG>
1 ; ?Spinoza? ; /Hegel/ yank
</STRONG></PRE>

<P>Beginning a backward search from the first line in the file
means that the search must start with the last line in the file
due to wraparound, which guarantees that the search will yank the
``Hegel'' line that follows the vary last ``Spinoza'' line in
your file.</P>

<P>Also, you can use a plus-sign offset after a backward search
when you are certain that the line finally found after the offset
is applied will be farther down in the file than the preceding
way point had been.  Thus, if I want to find the first mention of
Hegel in Chapter 8 that is at least 120 lines after the last
mention of him in Chapter 7, I can type:</P>

<PRE><STRONG>
/^Chapter 8$/ ; ?Hegel? +119 ; //
</STRONG></PRE>

<P>If a command with this address fails and gives an error message
about a bad address, I'll know that the last mention of Hegel in
Chapter 7 is more than 120 lines before the end of the chapter,
so the very first mention of his name in Chapter 8 is what I'm
looking for.  In that case, the address:</P>

<PRE><STRONG>
/^Chapter 8$/ ; /Hegel/
</STRONG></PRE>

<P>is all that my command needs.</P>

<P>The situation with forward searches inside a semicolon-separated
address string is a mirror image of what I've just said.
A forward search can take a minus-sign offset if you know that the
offset is small enough that the line found will be further down
than the last way point.  But a forward search will fail, even with
no offset or a plus-sign offset, if wraparound makes it find a
line earlier in the file than the way point from which it began.</P>


<H3><A NAME="section2">Addressing a Section of Text</A></H3>

<P><STRONG>TWO ADDRESSES CAN ALSO STAND FOR A RANGE OF LINES.</STRONG>
When two addresses are separated by a comma rather than a semicolon,
the meaning changes radically.  (What a difference a dot makes!)</P>

<P>Often you will want a line-mode command to act on a series of
successive lines.  For example, you may want to move a stretch of
text from one place to another.  To do this, you give the address
of the first line you want the command to act on, followed by the
last line it should act on, and separate the two addresses with a
comma.  So, the command:</P>

<PRE><STRONG>
14 , 17 delete
</STRONG></PRE>

<P>will delete line 14 and line 15 and line 16 and line 17.  You
can see that putting more than two addresses in a comma-separated
address string would be pointless.  The line mode of this editor
is discreet if you ignore this and string together three or more
addresses with comma separation: it uses the first two addresses
and discards the rest.</P>

<P>Any line-mode addresses may be used with a comma.  All of the
following combinations make sense:</P>

<PRE><STRONG>
'd , /^struct/
257 , .
?^Chapter 9$? , $
</STRONG></PRE>

<P>The first address combination would cause the command that
follows it to operate on the section starting with the line you
have previously marked ``d'' and ending with the next forward
line that begins with ``struct'', inclusive.  The second
combination covers line 257 through the line you are on now.  The
third goes backward to include the previous line containing only
``Chapter 9'', and forward to include the very last line in your
file; plus all the lines in between, of course.</P>

<P>There are limitations on this technique, too.  The primary one
is that the address after the comma (after any offsets, of course)
cannot be earlier in the file than the address before the comma.
That is, the range of lines must run forward from the first address
to the second address.  So the command:</P>

<PRE><STRONG>
57 , 188 delete
</STRONG></PRE>

<P>is just fine, while the similar-looking command:</P>

<PRE><STRONG>
188 , 57 delete
</STRONG></PRE>

<P>will only produce an error message.  (But if the two addresses
happen to evaluate to the same line, there is no problem.  The
command will silently operate on the one line you've specified.)</P>

<P>As you work up to more sophisticated line-mode addresses, you
may get unexpected error messages about the second address being
prior to first address, when you don't see how you could have
anticipated that the addresses would evaluate that way.  That's
no disgrace, and the solution is simple.  After you've looked
over the addresses you used, and you're certain that they are the
ones you want, just type the command in again with the two
addresses in reverse order.  That is, if:</P>

<PRE><STRONG>
642 , /in Table 23/ delete
</STRONG></PRE>

<P>has failed, giving an error message that the lines are in
the wrong order, then:</P>

<PRE><STRONG>
/in Table 23/ , 642 delete
</STRONG></PRE>

<P>will solve that problem.</P>

<P>The last limitation is that when you use search patterns on
both sides of a comma, the second search starts from the current
line just as the first search did; it does not start from the
line that the first search found.  There's a way around that,
though, that involves using one or more semicolons along with a
comma.</P>

<P>A semicolon-separated address string can be used anywhere in
line mode that you would use a single address.  One very useful
technique is to use these address strings on one or both sides
of a comma, to indicate a range of lines to be affected.
Remember that an address string separated by semicolons is the
address of just one line, so this one line can be the start or the
end of a range of lines.  For example, in:</P>

<PRE><STRONG>
/^INDEX$/ ; /^Xerxes/ , $ write tailfile
?^PREFACE$? ; /^My 7th point/ , ?^PREFACE$? ; /^In summary/ -- delete
</STRONG></PRE>

<P>the first command would write the latter part of the index
to a new file, while the second could be used to remove a section
of a book's preface.</P>

<P>And that brings up the solution to our previous obstacle;
the second search's starting point.  If you want the search after
the comma to begin from the point the first search found, use
the first search pattern followed by a semicolon as the start of
your after-the-comma search string, as in either of:</P>

<PRE><STRONG>
?Stradivarius? , ?Stradivarius? ; /Guarnerius/
?Stradivarius? , ?? ; /Guarnerius/
</STRONG></PRE>

<P>In view of the rules about not going backward in line-mode
address strings, I'd better clarify the way these limitations
work when you combine semicolon and comma separation, as in these
two examples.  All but the first of the way points in each
semicolon-separated string must be in the forward direction, of
course, but the start of the second semicolon-separated string
may be prior to any of the addresses in the first such string,
that is, the one-way meter resets itself at the comma point.  And
using semicolon-separated strings on both sides of a comma only
requires that the final landing point of the second 
semicolon-separated string not be earlier in the file than the
final landing point of the first; the relative locations of the
way points don't matter to the comma.  To clarify this, consider a
couple of odd-looking, and useless, but very lucid examples.  The
combination:</P>

<PRE><STRONG>
125 ; 176 ; 221 , 32 ; 67 ; 240
</STRONG></PRE>

<P>looks invalid due to the backward jump from line 221 to line
32, but is actually a perfectly good address.  The back jump
comes right after the comma, where it is all right.  But:</P>

<PRE><STRONG>
125 ; 176 ; 221 , 32 ; 67 ; 218
</STRONG></PRE>

<P>will produce an error message, because the final landing point
of the first semicolon-separated string, line 221, falls later in
the file than the final landing point of the second
semicolon-separated string, line 218.</P>

<P>Now, a note about default addresses.  I've already mentioned
that most line-mode commands that can take an address have a
``default'' address built in, which tells the editor where to run
the command if you don't give an address with it.  Each command
has its own default address, which may be the current line, the
current line plus the one following, the last line of the file,
or the entire file.</P>

<P>The comma separator has default addresses of its own.  They
are the same regardless of what command is being used, and they
override any command's own default address.  If you put a comma
before a command and don't put an address before the comma, by
default the address there is the current line.  In the same way,
if you leave out the address after the comma, the default there
is also the current line.  You can even leave out the address in
both places and use the current-line default in both: that means
the implied address is ``from the current line to the current
line'', which makes the current line the only line the command
will operate on.  So every one of the following command lines:</P>

<PRE><STRONG>
.     write &gt;&gt; goodlines
. , . write &gt;&gt; goodlines
  , . write &gt;&gt; goodlines
. ,   write &gt;&gt; goodlines
  ,   write &gt;&gt; goodlines
</STRONG></PRE>

<P>will do exactly the same thing: append a copy of just the
current line in the file you're editing to another file named
``goodlines''.</P>

<P>Finally, there is one special symbol that represents a 
comma-separated address combination.  The percent sign
(<CODE>%</CODE>) has the same meaning as <CODE>1,$</CODE>
as a line-mode address combination.  Both refer to the entire
file.</P>


<H3><A NAME="section3">Now You Try It</A></H3>

<P>Before you try the complex aspects of line-mode addresses in
actual editing situations, here are some problems you can build
yourself up on.  For each problem I've included a solution that
will work fairly efficiently.</P>

<OL>

<LI>How can you tell the editor to delete the line that holds the
very last instance of ``EXPORT'' in your file?  The <A
HREF="vi009.html#q1pt2">solution</A> is straightforward
once you know where to start searching.</LI><BR><BR>

<LI>Suppose you want to delete the very first line in the file
with ``EXPORT'' on it, and that just might be line 1.  You can't
start the search from line zero because the delete command cannot
take line 0 as an address.  When you type the address string
<NOBR>"$ ; /EXPORT/"</NOBR> to use wraparound, you get an error
message asserting that the search pattern found a line prior to
the line found by the ``$'' address that appeared first, which is
what you'd expect.  How can you tell the editor to find and
delete this line?  The <A
HREF="#q2pt2">solution</A> requires just a bit
of creativity.</LI><BR><BR>

<LI>If you use the address <NOBR>"?abc?  , /xyz/"</NOBR>, it
includes the two lines the searches (for ``abc'' and ``xyx'')
find, as well as all the lines between them.  How would you
specify that you want the affected lines to go up to, but not
include, the lines the two searches find?  In this case the <A
HREF="#q3pt2">solution</A> is simpler than
you might think.</LI>

</OL>


<H3><A NAME="next">Coming Up Next</A></H3>

<P>The <A
HREF="009.part3.html">next installment</A> of this tutorial will
deal with the Global commands--they're just too much to absorb
right after the mind-numbing collection of address forms we've
just gone through.  And to give you more scope for using all
these address forms, I'll also cover line-mode commands
themselves, particularly the ones that have more capabilities
than you suspect.</P>

<HR>
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 3</H1>

<A HREF="/uworld/copyrights/bsd-daemon.txt">



<H2>The Vi/Ex Editor, Part 3: The Global Command</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter Alan
Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>

<UL>
<LI><A HREF="#section1">The Details of Global Operations</A></LI>
 
<LI><A HREF="#section2">A Few More Uses for Global Commands</A></LI>
 
<LI><A HREF="#section3">Now You Give It A Try</A></LI>

<LI><A HREF="#next">Coming Up Next</A></LI>

</UL>


<H3>The Wondrous Global Command</H3>

<P>If you're surprised that I made no mention of
<CODE><STRONG>:global</STRONG></CODE> in the
preceding installment of this tutorial
-- well, <CODE><STRONG>:global</STRONG></CODE> is not an address.
It's actually a line-mode command, and it's much more powerful
than most users suspect.</P>

<P><A NAME="target01">Even experienced users of line mode</A>
usually think of <CODE><STRONG>:global</STRONG></CODE> along
these lines: ``If you type <CODE><STRONG>:global</STRONG></CODE>
and then a search pattern and then a line-mode command, all on
one line, then the editor finds every line in the file that
contains that pattern and runs the command on every one of those
lines''. That is, typing:</P>

<PRE><STRONG>
global /^Chapter [1-9]/ delete
</STRONG></PRE>

<P>is expected to find and delete every line in the file that starts
with a chapter heading.  This example will do just that, and so will
many other such uses of the command.  But spectacular failures
will happen from time to time--typing:</P>

<PRE><STRONG>
<A NAME="write">global /^Chapter [1-9]/ write &gt;&gt; t.of.contents</A>
</STRONG></PRE>

<P>definitely will <STRONG>not</STRONG> append each of the marked lines
to a file named ``t.of.contents'', as moderately experienced users
might expect.  (It's likely to overflow your file system quota
instead.)</P>


<H3><A NAME="section1">The Details of Global Operations</H3>

<P>More important, misunderstanding the <CODE><STRONG>:global</STRONG></CODE> command
keeps users from exploiting more than a small fraction of that
command's power.  But you don't have to live with the limitations of
ignorance on this--here's the full story in plain terms:</P>

<DL>

<DT>Searching where you tell it to look:

   <DD><P>As a line-mode command, <CODE><STRONG>:global</STRONG></CODE> can be
   preceded by an address or pair of addresses.  Its default is
   to search the entire file, but if you start your command as
   <CODE>257 , 382 global</CODE> then it will only search through
   lines 257 through 382 inclusive.  Any line-mode addresses can
   begin a <CODE><STRONG>:global</STRONG></CODE> command, so starting with
   <CODE>?^Exercises? +++ , $ global</CODE> will restrict the pattern
   search and line marking to a stretch beginning three lines past
   the last previous line that starts with the string ``Exercises'',
   and ending at the end of the file.</P>

<DT>Marking either hits or misses:

   <DD><P>Typing the command name as <CODE>global</CODE> or
   <CODE>g</CODE> will definitely cause it to mark every line
   in the search area that contains the pattern.  But typing it as
   <CODE>global!</CODE> or <CODE>g!</CODE> or <CODE>v</CODE>
   reverses the procedure--now it will only mark lines that do
   <STRONG>not</STRONG> contain the search string.  So if you are
   editing a copy of a log file of error messages, and only the
   lines that begin with ``Error 3b:'' are of interest, you can
   eliminate all the unwanted lines by typing:</P>

   <PRE><STRONG>
   global! /^Error 3b:/ delete
   </STRONG></PRE>

<DT>Choose your own search pattern delimiter:

   <DD><P>Since this command always searches the file (or the section
   of it that you select) from top to bottom, you can use almost any
   punctuation character to mark the start and end of your search
   pattern.  There's no need to use ? or / characters to indicate a
   direction for the search.  If you want to eliminate lines that
   contain three consecutive slash marks, any of:</P>

   <PRE><STRONG>
   global +///+ delete
   global ;///; delete
   global ]///] delete
   </STRONG></PRE>

   <P>will be a simpler choice than using slashes as delimiters and
   backslashing all three of the slashes you are searching for.
   (However, using <CODE>!</CODE> as you delimiter is dangerous,
   because <CODE><STRONG>:global</STRONG></CODE> is likely to mistake your
   delimiter for the switch that tells it to find only lines that
   do <STRONG>not</STRONG> contain the search pattern.)</P>

   <P>Of course this applies only to the search pattern that goes
   right after the <CODE><STRONG>:global</STRONG></CODE> command name, 
   the one that says which lines to mark.  If you use any search patterns
   before the command name, to say which area of the file is to
   be searched, then use ? and / delimiters as usual.</P>

<DT><A NAME="target10">Global searches that seem senseless</A> 
   can be very useful:

   <DD><P>At times it's wise to have <CODE><STRONG>:global</STRONG></CODE> or
   <CODE><STRONG>:global</STRONG>!</CODE> run a search over just one 
   line in a file.
   This is the basis for conditional execution of line-mode commands.
   As a simple example, you may find yourself editing files from
   outside your organization that are sometimes (but not always)
   sent to you with an extra, empty last line, as a spacer.
   You need to remove that last line, if and only if it is empty.
   You could go the end of each file and look, but it's easier
   to have the editor do the checking and (where necessary) the
   deletion, so you type:</P>

   <PRE><STRONG>
   $ global /^$/ delete
   </STRONG></PRE>

   <P><A NAME="target09">It can also be useful</A> to have 
   <CODE><STRONG>:global</STRONG></CODE> mark every
   line in the area of the file you tell it to search!  Our put-upon
   programmer, Hal (in the first installment of this tutorial) used
   this when he had to reverse the order of the lines in one file.
   His command line, which would look like this if typed out in
   unabbreviated form:</P>

   <PRE><STRONG>
   global /^/ move 0
   </STRONG></PRE>

   <P>begins by marking each line that has a start-of-line point,
   which makes every line qualify.  Next it goes to the first line
   and moves it up right after the fictitious line zero--a no-op,
   of course.  But then it moves the second line to the same place,
   pushing the former first line down one
   position in the file.  As it does the same with the third line,
   the fourth line, etcetera, it's changing the order of the lines
   to the exact opposite of the order they were in at the start.</P>

<DT>One <CODE><STRONG>:global</STRONG></CODE> can run many commands:

   <DD><P>You can put several commands on the line after a
   <CODE><STRONG>:global</STRONG></CODE> command and its search pattern.  After
   marking the appropriate lines, <CODE><STRONG>:global</STRONG></CODE> will then
   go to each marked line and run all of the commands you've
   given it, in the order you gave them.  Just separate these
   commands with a vertical bar (``|'') character.  <A
   NAME="chapter">If you type:</A></P>

   <PRE><STRONG>
   global /^CHAPTER/ substitute /APTER/apter/ | copy $
   </STRONG></PRE>

   <P>the editor will go to each line that starts with a chapter
   heading, change ``CHAPTER'' to ``Chapter'', and then copy the
   line (now beginning ``Chapter'' instead of ``CHAPTER'') to
   the end of the file.  The order in which you put those two
   commands is important -- the <CODE>substitute</CODE> command
   must come first so the subsequent <CODE>copy</CODE> command
   will copy the decapitalized version of the line, not the
   original all-caps version.</P>

   <P>You're not limited to just two commands in a
   <CODE><STRONG>:global</STRONG></CODE> command line; there is no maximum on the
   number of commands there.  The maximum string length for the
   command list varies with the editor version you're using, but
   I've never encountered a limit of less then 256 characters.
   There are a few restrictions on what the command list can
   contain, though:</P>

      <UL>

      <LI>The <CODE>global</CODE> keyword and the following list of
      commands all must be on one line.  (That is, on one physical
      line, with no carriage returns in it.  If that one line is too
      long for your terminal's screen width, the terminal may wrap it
      around to occupy two or more lines on your screen, but this
      will not cause a problem.)</LI>
   
      <LI>The command list cannot include an <CODE>undo</CODE>
      or another <CODE><STRONG>:global</STRONG></CODE> command.</LI>

      <LI>If you include a command that escapes to the shell, it
      must be the last command on the line.  (Putting two or more
      shell-escape commands in one command list will not work.)
      This makes it possible to use pipes (symbolized by the
      <CODE>|</CODE> character) in your shell-escape command string,
      without having the editor mistake the pipe symbol for the
      separator between two editor commands in your
      <CODE><STRONG>:global</STRONG></CODE> command line.</LI>

      </UL><BR><BR>

<DT>Commands don't have to run on the lines <CODE><STRONG>:global</STRONG></CODE> marks.

   <DD><P>Using <CODE><STRONG>:global</STRONG></CODE> is essentially the same as
   moving to each marked line manually, then typing in the
   command string while you are there.  Just as you no longer
   expect every command you type in to operate on the line you
   are on when you type it, you don't have to have the commands
   in a <CODE><STRONG>:global</STRONG></CODE> string operate entirely on the
   marked lines.  Here are three points to note regarding this:</P>

      <OL>

      <LI><P>Any command in a <CODE><STRONG>:global</STRONG></CODE> command line can
      take its own address or addresses, just as it could if it
      were typed in as a separate command.  So this command
      string:</P>

      <PRE><STRONG>
      global /^XX/ - copy $ | /ZZ$/ , +5 delete
      </STRONG></PRE>

      <P>is entirely legitimate.  It goes to each line that begins
      with two capital X's, then copies the line just before that
      one to the end of the file, and finally goes forward to the
      next line that ends with two capital Z's and deletes that
      line and the five lines that follow it.</P></LI>

      <LI><P>Even if you give no addresses for the commands in a
      <CODE><STRONG>:global</STRONG></CODE> string, default addresses for those
      commands may make them operate on other than the marked line.
      That's the fault in that <CODE><STRONG>:global</STRONG></CODE> command string
      <A HREF="#write">in the introduction</A> to this installment
      of my tutorial that tries to write individual lines to
      another file.  Because the default address for the
      <CODE>write</CODE> command is the entire file, this command
      will write the entire file the user is editing to the
      end of the other file,
      once for every line that <CODE><STRONG>:global</STRONG></CODE> 
      has marked.
      The correct way to write individual lines is to type:</P>

      <PRE><STRONG>
      global /^Chapter [1-9]/ . write &gt;&gt; t.of.contents
      </STRONG></PRE>

      <P>where the dot address in front of the <CODE>write</CODE>
      command tells it to write only the line it is on.</P></LI>

      <LI><P>But even if you take a command that has the current
      line as its default address, and put it in the string
      following <CODE><STRONG>:global</STRONG></CODE> without giving it an address
      of its own, it can still operate on different lines from the
      ones <CODE><STRONG>:global</STRONG></CODE>has marked if it is not the first
      command in the string.  The reason: each subsequent command
      in a <CODE><STRONG>:global</STRONG></CODE> takes as the current line whatever
      line the command before it left as the current line.</P>

      <P>In my <A HREF="#chapter">earlier example</A> about wanting
      to both change the capitalization of lines beginning with
      ``CHAPTER'' and copy those lines to the end of the file, the
      task was easy because the lines were to be copied in their
      changed state.  But what if the user wanted only the lines
      in the midst of the file decapitalized, while the ones copied
      to the end of the file were to remain all-caps?  It might
      seem obvious to simply reverse the order of the two commands,
      so the <CODE>copy</CODE> command was executed first, before
      the <CODE>substitute</CODE> command was called to change the
      capitalization, like this:</P>

      <PRE><STRONG>
      global /^CHAPTER/ copy $ | substitute /APTER/apter/
      </STRONG></PRE>

      <P>Surprisingly, that would produce the opposite of the
      effect that was intended.  That is, it would decapitalize
      the copied lines at the end of the file, but leave the
      marked lines in the midst of the file all-caps.
      The reason?  The <CODE>copy</CODE> command leaves the last
      line of the copy text block, not the original text block, as
      the current line.  So after the <CODE>copy</CODE> command
      has run, the <CODE>substitute</CODE> command, using the
      command's default address (the current line) because it
      has not been given an explicit address, would operate on
      the copy line rather than the original.</P>

      <P>But there is one thing that no amount of current-line
      shifting can change.  Wherever in the file the command
      string may leave the current line, when the commands have
      finished running, <CODE><STRONG>:global</STRONG></CODE> will go to the next
      marked line without fail.  The only way any of the commands
      in the string can prevent this is by deleting the next
      marked line -- in that case, <CODE><STRONG>:global</STRONG></CODE> will
      merely go on to the next marked line that has not been
      deleted.  And even this fact has uses that might not
      be obvious.</P>

      <P>Let's say you want to thin out the lines in a file,
      by deleting every second line.  You can do it by typing:</P>

      <PRE><STRONG>
      global /^/ + delete
      </STRONG></PRE>

      <P>This <CODE><STRONG>:global</STRONG></CODE> starts off by marking every line.
      When it goes to line 1, the command it executes will delete
      line 2.  The next undeleted marked line is line 3, where its
      command deletes line 4, and so on.  Or if you want to delete
      two-thirds of the lines in your file, type:</P>

      <PRE><STRONG>
      global /^/ + , ++ delete
      </STRONG></PRE></LI>

      </OL>

</DL>


<H3><A NAME="section2">A Few More Uses for Global Commands</A></H3>

<P>The examples above are designed to show not only the working
principles of the <CODE><STRONG>:global</STRONG></CODE> command, but also some
of the less-obvious tricks it can do.  But I couldn't fit every
important trick in above.  Here are some more that are well
worth knowing.</P>

<P><STRONG>Keeping Count.</STRONG>  At times it's a good idea
to follow <CODE><STRONG>:global</STRONG></CODE> with a string of commands that
have absolutely nothing to do with the lines that
<CODE><STRONG>:global</STRONG></CODE> has marked.  The most common occasion for
this comes when you need to repeat a line-mode command a
certain number of times.</P>

<P>At tradeshows I'm often invited to test a system right there
on the show floor.  I can't carry a 10,000-line test file along
with me in every media and format any system might require, so
I type in a ten-line file on the spot and expand it by telling
the editor ten times to make a copy of the entire file and put
that copy at the end of the present file.  (Each such copy doubles
the file's size, so I wind up with 10,240 lines.)</P>

<P>But that requires accurate counting.  If I'm off by even one
on the number of times I type that command in, I get a half-size
or double-size file that ruins my test results.  Instead of
trying to count without an error, I let the editor do the
counting for me.  After I've typed in the initial ten lines,
I give one <CODE><STRONG>:global</STRONG></CODE> command:</P>

<PRE><STRONG>
global /^/ % copy $
</STRONG></PRE>

<P>This tells the editor to search the ten lines of the file,
mark every line that has a start-of-line (which means every line,
of course), and then go to each of those ten lines and run the
subsequent command to make a whole-file copy.  This guarantees
that the command will run exactly ten times.</P>

<P>Not that this trick is limited to files that have exactly
as many lines as the number of times I want to command to be
repeated.  If I had typed in a twenty-line file, I could copy
it ten times by giving my <CODE><STRONG>:global</STRONG></CODE> as:</P>

<PRE><STRONG>
1 , 10 global /^/ % copy $
</STRONG></PRE>

<P><STRONG>Moving Around Automatically.</STRONG> At times you
may need to handle a series of editing problems in a file,
where the edits must be dealt with one by one, not with a
<STRONG>:global</STRONG> editing script.  But moving to each spot where work
needs to be done can be a very tedious business.  If there is
a text pattern that identifies each place that needs editing,
or if you can write a script to insert such a pattern, as Hal
did at the start of this tutorial's first installment, then
<CODE><STRONG>:global</STRONG></CODE> can move you around automatically.</P>

<P>You may recall that Hal used a script to mark up the legacy
source code, putting each <CODE>lint</CODE> warning at the
end of the source line to which it referred, preceded by "XXX"
to make the affected lines identifiable.  Suppose that the
nefarious Vice President for Information Systems comes back
to Hal to demand that each warning be investigated, to see
whether the code can be rewritten to eliminate the warning.</P>

<P>Should Hal just leaf through the code, searching for XXX
patterns to guide him to the trouble spots?  Hal knows that with
the spaghetti code he's facing, the actual problem may be a long
way from the line <CODE>lint</CODE> has designated.  In
traveling to the actual trouble spot he may have passed several
XXX patterns along the way, so searching for the next XXX in the
file may bring him to a site he's already dealt with, or may miss
a number of XXX sites that he passed when he moved forward to get
to the actual problem spot on the previous fix.  Besides, because
he frequently does pattern searching while fixing a problem, he
can't depend on a visual-mode <CODE>n</CODE> command to use the
XXX pattern he needs to find; he must type the pattern in afresh
each time.</P>

<P>But Hal knows a way around all this--dropping back to line mode
(by typing a capital letter Q from visual mode) and giving a simple
<CODE><STRONG>:global</STRONG></CODE> command:</P>

<PRE><STRONG>
global /XXX/ visual | write
</STRONG></PRE>

<P>This command brings Hal to the first "XXX" line, where it puts
him into visual mode to do his editing.  When the edit is
finished, Hal simply types a capital letter Q and the editor
takes him to the second "XXX" line and puts him into visual mode
there, no matter how much moving around Hal did during the first
edit, and so on through the list of "XXX" lines.  As frosting on
the cake, the <CODE>write</CODE> command automatically writes the
changed file to disk after each individual edit.</P>


<H3><A NAME="section3">Now You Give it a Try</A></H3>

<P>Here are a few exercises you can try to solve, before you
start using advanced <CODE><STRONG>:global</STRONG></CODE> tactics in your own
editing.  To keep things rolling I've provided at least one
solution to each exercise, and also a hint on the last (and
toughest) problem.</P>

<P><STRONG>Copy and Decapitalize.</STRONG>  Let's think back
to the user who wanted to find each line in the file that
begins with "CHAPTER", then copy each such line to the end
of the file just as it is, and finally change the start of
each original line (in mid-file) from "CHAPTER" to "Chapter"
while leaving the copied lines (at the end of the file)
beginning "CHAPTER".</P>

<P>We've already learned that this cannot be done with either
of:</P>

<PRE><STRONG>
global /^CHAPTER/ substitute /APTER/apter/ | copy $
global /^CHAPTER/ copy $ | substitute /APTER/apter/
</STRONG></PRE>

<P>What <CODE><STRONG>:global</STRONG></CODE> command (or commands) would it take
to do what's desired here?  Finding a <A
HREF="#q1pt3">solution</A> to this is not
difficult when there are so many workable ones.</P>


<P><STRONG>A Precise String Length.</STRONG>  An old friend who
does some pretty tricky work with <CODE>troff</CODE> often
needs to insert a string of backslashes in a line--up to 64
of them in a row.  The count of backslashes must be exactly
right or <CODE>troff</CODE> will choke.  How can he get these
strings exactly right without tedious counting and checking?</P>

<P>Let's say he needs to put 16 backslashes in line 217, right
before the string "n(PDu". What command(s) should he use to get
them in there without hand counting.  My <A
HREF="009.ans.part3.html#troff">solution</A> is pretty plain once
you know which commands to use.</P>


<P><STRONG>Numbering Paragraphs.</STRONG>  A documentation writer
has divided each section of a document into paragraphs, and as a
<CODE>troff</CODE> user, marks the start of each paragraph by a
line that contains the macro ".pp" only.  That is, a break
between paragraphs looks like this:</P>

<PRE><STRONG>
which is the only way that argon gas can be dissolved
in this liquid.

.pp
The problem of energizing the argon to fluorescence while
it is dissolved was first approached by applying a strong
</STRONG></PRE>

<P>How can this tech writer use the vi editor to number the
paragraphs in each section?  (If this seems far-fetched to
you, consider that I once got a phone call from a Unix guru
asking how to do just this.)  To keep the problem simple, let's
say that there are never more than 35 paragraphs in a section,
and that they should be numbered with Roman numerals.</P>

<P>This problem is still difficult enough that I'm offering you
two hints.  The first is that <CODE><STRONG>:global</STRONG></CODE> is essential
here.  Look at the second <A 
HREF="009.ans.part3.html#hint-number">hint</A> only if you're
about to give up and check my <A
HREF="009.ans.part3.html#solution-number">solution</A>.</P>


<H3><A NAME="next">Coming Up Next</A></H3>

<P>In the next part of this tutorial</A>, I'll cover
the less-known aspects of the other line-mode commands for
dealing with text and files.  If you're a little overwhelmed with
all that I've said about <CODE><STRONG>:global</STRONG></CODE>,
you'll be pleased to know that <CODE>substitute</CODE> is notably
simpler, and all the remaining commands are very much simpler,
than <CODE><STRONG>:global</STRONG></CODE>.</P>

<P>After that, future parts of this tutorial will deal with
visual mode; easier and more fun than line mode any day.</P>

<HR>
 
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 4</H1>

<P><A HREF="/uworld/copyrights/bsd-daemon.txt">



<H2>The Subtle Substitute Command</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter Alan
Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>

<UL>
<LI><A HREF="#section1">Making Changes Within Lines</A></LI>
<LI><A HREF="#section2">A Few More Metacharacters</A></LI>
<LI><A HREF="#section3">Replacement-Pattern Metacharacters</A></LI>
<LI><A HREF="#section4">Other Uses for Substitution</A></LI>
<LI><A HREF="#section5">A Start on Script Writing</A></LI>
<LI><A HREF="#section6">Don't Lose Your Files</A></LI>
<LI><A HREF="#feedback">Reader Feedback</A></LI>
<LI><A HREF="#next">The Next Installment</A></LI>
</UL>

<P>[<EM>Editor's Note:</EM> We'll indicate a line-mode command in
the paragraph text by prefixing it with a colon
(<CODE><STRONG>:</STRONG></CODE>), the character used to execute
a single line-mode command from visual command mode.]</P>

<P>After the <CODE><STRONG>:global</STRONG></CODE> command, which
we discussed in the <A HREF="009.part3.html">previous
installment</A> of this tutorial series, the
<CODE><STRONG>:substitute</STRONG></CODE> command is line mode's
most subtle and complex tool.  When I've gone over those
complexities we'll be ready to deal with techniques and tricks of
building powerful line-mode command strings.</P>


<H3><A NAME="section1">Making Changes Within Lines</A></H3>

<P>Most of you already know the <CODE><STRONG>:substitute</STRONG></CODE>
command by its shortest abbreviation <CODE><STRONG>:s</STRONG></CODE>
and use it in roughly this form:</P>

<PRE><STRONG>
s/previous/former/
%s/Smith/Lee and Smith/
</STRONG></PRE>

<P>to make some change within the line you are on, in the first case,
or change every instance in the file in the second.  If you use
both forms you are already ahead of the game.  Too many class
instructors and textbook writers try to tell you that the way to
change some phrase throughout the file is to type something like:</P>

<PRE><STRONG>
global/Smith/s//Lee and Smith/
</STRONG></PRE>

<P>This is wasteful nonsense.  Both forms accomplish exactly the
same thing, but the second version involves extra typing for you
and an extra run through the file for your computer.  It does not
matter that not every line in your file will contain a ``Smith''
to be changed -- the <CODE><STRONG>:substitute</STRONG></CODE>
command will execute properly in either version, and quietly if
even one line in the file has a ``Smith'' it can change.</P>

<P><A NAME="target07">But neither form as it stands</A> is sure
to change every ``Smith'' in the file.  The
<CODE><STRONG>:substitute</STRONG></CODE> command is set up to
change only the first example of the string it finds on any
particular line, so a line in the text that originally read:</P>

<PRE>
inure to Smith's benefit only if Smith shall
</PRE>

<P>will be changed by either version of the command to read:</P>

<PRE>
inure to Lee and Smith's benefit only if Smith shall
</PRE>

<P>Line mode has a built-in solution for this problem: place a
lower-case letter ``g'' at the very end of the command, immediately
after the last ``/'' mark, in order to make the change on every such
string in each line.  So typing this:</P>

<PRE><STRONG>
% substitute /Smith/Lee and Smith/g
</STRONG></PRE>

<P>will make that text line come out as:</P>

<PRE>
inure to Lee and Smith's benefit only if Lee and Smith shall
</PRE>

<P>Finer tuning of the instances can be done by a little
trickery.  Suppose you are working on tables, and want to change
only the very last ``k37'' on each line to ``q53''. This command
will do it:</P>

<PRE><STRONG>
% substitute /\(..*\)k37/\1q53
</STRONG></PRE>

<P>If this seems surprising, remember that in a search pattern
with a wild card, the editor always extends the match to the
greatest length it can.  In this case that means the string
starting at the beginning of the line and ending with the last
``k37'' in the line.</P>

<P>Now you should be able to extend this example.  What command
would change only the second-to-last ``k37'' on each line?  This
requires a shrewd guess from you, so I've written a <A
HREF="#q1pt4">solution</A> you can compare to
your own.</P>


<H3><A NAME="section2">A Few More Metacharacters</A></H3>

<P>You probably already know that you don't always have to type
the search pattern that indicates the text to be replaced by a
substitution command.  If you want to reuse your very last search
pattern, whether that was in a substitution command or not, you
can use an empty search pattern string to stand for the last
search pattern, so the two commands below are actually
identical.</P>

<PRE><STRONG>
/Murphy/ substitute /Murphy/Thatcher/
/Murphy/ substitute //Thatcher/
</STRONG></PRE>

<P>Either command will go to the next line containing ``Murphy''
and there replace the first ``Murphy'' with ``Thatcher''.</P>

<P>Within a substitution command's search pattern to find the
text to be removed, all the normal search-pattern metacharacters
apply.  So do two more that are reserved only for substitution
commands: the ``\('' and ``\)'' metacharacters.</P>

<P>These two metacharacters don't match anything themselves, so:</P>

<PRE><STRONG>
substitute /^The cat and small dog show/
substitute /^The \(cat\) and \(small dog\) show/
</STRONG></PRE>

<P>are exactly the same command as far as they go.  But the
substitution command remembers what it finds to match the text
between a pair of ``\('' and ``\)'' metacharacters, for use in
the replacement text.  Whenever your replacement pattern contains
``\1'' the editor replaces that metacharacter with whatever
matched the characters that were between the first pair of ``\(''
and ``\)'' metacharacters.  A ``\2'' in the replacement pattern
is removed and replaced by whatever was matched the characters
between the second pair.  And so on -- you can have up to nine
pairs in one substitution command.  These metacharacter pairs can
even be nested in the to-be-replaced text; the one that starts
first will be represented by ``\1'' and so on.  So if you extend
that second substitution command above to read:</P>


<PRE><STRONG>
substitute /^The \(cat\) and \(small dog\) show/My \2-\1 fair
</STRONG></PRE>

<P>the substitution command will produce a line that begins:</P>

<PRE>
My small dog-cat fair
</PRE>

<P>Or if you type:</P>

<PRE><STRONG>
substitute :up \(and \)\(over \)\(the sky\):\2\1\2\1\2\3
</STRONG></PRE>

<P>then your command will change the first line below to read
as the second line, just beneath it:</P>

<PRE>
up and over the sky
over and over and over the sky
</PRE>

<P>(I used the colon ``:'' character to separate the parts of
the command, instead of the slash ``/'' character, solely to
make it more readable for you.  There is no danger of the
editor confusing ``/'' with ''\'' or ``l'' (el) with ``1''
(one) etcetera.)</P>

<P>As the preceding examples show, the ``\('' and ``\)'' are not
too useful with plain-text search patterns; about their only real
value there is when you are searching for something that's
difficult to spell correctly, and don't want to type it into the
replacement pattern with possible spelling errors.  (Spelling
errors aren't so dangerous in the to-be-replaced text, because
they only cause the pattern match to fail.)</P>

<P>These metacharacters save the day, though, when you are
dealing with other search metacharacters in searching for text that
you will want to put back in.  (Often the only way to specify the
exact spot you want the replacement done is to include some
neighboring text in the search pattern, and tell the editor that
after the neighboring text has been taken out it is to be put back
in right where it was.)  Here are three examples of this kind of
substitution:</P>

<PRE><STRONG>
% substitute :\([Ss]ection\) \([0-9][0-9]*\):\1 No. \2:g
/\([Ss]ection\) \([0-9][0-9]*\)/ substitute ::\1 No. \2
% substitute ,[Aa]nswer: \([TtFf] \),ANSWER: \1,g
</STRONG></PRE>

<P>The first of these simply inserts ``No.''  in the middle of
phrases that are section numbers, throughout the document.  But
the ``\('' and ``\)'' notation is essential to preserve the
section number in each case, and also to leave unchanged the
capitalization or noncapitalization of the first letter of
``section''.</P>

<P>The second command does the same thing, but only on the very
next line that has a section number to change.  The surprise here
is that I put the ``\('' and ``\)'' in the address pattern to
find the correct line.  A line address doesn't use these
metacharacters, of course, but it does not object to them,
either.  It just ignores them in its own line search, but does
pass them along when a following substitution command reuses the
last search pattern, as happens in this example.</P>

<P>The third example is useful in editing a list of answers to
exercises.  It stops at each answer to a true-or-false question
and capitalizes the entire word ``answer''. The innovative aspect
of this command is that it finds the letter ``T'' or ``t'' or
``F'' or ``f'' following the word ``answer'', so it will not
change the capitalization where an answer is numerical rather
than true or false.  And yet, the letter indicating whether
``true'' or ``false'' is the correct answer is not discarded as a
side effect.  This is primarily an example of a change that can
be done more simply by using other metacharacters in the
replacement pattern.  Those other metacharacters are described
below.</P>


<H3><A NAME="section3">Replacement-Pattern Metacharacters</A></H3>

<P>The string of characters you want to put in via a substitution
command can use its own list of metacharacters.  They're entirely
different from the metacharacters used in searching for a pattern
you want to take out of a line.</P>

<DL>

<DT><STRONG>&</STRONG>

<DD><P>In a replacement pattern, the ``&'' stands for the entire
text that was to be replaced.  Use this when you want to add
rather than replace text.  For example, to change ``kit'' to
``kit and kaboodle'' regardless of whether ``kit'' is
capitalized, use:</P>

<PRE><STRONG>
% substitute /[Kk]it/& and kaboodle/g
</STRONG></PRE>

<P>If you have <CODE><VAR>magic</VAR></CODE> turned off, you must backslash
the ``&'' to give it metavalue.  With <CODE><VAR>magic</VAR></CODE> on,
backslash an ``&'' to insert it as a regular character.</P>

<!--Provide link to explanation of set and magic in a
subsequent installment.-->

<DT><STRONG>~</STRONG>

<DD><P>The ``~'' character represents the replacement pattern you
used in your last substitution command.  One good use for this
is in correcting various misspellings of a single word:</P>

<PRE><STRONG>
% substitute /[Ff]anstock clip/Fahnestock clip/g
% substitute /[Ff]ahnstock clip/~/g
% substitute /[Ff]ahnstocke clip/~/g
% substitute /[Ff]annstock clip/~/g
% substitute /[Ff]anestock clip/~/g
% substitute /[Ff]aenstock clip/~/g
</STRONG></PRE>

<P>If you have <VAR>magic</VAR> turned off, you must backslash
the ``~'' to give it metavalue.  With <VAR>magic</VAR> on,
backslash a ``~'' to insert it as a regular character.</P>

<DT><STRONG>\U</STRONG>

<DD><P>A ``\U'' metacharacter makes all letters following it
into capitals; to the end of the replacement pattern or until
another metacharacter turns it off.  Here's how you'd use it
to change a section of your document to all capitals:</P>

<PRE><STRONG>
1 , substitute /.*/\U&
</STRONG></PRE>

<DT><STRONG>\L</STRONG>

<DD><P>A ``\L'' gives the opposite effect of a ``\U'';
all following letters become lower case.  You might use this
to decapitalize acronyms:</P>

<PRE><STRONG>
% substitute /FORTRAN and COBOL/\L&/g
</STRONG></PRE>

<DT><STRONG>\E</STRONG>

<DD><P>Use ``\E'' to end the effect of a ``\U'' or ``\L''
metacharacter.  Everything following the ``\E'' has the
same mix of capitalization as originally.  For example, to
enclose a line of text in curly braces, and also change just
the first word to all capitals:</P>

<PRE><STRONG>
substitute :\([^ ]*\)\(.*\):{\U\1\E\2}
</STRONG></PRE>

<P>No ``\E'' is needed when you switch from ``\U'' to ``\L''
in the middle of a replacement pattern, or vice versa.  When
either of those metacharacters appears, it automatically ends
the effect of the other.  So if you have a list of book titles,
one title per line,
with only the first letters of the words capitalized, and you
want to change those titles to all capitals before the colon
in the middle of each title, and all lower case after it,
just type:</P>

<PRE><STRONG>
% substitute ,\(.*\):\(.*\),\U\1:\L\2
</STRONG></PRE>

<DT><STRONG>\u</STRONG>

<DD>This metacharacter capitalizes just the single letter that
immediately follows it.  If the character that immediately
follows it is not an alphabet letter, ``\u'' does nothing.

<DT><STRONG>\l</STRONG>

<DD>The same as ``\u'', except that ``\l'' makes the
immediately following letter come out as lower case.
</DL>

<P>One more thing that's important to know about reusing patterns in
substitution commands.  When all or part of a text-to-be-replaced
pattern is going to be used as a replacement pattern, or vice
versa, the command reuses the result of the original pattern,
after all the metacharacters have been evaluated in the original
situation.  Since the metacharacters in either of those two types
of patterns have no meaning in the other type, it could hardly be
otherwise.</P>

<P>But when the reuse involves a text-to-be-replaced pattern
being used a second time as a text-to-be-replaced pattern, or a
replacement pattern being reused as a replacement pattern, the
command brings along all the original metacharacters and
evaluates them afresh in the new situation.  Thus, in either of
the cases in this paragraph, the second use is unlikely to
produce exactly the same results as the first use did.</P>

<P>Now another exercise for you.  Suppose that lines 237 through
289 of a file have unknown capitalization--any line could be all
caps, all lower case, or some mixture.  These lines are to be
changed so that the first letter of every word is a capital and
all other letters are lower case.  To simplify this, words are
separated by space characters.  What is the easy way to do this
with one line-mode substitution command?  This exercise depends
on something I did not state directly, so don't feel bad if my 
<A HREF="#q2pt4">solution</A> is a little simpler
than yours.</P>


<H3><A NAME="section4">Other Uses for Substitution</A></H3>

<P>Despite the name, the <CODE><STRONG>:substitute</STRONG></CODE>
command doesn't always take something out of the line and put
something else in its place.  Here's an example that adds text at
the start of certain lines without removing anything:</P>

<PRE><STRONG>
537 , 542 substitute /^/WARNING:  /
</STRONG></PRE>

<P>so that text which originally looked like this:</P>

<PRE>
The primary output line carries very high voltage,
which does not immediately dissipate when power to
the system is turned off.  Therefore, after turning
off the system and disconnecting the power cord,
discharge the primary output line to ground before
servicing the output section.
</PRE>

<P>now looks like this:</P>

<PRE>
WARNING:  The primary output line carries very high voltage,
WARNING:  which does not immediately dissipate when power to
WARNING:  the system is turned off.  Therefore, after turning
WARNING:  off the system and disconnecting the power cord,
WARNING:  discharge the primary output line to ground before
WARNING:  servicing the output section.
</PRE>

<P>It's just as practical to pull some text out of lines without
putting anything back in its place.  Here are two command lines
that do just that:</P>

<PRE><STRONG>
% substitute / uh,//g
. , $ substitute / *$
</STRONG></PRE>

<P>The latter command removes superfluous spaces at the ends of
lines.  It doesn't need the final two slashes because there is no
suffix to be distinguished from a replacement pattern.</P>

<P>At times you might use both the previous principles, to create
<CODE><STRONG>:substitute</STRONG></CODE> commands that
neither subtract nor add any text.  Sound pointless?
Here's one such that I sometimes use
when I'm well along in writing one of these tutorials:</P>

<PRE><STRONG>
% substitute /^$
</STRONG></PRE>

<P>Now here's a different kind of exercise for you.  I've already
given you the command, above.  It obviously makes no change
whatsoever in the file.  So why do I run this command?  You need
a goodly dose of inspiration to answer this, so don't be
embarrassed if you have to look at my <A
HREF="#q3pt4">answer</A> to this one.</P>


<H3><A NAME="section5">A Start on Script Writing</A></H3>

<P>Already you know enough about the editor to be able to
plan some fairly complex edits.  Here's a short introduction
to the art of writing editing scripts for this editor.</P>

<P><STRONG>BOTTOM-UP PROGRAMMING</STRONG>. That's usually the
best way to build a complex editor command or command script.
That's a programmer's term that means putting all the little
details in separately and then pulling them all together into a
unified whole, rather than starting with a grand overall plan and
forcing the details to fit.</P>

<P>For example, reader R.T. of San Francisco, California asks how
to use the editor to automatically add HTML paragraph tags to
each paragraph of manuscripts.  This requires inserting the
string ``&lt;P&gt;'' at the start of the first line of each
paragraph, and the string ``&lt;/P&gt;'' at the end of the last
line.  In these manuscripts, a completely empty line (not even a
non-printing character on it) separates one paragraph from
another.</P>


<P>This looks pretty easy.  All that seems to be needed is to go
to each empty line, then move up to the preceding line to insert
the end-of-paragraph string and down to the following line to put
in the start-of-paragraph string.  But there are flaws in the
obvious command to do this:</P>


<PRE><STRONG>
global /^$/ - substitute :$:&lt;/P&gt;: | ++ substitute /^/&lt;P&gt;/
</STRONG></PRE>

<P>The first problem is that when the editor goes to the empty
first line that commonly begins a file, it will be unable to move
up a line to do the first substitution.  No substitution is
needed there, of course, but since the editor doesn't leave that
empty first line, moving down two lines will put it on the second
line of the following paragraph -- definitely the wrong place for
a start-of-paragraph tag.  There are several ways to fix this
problem:</P>


<OL>

<LI>Have the editor <CODE><STRONG>:mark</STRONG></CODE> the empty
line before leaving it to execute (or attempt to execute) the
first substitution.  Then it can go to the marked line (which
works even if the editor never left it) and drop down one line to
perform the second substitution.<BR><BR>

<LI>Change the address of that second substitution command from
``++'' to ``/./'' in order to move forward to the next nonempty
line, which will be the first line of the following paragraph
whether the search starts from the empty line or the line above
it.<BR><BR>

<LI>Run two separate <CODE><STRONG>:global</STRONG></CODE>
searches, each of which executes one of the two substitution
commands.<BR><BR>

</OL>

<P>Problem number two is that there may be several empty lines
between two paragraphs, since HTML interpretation is not affected
by them.  If the editor is on the first of two or more
consecutive empty lines, the command I first proposed above will
perform its second substitution on the second empty line just
below it.  When it moves to the second previously-empty line, it
will run the first substitution command on the empty line it just
left.  (Yes, the second line is no longer empty, but it has
already been marked by the <CODE><STRONG>:global</STRONG></CODE>
command before any substitutions are done.)  That is, a stretch
of text that initially looked like this:</P>

<PRE>
at this meeting, so be sure to be there!


At next month's meeting we'll hear from the new
</PRE>

<P>and should have been edited to look like this:</P>

<PRE>
at this meeting, so be sure to be there!&lt;/P&gt;


&lt;P&gt;At next month's meeting we'll hear from the new
</PRE>

<P>actually turns out like this:</P>

<PRE>
at this meeting, so be sure to be there!&lt;/P&gt;
&lt;/P&gt;
&lt;P&gt;
&lt;P&gt;At next month's meeting we'll hear from the new
</PRE>

<P>It may look as though this hazard can be defeated by
modifying the number two solution to the first problem above.
That is, the address for both substitutions will be a search
pattern that looks for a line that already has some text
on it.  This works properly when the editor is on the first
of two consecutive empty lines.  From the second line,
though, it runs its substitution commands on lines that have
already been given their tags, so the sample text now looks
like this:</P>

<PRE>
at this meeting, so be sure to be there!&lt;/P&gt;&lt;/P&gt;


&lt;P&gt;&lt;P&gt;At next month's meeting we'll hear from the new
</PRE>

<P><STRONG>COMPLEX CONDITIONALS</STRONG>. What's really needed
here is double-conditional execution.  That is, substitution
commands must run on a given line only if both of these
conditions are true:</P>

<UL>
<LI>The line to be substituted is adjacent to the empty line.

<LI>The line to be substituted is not itself empty.
</UL>

<P>In this case, the editor can handle it.  The
<CODE><STRONG>:global</STRONG></CODE> portion of the command line
takes care of the first condition if the substitution commands'
addresses move exactly one line in each direction from the empty
line.  (Of the three proposed solutions to the first difficulty
encountered, numbers one and three both do this much.)  To
satisfy the second condition, make the substitution commands
remove one character from the existing line -- and then replace
it, of course.  This ensures that if there is no character to
remove because the line is empty, the substitution command will
fail on that line and do nothing.</P>

<P>Either the first or third solution can be adapted to satisfy
that second condition.  I've used the third solution in the
example commands below, because the technique is easier to follow
than it would be with the first solution:</P>

<PRE><STRONG>
global /^$/ + substitute /^./&lt;P&gt;&amp;/
global /^$/ - substitute :.$:&amp;&lt;/P&gt;:
</STRONG></PRE>

<P>Bottom-up techniques can be continued if there are yet other
special needs to be accommodated.  Reader R.T. may have headlines
and subheads mixed in with the paragraphs, and may already have
appropriate HTML tags at the beginnings and ends of those heads
and subheads.  As an exercise, how would you adapt the commands
just above so they would not add a paragraph tag where any text
already begins or ends with an HTML tag?  Hint -- an HTML tag
always begins with a ``&lt;'' and ends with a ``&gt;'' character.
This is a very minor change, so you probably will not need to
look at my <A HREF="#q4pt4">solution</A> except
to confirm your own answer.</P>


<P><STRONG>A LITTLE TRICKERY</STRONG>. At times a command needs
to be supercharged by way of a far out use of 
substitution--something perfectly legitimate, but never intended
by the people who wrote this editor.  Here are a few that you may
find useful.</P>

<P>You can't make a substitution that extends over more than a
single line--not directly, that is.  Any attempt to put a
``newline'' character in either the to-be-replaced pattern or the
replacement pattern of a substitution command will fail.  But by
combining the <CODE><STRONG>global</STRONG></CODE> and
<CODE><STRONG>substitute</STRONG></CODE> commands, you can often
get the effect of a substitution that spills over a line
ending.</P>

<P>Let's suppose that you have to alter a long document so that
all references to ``Acme Distributors'' are changed to ``Barrett
and Sons''. A simple substitution command will make most of these
changes, but it will miss those instances where ``Acme'' appears
at the end of one line and the next line starts with
``Distributors''. A followup pair of substitutions, to replace
``Acme'' wherever it appears at the end of a line and to replace
``Distributors'' when it starts a line, would wreak havoc--this
document also refers to ``Acme Supply Co.''  and to three other
companies whose names end with ``Distributors''.</P>

<P>But we can handle this problem nicely with the following two
command strings:</P>

<PRE><STRONG>
global /Acme$/ + substitute /^Distributors/and Sons
global /^and Sons/ - substitute /Acme$/Barrett
</STRONG></PRE>

<P>The first command goes to every line that ends with ``Acme''
and then moves forward one line--if and only if that next line
begins with ``Distributors'', it is changed to begin with ``and
Sons''. The next command reverses the process to change ``Acme''
to ``Barrett'', but only in the right instances.  (Note well that
the second command searches for ``and Sons'', not
``Distributors'', because the first command has changed those
line-split ``Acme Distributors'' to ``Acme and Sons''.)</P>

<P>Often it is a good strategy to start with a change you
definitely don't want in order to wind up with what you do want.
Suppose you are a technical writer who has just finished writing
a number of lengthy photo captions full of phrases like ``the
light spot in the upper righthand corner'' and ``dark areas near
the lower lefthand edge''. Along comes the news that the Art
Director has decided to flop all the photos: print them in
mirror-image form.  Suddenly, everything that was on the right is
now on the left, and vice versa.</P>

<P>Your captions will be accurate again if you change every
``lefthand'' to read ``righthand'' and vice versa.  But how to do
that without wading through the whole text and making each change
individually?  The obvious pair of substitutions will not
work:</P>

<PRE><STRONG>
% substitute /lefthand/righthand/g
% substitute /righthand/lefthand/g
</STRONG></PRE>

<P>The second command doesn't just change the original instances
of ``righthand'' to ``lefthand''; it also reverses every change
your first command made--now everything is described as being on
the lefthand side.  But the following three substitution commands
will do the job nicely.</P>

<PRE><STRONG>
% substitute /lefthand/QQQQ/g
% substitute /righthand/lefthand/g
% substitute /QQQQ/righthand/g
</STRONG></PRE>

<P>By making the first command change ``lefthand'' temporarily to
``QQQQ'' (or any other string you know will not be found in your
document), you keep those changes safe from the effect of your
second command.  Then, after that second command has finished,
the third command changes those Q strings to what you had wanted
in the first place.</P>

<P>It can even make sense to type in things incorrectly, then
change them to what you want via substitution.  When I'm writing
documents in plain ASCII, to be printed without any formatting, I
often use a line across the page to separate major sections of
the document.  But where others are satisfied with just a string
of hyphens, or another single character, I pretty things up with
multicharacter dividers like:</P>

<PRE>
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

-+--+--+--+--+--+--+--+--+--+-

*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~

[][][][][][][][][][][][][][][]
</PRE>

<P>Not that I have the patience and concentration to type in
page-wide lines of alternating characters, especially when I would
have to constantly get on and off the shift key, too.  No, I just
use my repeat key to fill the line with whatever character will
begin my eventual multicharacter pattern.  For those four
patterns above, I would have repeat-keyed in these four lines,
respectively:</P>


<PRE>
------------------------------

------------------------------

******************************

[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
</PRE>

<P>Then I only have to run a simple repeated substitution to get
the line I actually want.  Here are the commands I would run on
the four lines above, respectively:</P>


<PRE><STRONG>
substitute /--/-=/g
substitute /---/-+-/g
substitute /\*\*/*\~/g
substitute /\[\[/[]/g
</STRONG></PRE>

<P><STRONG>SEMI-AUTOMATIC SUBSTITUTIONS</STRONG>.  At times
you'll have to make changes that are so dependent on human
judgment that no substitution tricks could possibly do exactly
what's wanted.  In those cases there are two ways to have the
editor partially automate those changes.</P>

<P><A NAME="target08">The first is to use a variant form</A> of the
<CODE><STRONG>substitute</STRONG></CODE> command that presents
each potential substitution on your screen, and asks you to
accept or reject it.  All you need to do is put a lower-case
``c'' at the end of your substitution command, in the same place
you would put a ``g'' to change every instance on each line, like
either of these examples:</P>

<PRE><STRONG>
% substitute /^something/something else/c
% substitute /something/something else/gc
</STRONG></PRE>

<P>The editor will then display the lines where substitutions are
to be made on your screen, one at a time.  Each line will have
``^'' marks below the text to be removed, like this:</P>

<PRE>
something in the air.  The consensus is that
^^^^^^^^^
</PRE>

<P>and if there are two or more places on the line where the
substitution could be performed, the line will be displayed on
your screen two or more times, with a different potential
substitution marked each time.. After displaying a line on your
screen, the editor will wait for you to type something ending
with a carriage return.  If whatever you type begins with a 
lower-case ``y'', the change will be made.  If it begins with
anything else, the text will be left as it is.</P>


<P>Even this substitution variant may not give you enough
control.  You may need to see more than one line to verify your
judgment, or the text to be put in may vary from one place to
another.  In those cases, you can use one of the qualities of the
<CODE><STRONG>:global</STRONG></CODE> command.  This is a
simplified version of the technique our programmer friend Hal (in
the first installment of this tutorial) used to work over the
problem points that Lint found in the code he was updating.</P>

<P>If you are editing in screen mode, as usual, you must start by
typing a capital ``Q'' to go into line mode.  From line mode's
colon prompt, give a command like the following (if you want to
make the same substitution as in our previous examples):</P>

<PRE><STRONG>
global /something/ visual
</STRONG></PRE>

<P><A NAME="feedback1-retn">This command</A> <A
HREF="#feedback1">will bring you in turn to each line</A> in the
file that contains the string ``something'' and put you in screen
-editing mode there.  After you've looked around, and made a
substitution if you think it justified, typing a capital ``Q''
takes you out of screen-editing mode and returns you to the
<CODE><STRONG>global</STRONG></CODE> command, which takes you the
next marked line and resumes screen editing.</P>



<P>There is an indirect <A HREF="#Q">hazard</A> in leaving screen
editing mode, though.  And that brings us to the whole dismal
subject of preventing loss of your changes, or of your entire
file, while you are in the editor.</P>


<H3><A NAME="section6">Don't Lose Your Files</A></H3>

<P>The vi/ex editor is not strong on protecting you from the
consequences of your own mistakes.  In part that's just the
natural result of giving you a lot of editing power.  But
when it comes to losing all the changes you've made in a file
during a session, or even losing the original file you started
with, the editor could be a lot more responsible without
hamstringing your subtle edits.  Still, there are ways you can
comfortably protect yourself from those hazards, and many of
those ways I explain below.</P>

<P><STRONG>IN EMERGENCIES</STRONG>. Consider one of the editor's
safety features that can accidentally but quite easily turn into
a disaster.  You may already know that when you edit with this
editor, you are working on a copy of the file, not the original.
Your changes do not affect the original unless you use the
<CODE><STRONG>:write</STRONG></CODE> command, for which
<CODE><STRONG>:w</STRONG></CODE> is the shortest abbreviation, or
leave the editor in a normal way.  That's a good precaution
against making a mistake with this powerful editor that mangles
your file, and then discovering you have no backup copy.</P>

<P>That copy you are working on lives in a volatile place,
though, where it can easily be erased when the system crashes or
your link into the system goes down.  That could cost you all the
additions and changes you'd made in that session with the editor.
Your first line of defense against this is to run the
<CODE><STRONG>:write</STRONG></CODE> command often--every time
you run it, your current edited version replaces the previous
version in the stable permanent-storage area on disk.</P>

<P>And if you don't intend to change the original?  Your edited
version is to be a new file, with the original left untouched?
Well, you can use a modified form of writing the file, by typing
<CODE><STRONG>:write nufile</STRONG></CODE> where ``nufile'' is
whatever you want the name of the edited file to be.  (That can
be a path name, in case you don't want to put the new file in
your current directory.)  This will write the revised version
only to the new file (creating the file if necessary), and leave
the original file untouched.</P>

<P>That method of preserving the original file is dangerous,
though.  If you forget even once to add the filename to the
<CODE><STRONG>:write</STRONG></CODE> command, your original file
is wiped off the disk.  That's why this technique is best
reserved for occasions where you do want to change the original
file, but also want a copy of some partially edited stage of the
file saved elsewhere.  When you get the file to the state you
want to save as a copy, run both of these commands:</P>

<PRE><STRONG>
write nufile
write
</STRONG></PRE>

<P>and then go back to editing and writing to the file as usual.</P>

<P>The sane way to protect your original file from any changes is
to start your editing with a <CODE><STRONG>:file
nufile</STRONG></CODE> command, for which <CODE><STRONG>:f
nufile</STRONG></CODE> is the shortest abbreviation.  From that
point on, the editor considers ``nufile'' to be the name of the
file you are working on, and writes go automatically to that
filename.  (Incidentally, if you ever forget whether you have
changed the file name, or what you've changed it to, a
<CODE><STRONG>:file</STRONG></CODE> command by itself, without a
file name, will tell you what the editor thinks the file's
current name is, among other interesting facts.)</P>


<P><STRONG>CRASHES WILL HAPPEN</STRONG>. Still, a crash may catch
you by surprise, with a lot of additions and changes that you
have not written to any file..  To protect against this, the
editor always attempts to save your current working copy of the
file when a crash is imminent.  You can even launch an emergency
save yourself when you face a sticky situation, such as being
unable to do a normal write because it would exceed your
filespace quota.  Just type a
<CODE><STRONG>:preserve</STRONG></CODE> command (or its
<CODE><STRONG>:pre</STRONG></CODE> abbreviation) and the working
copy is normally preserved.  There are a few gotchas to watch
for, though.</P>

<P>The preservation function puts the saved copy in a specific
directory, and it will fail if that directory does not exist or
is not writable.  (The path name of that directory varies
between versions of the editor, although
<CODE>/var/preserve</CODE> seems to be a common choice on modern
Unix systems.)  To check writability, run a
<CODE><STRONG>:preserve</STRONG></CODE> command from a short
file, as a test.  If the result is a message something like
this:</P>

<PRE>
Can't open /var/preserve
Preserve failed!
</PRE>

<P>there is a problem you will have to take up with your system
administrator.  (To speed up that discussion, bring along the
path name of the directory that couldn't be opened.)  If the
message reads like this:</P>

<PRE>
File preserved.
</PRE>

<P>so far, so good.  The next question is whether the editor has
preserved an accurate copy or a pile of garbage--some editor
implementations are broken in this area.  To check this, recover
the file you've just preserved.</P>

<P><STRONG>RESCUING SAVED FILES</STRONG>. There are two ways to
recover a rescued working copy, whether it was saved in a crash
or because you used the <CODE><STRONG>:preserve</STRONG></CODE>
command.  Usually you recover it from your shell command line, by
entering the editor with a ``-r'' flag:</P>

<PRE><STRONG>
vi -r novel.chap3
vi -r
</STRONG></PRE>

<P>The first of these commands puts you in the editor, with the
latest rescued copy of your file ``novel.chap3'' before you.  The
latter command doesn't put you in the editor at all; it displays
a list of all files that have been emergency-saved and then
returns you to the shell command line.  This list is useful when,
say, the system crashed while you were editing a file that you
hadn't given a name.  (Yes, you can enter the editor without
giving a filename to edit; the editor will simply bring up an
empty buffer and assume you will give it a name later.)  In this
case the preservation process will give the file a name, and you
must know this name to recover it.</P>

<P>I said that the first command would bring up the
<EM>latest</EM> rescued copy of the file you named.  If the
system has been staggering for a while, there may be more than
one occasion when either you or the system caused the editor to
preserve the working copy of that file.  If the latest version is
not the best copy, you can discard it and pull up the next most
recent version, without leaving the editor.  Just give a
<CODE><STRONG>:recover</STRONG></CODE> command (or its
<CODE><STRONG>:rec</STRONG></CODE> abbreviation) to have the
current rescued version discarded and replaced by the next-latest
of the saved copies.  (When you're already in the editor, there's
no need to give the name of the file to recover if it is the same
as that of the file you're editing at the time.  The editor
assumes the current filename unless you give another name as an
argument following the <CODE><STRONG>:recover</STRONG></CODE>
command.)  If this isn't the best copy either, you can continue
this process.</P>

<P>When you've recovered a file either way, look it over.  If the
editor version you're using has a broken preservation function,
you'll only find garbage characters or a display like this:</P>

<PRE>
LOST
LOST
LOST
LOST
LOST
</PRE>

<P>If that be the case, the file you preserved is hopelessly lost
and you'd better have a talk with your system administrator about
getting a better version of the editor.  But if what you see
looks like what you had, then all you have to do is write the
copy you've recovered to a file somewhere--the preserved copy was
erased when you used one of the recovery commands, so it can't be
recovered that way again.</P>

<P>And that brings up the last gotcha.  You may believe that any
of the three commands <CODE><STRONG>ZZ</STRONG></CODE> or
<CODE><STRONG>:x</STRONG></CODE> or
<CODE><STRONG>:wq</STRONG></CODE> will check whether the working
copy needs to be written to the file, write it only if necessary,
and then quit the editor.  Actually, the last of the three, the
<CODE><STRONG>:wq</STRONG></CODE> command, always writes to the
file regardless, and is the only one you should use.</P>

<P>The first two attempt some checking, but their checks are not
very complete.  In particular, they and the
<CODE><STRONG>:quit</STRONG></CODE> command often check for
nothing more than the flag that is set when an editing change is
made to the current working copy and unset when the working copy
is written to the file.  You are courting disaster if you ever
use the <CODE><STRONG>ZZ</STRONG></CODE> or
<CODE><STRONG>:x</STRONG></CODE> commands, or if you use
<CODE><STRONG>:quit</STRONG></CODE> carelessly.</P>

<P>The gotcha in the case of a recovered file is that pulling a
new file into the buffer, whether normally or by recovering an
emergency-saved copy, is not an editing change.  If your version
of the editor has a weak version of <CODE><STRONG>ZZ</STRONG></CODE> 
or <CODE><STRONG>:x</STRONG></CODE> then its casual check will
show no reason to write the file, and all your carefully
recovered work will be lost for good when the command closes the
editor without writing the file.  So always use
<CODE><STRONG>:wq</STRONG></CODE> or separate
<CODE><STRONG>:write</STRONG></CODE> and
<CODE><STRONG>:quit</STRONG></CODE> commands to end an editing
session.</P>


<P><STRONG>A FEW MORE HAZARDS AND SOLUTIONS</STRONG>. <A
NAME="Q">Worse yet</A> can befall you.  You may accidentally lose
both your own editing changes and the original file you were
working from.</P>

<P>Suppose one of your global editing commands went astray and
trashed your working copy of the file, but didn't happen to
affect the part that is on your screen.  If you then wrote the
working copy to the file, the garbage replaced your original file
contents.  Oh, misery!  And with any but the smallest file, it's
not practical to look over the working copy carefully before each
<CODE><STRONG>:write</STRONG></CODE> command.</P>

<P>Or perhaps you did discover the disaster before you wrote the
working copy to the file.  Seeing that undoing the errors was not
feasible, you decided either to run an
<CODE><STRONG>:edit!</STRONG></CODE> command to bring up a fresh
copy of the original file, or a
<CODE><STRONG>:quit!</STRONG></CODE> to leave the editor.  In
either case, the ``!'' at the end of the command tells the editor
to ignore the garbage changes that have not been written to the
file.</P>

<P>But since you were not creating an editor script here, you
probably typed the short form of your command, either
<CODE><STRONG>:e!</STRONG></CODE> or
<CODE><STRONG>:q!</STRONG></CODE>. At least you tried to.
Perilously placed between the ``e'' and ``q'' keys on a standard
keyboard is the ``w'' key.  If you accidentally typed
<CODE><STRONG>:w!</STRONG></CODE> instead of what you intended,
you told the editor to overwrite the original file with that
trashed version, and ignore any anti-write protections you may
have set.  Oh, misery cubed!</P>

<P>You are not lost yet, though, if you have been editing along
in screen mode all the while.  At any time you can type a short
sequence to put the working copy back the way it was when you
started this editing session.  Then you only need to write the
working copy to the file to expunge the trash there.</P>

<P>Start by typing <CODE><STRONG>Q</STRONG></CODE> to leave
screen mode and drop back to line mode.  Now, line mode has an
<CODE><STRONG>undo</STRONG></CODE> command that works the way the
screen mode <CODE><STRONG>u</STRONG></CODE> command does, but on
line mode commands.  That is, it reverses the effect of the
latest line mode command that changed (or may have changed) the
working copy.  One line mode command that may well change the
working copy is <CODE><STRONG>visual</STRONG></CODE>, of course.
And -- surprise -- when you typed <CODE><STRONG>vi
novel.chap3</STRONG></CODE> from your shell prompt to enter the
editor, your shell actually launched
<CODE><STRONG>ex</STRONG></CODE> (for which
<CODE><STRONG>vi</STRONG></CODE> is just an alias) and the editor
gave itself an initial <CODE><STRONG>visual</STRONG></CODE>
command to boost you into screen mode.</P>

<P>So all the time you've been editing, the editor has been
holding a complete copy of the original file, in case you go back
to line mode and want to reverse the effect of that initial
<CODE><STRONG>visual</STRONG></CODE> command.  (That's one reason
the editor's buffer takes up so much more room than you'd expect
in swap space.)  If you want to see the complete command sequence
to restore the original working copy and return to visual mode,
using shortest abbreviations and showing carriage returns as new
lines, here it is:</P>

<PRE><STRONG>
Qu
w
vi
</STRONG></PRE>

<P>One last hazard, which may seem childish to experienced Unix
users but trips up many a refugee from single user systems.
Unless you're on one of those rare Unix implementations that
offers file locking, there is little to prevent another user on
the system from editing the same file at the same time as you
do.</P>

<P>You will each be editing on a separate working copy, so there
will be nothing to tell you that someone else is also editing the
same file.  But each time you write your changed version to the
file, you will wipe out whatever changes the other user has
already written to file, and vice versa.  The ultimate victor in
this unknowing war will be the user who finishes editing last.
The other user can come back an hour later and find no indication
that he/she ever touched the file.</P>

<P>There's no real technical solution to this danger.  You'll
just have to coordinate carefully with other users on files
that more than one of you may have occasion to edit.</P>


<H3><A NAME="feedback">Reader Feedback</A></H3>

<P><A NAME="feedback1">One of our readers</A> raised a
significant point about <A HREF="#feedback1-retn">this
technique</A>; important enough to deserve a reply published in
this article.</P>

<PRE>
Dear Walter...

In your tutorial you write that you can use the command

global/XXX/visual

to search for the pattern "XXX" and edit/move around (remember,
Hal needed this command to edit the linted spaghetti-code...)

But there's one problem: suppose I found, after the 10th XXX of
100, that I do not want to view the remaining 90 occurences.  It
works as long as I don't type 'Q'. But now I want to view/edit
the code where my lint report is something like "illegal", I have
to type Q and then global/illegal/visual.

And now there's the problem: typing Q doesn't prompt for a new
input, it moves to the 11th occurence of "XXX".

Do you know my problem?  Is there a way to stop vi moving on with
the global command after typing Q?

Thanks a lot in advance!

Chris...
</PRE>

<P>As Chris clearly realizes, ordinarily there is no problem with
omitting the remaining 90 stops.  Each time this command puts you
into visual mode somewhere in the file, you are not restricted to
fixing one limited problem.  You may move anywhere in the file,
edit whatever you like, and keep doing this as long as you
please.  When you finally finish all the edits you've decided to
do, you can write the file and quit the editor in your usual 
way--the suspended <CODE><STRONG>global</STRONG></CODE> command
will silently disappear at this point.</P>

<P>But going into a second string of
<CODE><STRONG>visual</STRONG></CODE> mode stops from a new
<CODE><STRONG>global</STRONG></CODE> command, as Chris wants to
do, requires finesse.  Obviously, it's not possible to use the
<CODE><STRONG>Q</STRONG></CODE> command to return to the 
line-mode command prompt until every one of those 100 lines has
been visited and the first <CODE><STRONG>global</STRONG></CODE>
has terminated.</P>

<P>The best way out of this predicament starts with writing your
changes to the file.  Then, instead of typing
<CODE><STRONG>Q</STRONG></CODE> type an
<CODE><STRONG>:edit</STRONG></CODE> command.  This brings up a
fresh copy of the file you are editing, but since you've just
done a write, the fresh copy is identical to the one you've been
working on.  Because you haven't left the editor, most of the
state is saved--contents of the named buffers, any maps and/or
abbreviations, values of the <CODE><STRONG>set</STRONG></CODE>
command options.  You do wipe out a few small items like the
contents of the unnamed buffer--and, of course, that suspended
<CODE><STRONG>global</STRONG></CODE> command.</P>

<P>Now you can use the <CODE><STRONG>Q</STRONG></CODE> command to
go into line mode, then run that second
<CODE><STRONG>global</STRONG></CODE> command.</P>


<H3><A NAME="next">In The Next Installment</A></H3>

<P>In this tutorial to date, you've undoubtedly seen some aspects
of the editor that you wish had been designed differently.  The good
news is that many of these features are yours to change at
will--without hacking up the source code and recompiling.</P>

<P>In Part 5 of this tutorial</A>, I'll elucidate
the editor's built-in facilities for setting up your own editing
environment, and the many factors you can modify this way.</P>

<HR>
 
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 5</H1>

<P><A HREF="/uworld/copyrights/bsd-daemon.txt">



<H2>Take Control of Your Editing Environment</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter Alan
Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>

<UL>

<LI><A HREF="#section1">The <CODE><STRONG>set</STRONG></CODE>
Command</A></LI>

<LI><A HREF="#section2"><CODE><STRONG>set</STRONG></CODE>
Command Variables that Control How to Paint the Screen</A></LI>

<LI><A HREF="#sectionT">Playing ``tag''</A></LI>

<LI><A HREF="#sectionL">Making Your Environment Setup Automatic</A></LI>

<LI><A HREF="#next">The Next Installment</A></LI>

</UL>


<P>Besides all the power in the Vi/Ex editor, there's a lot of
flexibility in it, too.  You've already met some of this
adaptability when I pointed out various ways to perform many
editing functions.  Now it's time to meet phase two of editor
flexibility -- the myriad ways to modify the editor's internal
operations.</P>

<P>There's no ``setup mode'' for changing these parameters.
Instead, all the changes are made with line-mode commands, which
can be interspersed with ordinary editing commands.  That is, you
give the commands from the prompt, as usual, if you are editing
in line mode.  When you are editing in visual (or screen) mode,
precede these environment-modifying commands with a colon, as you
would with any other line-mode commands you specify in visual
mode.</P>

<P>These modifications take effect as soon as you give the
commands.  They stay in effect as long as you run the editor
program.  You can switch from editing one file to another -- as
with any of the <CODE><STRONG>edit, next, rewind</STRONG></CODE>
commands -- without affecting the editing environment you've set
up.  And, you can revoke or further modify any environmental
changes you've made at any time, by using the same commands or
variant forms of them.</P>

<P>Your environment setup does go away when you quit the editor
altogether.  The next time you invoke the editor you'll find that
all the environment parameters have returned to their default
values.  (This can be a blessing in disguise, because there is no
direct way to tell the editor to restore all parameters to
default settings.)</P>

<P>When you've found a combination of settings you'd like to use
again, there are ways to have these settings established
automatically (or semi-automatically) whenever you invoke the
editor.  You can even have several of these preset environments -- 
which one is used will depend on the circumstances in which you
invoke the editor.  I'll explain how to automate the settings at
the end of this tutorial.</P>

<H3><A NAME="section1">The <CODE><STRONG>set</STRONG></CODE>
Command</A></H3>

<P>Most of your setup will be accomplished by a single command
that controls around fifty editor variables that affect the
editing environment.  The <CODE><STRONG>set</STRONG></CODE>
command, for which <CODE><STRONG>se</STRONG></CODE> is the
shortest abbreviation, sets variables having three different
types of values: string, numeric, and boolean.  Consider the
examples here:</P>

<PRE><STRONG>
set report=7
set term=vt100
set terse
set nomagic
</STRONG></PRE>

<P>Because the first two examples are assignments, they must
specify either string or numeric values.  The first is numeric;
here, <CODE><STRONG>report=7</STRONG></CODE> tells the editor to
give you a report (warning message) whenever a command changes
seven or more lines -- the default is five or more lines.</P>

<P>The second example assigns a string value; the numerals
in it are regarded as merely characters by the editor.  The
<CODE><STRONG>term=vt100</STRONG></CODE> directive tells the
editor to address your terminal as though it were a DEC model
VT100.  (You specify one of the listed short names for the terminal -- 
obtained from the Termcap or Terminfo terminal-description
systems -- as its string value.)  The default for this variable
is to use the terminal type from your log-in shell environment
(the value assigned to your <CODE>TERM</CODE> variable), if
available -- and if not available, then address your terminal as
though it were a ``dumb'' terminal.</P>

<P>The last two examples (without equal signs) illustrate boolean
variables, which can be either on (enabled) or off (disabled). You
turn a boolean variable on just by giving its name after the
<CODE><STRONG>set</STRONG></CODE> command.  The first of these
two boolean examples tells the editor to make any error messages
very brief: cryptic to inexperienced users, but convenient for
people who are quite familiar with the editor.  The default for
this variable is ``off'' or ``disabled'', which provides longer,
more explanatory error messages.</P>

<P>To turn a boolean variable off, just give its name prefixed by
the string ``no'' without any intervening space characters.  The
last of these examples turns off the special (``magic'')
interpretation of several metacharacters, as discussed in <A
HREF="009.part1.html#section3">an earlier part of this
tutorial dealing with search patterns</A>.  The usual default for
this variable's value is ``magic'', which means all
metacharacters have their special interpretation -- but if you
invoke the editor by the name <CODE><STRONG>edit</STRONG></CODE>
or <CODE><STRONG>vedit</STRONG></CODE>, then ``nomagic'' is the
default value (no special interpretation of these particular
metacharacters).</P>

<P>There's no need to use several distinct
<CODE><STRONG>set</STRONG></CODE> commands when you want to
change a number of these variables.  A single command can have
almost any number of arguments.  So all four of the example
commands above could be replaced by this single command:</P>

<PRE><STRONG>
set report=7 term=vt100 terse nomagic
</STRONG></PRE>

<P>Variant forms of this command will tell you the present status
of individual variables, all that have been changed, or all the
variables.  For instance, type ``set'' without any arguments to
tell the editor to display a list of all the variables that have
been changed from their default values, along with their current
values.</P>

<P>Type ``set all'' to display all the variables and their
values, whether changed from default or not.  This is a good way
to check which variables your version of the editor recognizes,
and what their default values actually are -- some proprietary
versions of the editor have played with both these factors.</P>

<P>If you want to check the values of only one or a few variables,
you don't have to scan through a long list -- you can run a
<CODE><STRONG>set</STRONG></CODE> command that will report the
settings of only the variables you specify.  For a boolean variable,
just give the name of the variable, immediately followed by a
question mark, as an argument to the command.  For a string- or
numeric-valued variable, you only need to specify the name itself,
without the equal sign.  Thus, typing:</P>

<PRE><STRONG>
set report magic?
</STRONG></PRE>

<P>will produce a response like this:</P>

<PRE>
report=7 nomagic
</PRE>

<P>If the details of checking individual variables seem too arcane
to remember, the editor will cut you some slack: You may specify
the name of a boolean variable in its ``no'' form, and you may give
a non-boolean variable with an unneeded question mark at the end of
it, and your query will still work.  So typing:</P>

<PRE><STRONG>
set report? nomagic?
</STRONG></PRE>

<P>will produce the same result as the previous query did.</P>

<P>You can even mix option settings with inquiries in the same
<CODE><STRONG>set</STRONG></CODE> command, in any order.  For
example, if you want to turn on
<CODE><STRONG>number</STRONG></CODE> and set
<CODE><STRONG>report</STRONG></CODE> to warn you whenever even
three lines are changed, and also want to know what terminal type
the editor thinks you are using and whether
<CODE><STRONG>terse</STRONG></CODE> is on or off, any one of the
following command lines will take care of it all:</P>

<PRE><STRONG>
set number report=3 term terse?
set term terse? number report=3
set term number terse? report=3
</STRONG></PRE>

<P>Below, I've listed some important editor variables that modify
the visual display, with an explanation of each.  If two names
are specified, the first is the full name and the other is the
shortest recognized abbreviation.  The full name will appear in
the lists displayed when you type ``set'' by itself or type ``set
all''.</P>


<H3><A NAME="section2"><CODE><STRONG>set</STRONG></CODE> Command
Variables that Control How to Paint the Screen</A></H3>


<H4><CODE>number nu</CODE></H4>

<P>You already know that the editor assigns a number to every
line in your file, and changes line numbers every time you add or
delete lines, in order to keep the numbers consecutive.  The
<CODE><STRONG>number</STRONG></CODE> boolean variable tells the
editor to display those line numbers next to every file line that
appears on the screen, in both screen and line-editing modes.
You just have to turn it on; it's off by default.  If you have a
window that looks like this:</P>

<PRE>
COLOR CODING FOR POWER WIRES
green     ground
white     neutral
black     hot
red       hot
</PRE>

<P>turning on this variable will make it look something
like this:</P>

<PRE>
  158  COLOR CODING FOR POWER WIRES
  159  green     ground
  160  white     neutral
  161  black     hot
  162  red       hot
</PRE>

<P>The displayed numbers do not become part of the file, and
nothing you can do, deliberate or accidental, will cause your
editing to interact with the line numbers.</P>


<H4><CODE>list</CODE></H4>

<P>Turning on this off-by-default variable makes two changes
in the way file lines are displayed on the screen, whether in
line- or screen-editing mode:</P>

<OL>

<LI>The end of each line is marked by a dollar sign.  (This
applies to actual line ends, not to places where the editor wraps
a long line so it can all be displayed on the screen.)</LI><BR><BR>

<LI>Every tab character is replaced by a circumflex-capital-I
(``^I'') character sequence.  (This means that columns that were
kept in alignment by preceding tabs will not be displayed aligned
with this variable enabled.)</LI>

</OL>

<P>Taking the same sample screen as in the previous example, when
the <CODE><STRONG>list</STRONG></CODE> variable is on, the screen
would look like this:</P>

<PRE>
COLOR CODING FOR POWER WIRES$
green^Iground$
white^Ineutral$
black^Ihot$
red^Ihot$
</PRE>

<P>This variable affects display only, the contents of the file
are not changed in any way.  The <CODE><STRONG>list</STRONG></CODE> 
and <CODE><STRONG>number</STRONG></CODE> variables are compatible.  
Enabling them both would produce a display like this:</P>

<PRE>
  158  COLOR CODING FOR POWER WIRES$
  159  green^Iground$
  160  white^Ineutral$
  161  black^Ihot$
  162  red^Ihot$
</PRE>


<H4><CODE>window=</CODE></H4>

<P>The numeric value of this variable tells the editor how many
screen lines should be in the editing window (in screen-editing
mode). The default is one less than the size of your screen or
window.  This variable's value cannot be changed while you are in
screen-editing mode.</P>


<H4><CODE>scroll</CODE></H4>

<P>A numeric variable that sets the number of lines to be
scrolled down by a control-D or up by a control-U command.  The
<CODE><STRONG>z</STRONG></CODE> command uses twice this count as
the number of lines to display.  Default value is half the size
of the screen or window.</P>

<P>You can give a count prior to one of those scrolling commands,
which will override the value of the
<CODE><STRONG>scroll</STRONG></CODE> variable.  For example,
typing ``3control-D'' will scroll forward just three lines.</P>

<P><EM>Caution:</EM> The editor will remember any count you give,
and use that count -- instead of the value assigned to
<CODE><STRONG>scroll</STRONG></CODE> -- with any future command
you give without specifying a new count.  Because the value of
the <CODE><STRONG>scroll</STRONG></CODE> variable remains
unchanged, even though it is no longer being used, the
<CODE><STRONG>set</STRONG></CODE> command has no way to undo this
new behavior.  The only way to go back to using the value set for
<CODE><STRONG>scroll</STRONG></CODE> is to look up that value --
type ``set scroll'' -- then use this value as a count preceding
another of the commands that normally use the
<CODE><STRONG>scroll</STRONG></CODE> variable.</P>


<H3><A NAME="sectionT">Playing ``<CODE>tag</CODE>''</A></H3>

<P>If your editing work requires jumping from place to place in
numerous files, it would be convenient to index the places you
visit most.  The editor has a system for handling this.  It's
pretty simple, too; you set up one or more reference lists, then
you can go to the place within the file that you want just by
typing a few characters.</P>

<P><EM>Caution:</EM> the ``tags'' system described below does
not simply switch focus briefly to another file.  It ends
your editing of the current file, then loads the new file into
the editor with the standard context changes, just as if you
had given an <CODE><STRONG>edit</STRONG></CODE> command.  As
a consequence of this, the editor will normally refuse to execute
a <CODE><STRONG>tag</STRONG></CODE> command when the file you are
presently editing has changes which you have not yet written to
permanent storage.  If you choose to override this protection,
give the command as <CODE><STRONG>tag!</STRONG></CODE> or
<CODE><STRONG>ta!</STRONG></CODE>.</P>

<P>To use this system, you need to set up at least one ``tags''
file containing references to your file destinations.  If
programming is your work and you use C, C++, Pascal,
FORTRAN, lex or yacc, the Unix <A
HREF="/uworld/man/ctags.1"><CODE><STRONG>ctags</STRONG></CODE></A> 
utility can set up a suitable ``tags'' file for you.  If not,
it isn't all that difficult to build such a file yourself.</P>

<P>Each line in a ``tags'' file is a complete reference to a
place you might want to go.  The line has five parts, which
(reading from left to right) are:</P>

<OL>

<LI>The short name you will use to refer to the particular file
and the place in it.  Don't start choosing names, though, until
you've read the <A HREF="#third-way">third way to invoke a
tag</A>, below.</LI><BR><BR>

<LI>One tab character, as a separator.  A space character will
not do here.</LI><BR><BR>

<LI>The name of the destination file.  This can be a simple name,
if the file is in your current directory, or a path name, if
not.</LI><BR><BR>

<LI>Another tab character.  Again, a space character won't do.</LI><BR><BR>

<LI>A line-mode search command that will find the place you want
within the file.  As you may have cleverly deduced, you can
string multiple commands together here with the vertical-bar
(``|'') character, and can use editing commands if you want the
file pre-edited.  Spaces and even tabs may appear in this string
if needed; only the first two tabs in a line are interpreted as
field separators.</LI>

</OL>

<P>If this file structure sounds a little complex, look at this
short example of a ``tags'' file to see how things actually
work out:</P>

<PRE><STRONG>
difid   ../math/calc    /^APPENDIX/;/^C. Differen
integ   ../math/calc    /^APPENDIX/;/^D. Integrals
log     /adm/err-log    1;?Err-7$
rvlog   /adm/err-log    g/^/m0|0;/Err-7$
vocab   %      /^GLOSSARY
words   %      /^GLOSSARY
</STRONG></PRE>

<P>The first line in the example above provides that using
``difid'' as a tag will take the user to edit a file named
``<CODE>calc</CODE>'', in a directory with relative path name
``<CODE>../math</CODE>''. (<EM>Note:</EM> that using this tag
will not change the current directory of the user's shell; only
the file being edited is changed.)  Once that file has been
loaded, the editor will seek out the first line that starts with
``APPENDIX'', and go from there to the next line that begins with
``C. Differen''.</P>


<P>Yes, you can specify different tags to enter the same file at
different points.  My second example line contains a tag that leads
to a different place in the same file.  After the editor has
searched out the first line beginning ``APPENDIX'', as before, it
goes on to a different section of the appendix.</P>

<P>You can even use multiple tags to enter the
file at the same point, but with different preliminary
editing.  My ``log'' and ``rvlog'' tags go to the same file and
the same line -- the most recently appended line that ends with
``Err-7''.  The difference is that the ``rvlog'' tag first
reverses the order of lines in the file.  (Note that the search
command for the two tags is different, because in the second
case the line being sought has been moved to a different
position in the file.)</P>

<P>And you can use a tag to move to a place in the file you are
already editing.  In the last two example lines I have used the
percent sign (<CODE><STRONG>%</STRONG></CODE>) to indicate
``current file''; the pound-sign (<CODE><STRONG>#</STRONG></CODE>) 
for ``alternate file'' is also acceptable.  These tags move the
user to the glossary section of the document currently being
edited, whatever that document may be.  If I were to invoke a
tag with an actual file name in it, and that file happened to be
the file I was presently editing, the effect would be the
same.</P>

<P>Finally, you undoubtedly saw that the last two entries in my
tags file are identical except for the tag names.  Either tag
will take you to the same place in the same file with no
preliminary editing.  This is legitimate, and often useful.
You may be building a tag file for multiple users -- some of
these users are accustomed to a certain tag name for a given
file and location, some to another tag name.  The tags system
allows you to accommodate both groups.</P>

<P>You may have noticed that the lines in my example file are
arranged in ASCII-sort order.  This is necessary to keep the
tag-search mechanism from missing the tag you specify.
If you don't trust your own ability to sort the lines, the Unix <A
HREF="/uworld/man/sort.1"><CODE><STRONG>sort</STRONG></CODE></A>
utility can do it for you.</P>

<P>When you've built your ``tags'' file, you need a place to put
it.  Ordinarily, when you invoke a tag name, the editor first
tries to look it up in a file named ``<CODE>tags</CODE>'' in your
current directory.  If it fails to find such a file, it then
looks for <CODE>/usr/lib/tags</CODE>.  But you can override these
defaults by setting a different value for the ``tags'' file in
your editing environment.  For instance, if you include this
command in your setup file:</P>

<PRE><STRONG>
set tags=moretags
</STRONG></PRE>

<P>then tag searches will take place in a file named ``moretags''
in your current directory.</P>

<P>With everything set up, you only need to know how to invoke a
tag as needed.  There are three or four ways to do it, all
enumerated below:</P>

<OL>

<LI><P>When you invoke the editor from your shell's command line
you can use the ``-t'' command-line option flag to specify a
tagged item instead of naming a file to edit.  For example,
typing the line (from your shell prompt):</P>

<PRE><STRONG>
vi -t chap3
</STRONG></PRE>

<P>tells the editor to look up the ``chap3'' tag to find the
destination file and location in that file.  Oddly enough, you
can list some file names to edit as well as a tag (with ``-t'') on
the editor-invocation command line.  The rule is that the first
string of non-whitespace characters immediately following the
``-t'' flag is regarded by the editor as a tag name; any other
such strings that don't begin with a ``-'' character are taken
as actual names of files.  However, the tagged and the
named files aren't remembered the same way in this case.</P>

<P>For instance, if you specify a tag, then two file names,
the editor will initially place you
in the tagged file and when you type
<CODE><STRONG>:next</STRONG></CODE> you will move to the first
named file, and another <CODE><STRONG>:n</STRONG></CODE> (the
shortest abbreviation) takes you to the second named file.  But,
the tagged file does not appear on the argument list -- viewed
with the <CODE><STRONG>args</STRONG></CODE> command -- so when you
enter a <CODE><STRONG>:rewind</STRONG></CODE> command you return
to the first named file, not the tagged file, even though it was
specified first on the command line.</P></LI>

<LI>While you are editing a file, you can invoke a tag with the
line-mode command <CODE><STRONG>tag</STRONG></CODE> (shortest
abbreviation, <CODE><STRONG>ta</STRONG></CODE>) followed by a
space and the tag name.  This command can be given from screen
mode as <CODE><STRONG>:tag</STRONG></CODE>, of course.</LI><BR><BR>

<LI><P><A NAME="third-way">While you are in screen mode, you can
put the cursor on either the first letter of a word or the space
immediately preceding it and then type a ``control-]'' character.
This has the same effect as if you'd typed the word the cursor is
at as the argument to a <CODE><STRONG>:tag</STRONG></CODE>
command.</A></P>

<P><EM>Caution:</EM> A ``control-]'' is the default Telnet
``escape'' character.  So if you are editing on a remote system
during a Telnet session and enter a ``control-]'', control will
return to Telnet, which will interpret what you type next as a
Telnet command.  You could change the Telnet escape character
when you start your remote terminal session in order to use
``control-]'' with the editor.</P></LI>

<LI>Some newer versions of the editor maintain a stack of tags.
If so, you can repeat the last
<CODE><STRONG>:tag</STRONG></CODE> command you gave in screen
mode by typing ``control-T''. This can take a count, so that
typing a ``2'' and then a ``control-T'' repeats the
<CODE><STRONG>:tag</STRONG></CODE> command preceding the last one
you gave, etcetera.</LI>

</OL>

<H3><A NAME="sectionL">Making Your Environment Setup Automatic</A></H3>

<P>When you've worked out an editing environment setup that you
will want to use frequently, or even occasionally, there is no
need to type in all the changes from default every time you start
up the editor.  Because these are all line-mode editor commands,
there are several ways to define them automatically, all or some
of the time.</P>

<P>If there is an editor start-up file (which must be named
<CODE>.exrc</CODE>) in your home directory (the dot at the start
of the name is essential and the ``rc'' abbreviation means ``run
command''), the editor will interpret it every time you invoke
the editor and execute (or at least attempt to execute) the lines
in the file as line-mode commands before it turns editing control
over to you.  This applies to environment-setting commands as
well as others, so placing your set-up commands somewhere in this
file will cause the setup to happen every time you invoke the
editor.</P>

<P>There are drawbacks to this approach, though.  You can only
have one environment preset this way: the editor will use that
same environment every time you invoke the editor.  One way to
provide more flexibility is to maintain several files with
various setups in them, and before you enter the editor, rename
the appropriate one of those start-up files to <CODE>.exrc</CODE>
and when you leave the editor, restore its original name.  But
you shouldn't have to deal with anything this cumbersome just to
control your editing environment.</P>

<P>The creators of the editor have provided a much better
solution.  Before the editor looks in your home directory for a
start-up file, it first looks in the directory from which you
invoked the editor.  If it finds a file named <CODE>.exrc</CODE>
there, it interprets that as the start-up file instead of the
<CODE>.exrc</CODE> file in your home directory.</P>

<P>That behavior lets you have a special setup for each directory
in which you might want to do some editing.  For instance, let's
say you have a directory of shell scripts, another containing
chapters from a book you're writing, still another you use for
writing e-mail, plus one where you store and edit error logs --
you can have a separate editing environment for each of these
purposes.  And if you invoke the editor from a directory where
you don't maintain a separate start-up file, the one in your home
directory will be used.  Just remember to change to the directory
where the target file(s) are located before invoking the editor.</P>

<P><EM>Caution:</EM> If you invoke the editor from a directory
different from the one containing the file you're editing,
the editor will interpret the start-up file from your start-up
directory, and not use the intended environment (defined by the
<CODE>.exrc</CODE> file in the directory where the target file
resides).</P>

<P>One caveat about multiple <CODE>.exrc</CODE> files, though.
In Unix System V and its successors, a security feature restricts
the editor's access to <CODE>.exrc</CODE> files that are not in
your home directory.  The editor will not interpret a
<CODE>.exrc</CODE> file that's not in your home directory, unless
you also have a <CODE>.exrc</CODE> file that does live in your
home directory, and that file contains a line that sets the
<CODE>exrc</CODE> boolean variable.</P>

<P>The security hazard that this complex proviso guards against
is a real one.  Let's say you need to edit several files that are
in a directory like <CODE>/tmp</CODE>, <CODE>/var/tmp</CODE> or
some other directory that is writable by all users.  To save the
trouble of providing a full path name every time you want want to
switch from one file to another, you could easily change
directories (that is, ``cd'' to the directory where these files
are located). But when you want to start editing a file, the
Vi/Ex editor may find a Trojan horse file named
<CODE>.exrc</CODE> placed in your current directory by a cracker
to await victims.  Of course, the commands in this false editor
start-up file will be run with your account ownership.  These
commands aren't limited to editor set-up commands, but may be any
shell command that you're allowed to run, including ones to wipe
out your files, reset file permissions to allow public access to
confidential data, send indelicate comments to your boss using
utilities like <A
HREF="/uworld/man/write.1"><CODE><STRONG>write</STRONG></CODE></A> 
combined with <A
HREF="/uworld/man/banner.1"><CODE><STRONG>banner</STRONG></CODE></A>, 
and so forth.</P>

<P>Now, perhaps you work on files that have different kinds of
material in different sections, and you want to be able to make a
complete change of editing environment whenever you move from one
section to another.  In this case, use the
<CODE><STRONG>source</STRONG></CODE> command, with
<CODE><STRONG>so</STRONG></CODE> as its shortest
abbreviation.</P>

<P>The <CODE><STRONG>source</STRONG></CODE> line-mode command can
be given at any time, although you may have to give it from 
line-editing mode, not from screen mode with a preceding colon.  It
takes one argument, a file name or path name, and its function is
to read the named set-up file and attempt to execute the lines in
it as a series of line-mode commands.</P>

<P>Whether or not you can specify this command successfully in
screen mode depends on the editor version you are using.  Some
early versions were quite serious about prohibiting multiple-line
line-mode commands while in screen mode.  So serious that these
versions will execute only the first line of a script that has
been sourced in while the user is in screen mode.  If you don't
encounter this behavior, you can ignore this warning.  If you do,
you at least know where the problem lies.</P>

<P>Now that you understand editor start-up files, I can
acknowledge that the one you put in you home directory is not
strictly necessary.  The editor will accept the value of a shell
environment variable named <CODE>EXINIT</CODE> as the string of
line-mode commands to be run whenever the editor starts up.  But
I don't recommend going this route, for several reasons:</P>

<UL>

<LI>Usually the shell has a strict limit on the number of
characters for the value of an environment variable, whereas the
size of a <CODE>.exrc</CODE> file is practically unlimited.  As
you get better at using the editor, you can easily develop a 
home-directory start-up file that is too large for
<CODE>EXINIT</CODE>.</LI><BR><BR>

<LI>A start-up file can be changed by simple editing, but
you have to redefine the <CODE>EXINIT</CODE> variable from 
scratch.</LI><BR><BR>

<LI>A change in your start-up file takes effect the next time you
invoke the editor, whereas if your <CODE>EXINIT</CODE> variable
is defined in a shell start-up file, it's new definition won't
take effect until you log-in again or explicitly ``source'' the
shell start-up file from the shell's command line.</LI><BR><BR>

<LI>When you want to restore the editor's environment variables
to their beginning state, you can simply source in the editor
start-up file.  There's no way to do this with the
<CODE>EXINIT</CODE> shell variable.</LI>

</UL>

<P>You can use <CODE><STRONG>source</STRONG></CODE> to execute an
editor set-up file from anywhere in your file space.  It will
also execute any file of line-mode commands, no matter what the
file name.  For example, let's say you have a special environment
setup that you never use at the beginning of an editing job, but
you do need it to edit tables.  You invoke the editor as always,
but when you're ready to edit your tables, you run a command
like:</P>

<PRE><STRONG>
:so table-defs
</STRONG></PRE>

<P>where the <CODE>table-defs</CODE> file contains line-mode
commands that set up the editor for table editing.</P>

<P>When you specify a file of line-mode editing commands with
<CODE><STRONG>source</STRONG></CODE> to perform, say, a
frequently used edit automatically, it's probably a good idea to
have commands in that file to return the editing environment to
what it was before the editing commands were run, assuming the
environment was changed for the editing task.</P>

<P><EM>Caution:</EM> If you decide to use environment set-up files
that you specify while you are editing -- you can't always depend
on default values.  For example, the
<CODE><STRONG>autoindent</STRONG></CODE> variable is disabled
(``off'') by default.  So if you are setting up a start-up file
that will only be used at the beginning of editor sessions, and
you don't want to use autoindenting, you don't need to do
anything to leave it turned off.  But if you plan to occasionally
use that set-up file in the middle of a session, you have to ask
yourself, ``Will I ever use this setup in a case where I
previously had autoindenting turned on, either by another set-up
file or because I manually turned it on?''  If the answer that
question is ``Yes'', then the set-up file you're writing must
contain a <CODE><STRONG>set noai</STRONG></CODE> command to be
sure that autoindentation is definitely disabled.</P>

<P>And, what if the <CODE><STRONG>source</STRONG></CODE> command
is broken in your version of the editor?  There is still a way to
make semiautomatic environment changes.  You have to use the 
line-mode <CODE><STRONG>read</STRONG></CODE> command plus a 
little-known feature of letter-named storage buffers.</P>

<P>You're probably accustomed to using the ``a'' through ``z''
named buffers for storing pieces of text, and returning these
pieces to the main document with commands like
<CODE><STRONG>"jp</STRONG></CODE>, which returns the contents of
the ``j'' buffer right after the cursor position in visual mode.
Well, you can also use a visual-mode command of the form
<CODE><STRONG>@j</STRONG></CODE>, which takes the text from the
``j'' buffer and executes it as a visual-mode command string.
For instance, if buffer ``j'' contains ``257G3dd'' as its text,
then typing <CODE><STRONG>@j</STRONG></CODE> will move the cursor
to line 257 and delete that line and the two that follow it.</P>

<P>The text in the buffer must be commands you could give
from visual mode for this feature to work, but that includes
line-mode commands that are preceded by a colon and terminated
with a carriage-return character.  So if buffer ``h'' contains
the lines:</P>

<PRE><STRONG>
:se nomesg terse list
:map v :!wc -w %^M
1G
</STRONG></PRE>

<P>then typing ``@h'' will reset three variables, map a command
string, and move the cursor to the first line in the file.</P>

<P>There are a few points you should keep well in mind when you
are placing line-mode commands into a letter-named buffer for
future execution.  All of them revolve around the fact that the
editor is expecting screen-mode commands from this source.</P>

<UL>

<LI>Any line-mode command must fit entirely on a single line.</LI><BR><BR>

<LI>A line-mode command must begin with a colon character.</LI><BR><BR>

<LI>A line-mode command may begin at the start of a line of text
or in the middle of it, but it must end at the end of the line.
At execution time, the newline character at the end of the text
line is what tells the editor that this particular command is
ended and a new command (either line- or screen-mode) will
follow.</LI><BR><BR>

<LI>Never put a line break in buffer text you will execute as a
command string unless a carriage return is part of the command
string at that point.</LI>

</UL>

<P>To import this set-up command list from an outside file to the
``h'' buffer, use the <CODE><STRONG>read</STRONG></CODE> command.
For example, if your three-line set-up file is named
<CODE>set.5</CODE>, then type:</P>

<PRE><STRONG>
:r set.5
"h3dd@h
</STRONG></PRE>

<P>to read the file into your editing buffer, then the
<CODE><STRONG>"h3dd@h</STRONG></CODE> command will delete those
three lines -- which came from the external file -- into the
``h'' named buffer, then execute the same lines as set-up
commands.</P>


<H3><A NAME="next">The Next Installment</A></H3>

<P><EM>You asked for it, and it's here!</EM><BR>
Most of the e-mail I receive about this tutorial asks me how to
do some specific kind of editing with Vi.  The most popular
request so far has been for techniques to edit material in
columns, and that's what I explain in the <A
HREF="009.part6.html">next installment</A>. Then it's on to the
treacherous, albeit important, topic of addresses for screen-mode
commands.</P>

<HR>

<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?uworld1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>



 
 
<H1>UnixWorld Online: Tutorial: Article No. 009: Part 6</H1>

 
<H2>Addresses and Columns</H2>
 
<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter
Alan Zintz</A>.</P>
 
<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>
 
<UL>
 
<LI><A HREF="#screen">Screen-Mode Addresses</A>

<UL>
    <LI><A HREF="#few">A Few Address Principles</A>
    <LI><A HREF="#useful">Useful Addresses</A>
</UL>

<LI><A HREF="#cols">Editing in Columns</A>

<UL>
    <LI><A HREF="#single">Single-Character Columns</A>
    <LI><A HREF="#multi">Multi-Character Columns</A>
</UL>

<LI><A HREF="#next">Next Installment</A>

</UL>


<P>By popular demand I'm trying something new in the tutorial,
starting with this installment.  The e-mail I receive from
tutorial readers most often asks me how to do some specific
type of editing job, using whatever editor tools are needed.
So, I'm now mixing my general-principle explanations with
in-depth coverage of particular work areas.</P>

<P>The first application area I'm covering is the one readers
ask about most often, by far: editing files where columns
are a major factor.  Future areas are up to you readers.  If
you have an application area you'd like to see explained in
some depth, <A HREF="mailto:walter@ccnet.com">e-mail me</A>
your suggestion.</P>

<H3><A NAME="screen">Screen-Mode Addresses</A></H3>

<P>You use them all the time.  They're the address targets that
tell screen-mode commands like <CODE><STRONG>c d y</STRONG></CODE>
which stretch of your file to act on.  And even more often you
use such addresses without commands, to move around in the file.</P>

<P>For starters, I'll tell you some basics of screen-mode
addressing that aren't particularly clear to most editor users.
Then it's on to a few powerful but obscure addresses that most
of us rarely or never use.</P>

<P><STRONG><A NAME="few">A FEW ADDRESS PRINCIPLES</A></STRONG></P>

<P>The first fact of screen-mode range addresses is simple enough:
one end of the range to be affected by the command is always marked
by the cursor itself.  The address you give the command (always a
single address) indicates where the other end of the affected range
is to be.  The address target can be either forward or backward
from the cursor position, in most cases.  But exactly how the cursor
and the target terminate the two ends of the range is variable.</P>

<P>At the start we have to distinguish between line addresses and
character addresses.  Line addresses are very straightforward: the
command affects the entire line the cursor is on, the entire line
where the address point is located, and all the lines in between.
If you are using an address without a command, in order to move the
cursor, a line address generally puts the cursor on the first
non-whitespace character in the line addressed.</P>

<P><A NAME="line-char">But line versus character addresses</A> affect
a lot more than exactly what's included in the range.  As one example,
if you yank or delete text using a line address and then place that
text somewhere with a <CODE><STRONG>p</STRONG></CODE> or
<CODE><STRONG>P</STRONG></CODE> command, that text will appear on a
new line or lines, above or below the line you are on, respectively.
But if you yanked or deleted with a character address, when you put
the text back in, it will appear within the line you are on, just
just ahead of or behind the cursor.  And to dispose of one editor
fallacy here and now, it does not make a bit of difference that the
range of text you yanked or deleted with a character address amounts
to exactly one or more lines -- it will still behave as any other
text yanked or deleted with a character address.</P>

<P>So which addresses
are line addresses?  That depends on what your command is.</P>

<P>Besides the three commands I cited as examples above, there
are four other, less-used commands -- <CODE><STRONG>! &lt; &gt;
=</STRONG></CODE> -- that also take addresses.  The only thing
you have to know right now about these four commands is that they
can act only on entire lines; that's inherent in what they do.
So with these four commands, every address is a line address.
(Except a handful of addresses, such as ``f'', that cannot be
used with these commands at all.)</P>

<P>With the three more-used commands <CODE><STRONG>c d
y</STRONG></CODE> or with an address used by itself to move the
cursor, an individual address is either always a line address or
always a character address -- usually.  There are exceptions to
this rule also, such as the address ``j'', which is a
character address when you are just moving the cursor, but a line
address to any command.</P>

<P>So just where does a character address take you?  When you are
just moving around in the file, the cursor lands on the character
that is the target you sought.  Or if the target was a string of
characters, the character address puts the cursor on the first of
these.</P>

<P>When you are using a character address with a command, the
situation is more complex.  The one firm rule is that if the
character address is farther down in the file than the cursor
position, the cursor position is included in the range the command
affects; while if the address target is earlier in the file than
the cursor, the cursor position is not included in the range.</P>

<P>The question of whether the address target is included in the
command's range, like all the other open questions raised in the
last few paragraphs, will have to be answered separately for
each address.  (But the usual rule is that if the address target is
forward of the cursor, the target is not included; if the target lies
backward from the cursor, the target is included.)</P>

<P>Note also that a count given with any of these
seven commands is passed to the address.  You may give the count before
or after the command character itself, but always before the address.
What the address does
with the count, if anything, is also a case-by-case question.</P>

<P><STRONG><A NAME="useful">USEFUL ADDRESSES</A></STRONG></P>

<P><A NAME="finding">There are four addresses</A> that together
resemble a miniaturized, localized version of the / and ? search
patterns.  In each case, the search takes place only in the
current line, and only for a single character.  To use any of
them, you type one of the four letters designating the kind of
inline search, immediately followed by the character to be
searched for.  (There are no metacharacters used with these
addresses.)</P>

<P>The letter ``f'' means that the search will go forward in the
current line and stop on the character typed next.  ``F'' makes
the search run backward within the current line, otherwise the
same as ``f''.  A ``t'' search is the same as an ``f'' search
except that the search stops with the character just short of
the one you type after the ``t'', and a ``T'' search is like a
``t'' search but running backward within the current line.  Any
of these addresses can take a preceding count, which tells the
search not to stop at the first instance of the character sought,
but to go on to the <EM>n</EM>th, where <EM>n</EM> is the count.</P>

<P><A NAME="found">Any of these search commands,</A> including the
repeat-search commands mentioned below, are character addresses and
can be used as an address for any of the three range commands that
does not require a line address.  In every case, the character on
which the cursor would have landed had there been no command is
the furthest character included in the range the command will affect.</P>

<P>A few examples.  ``Fp'' would cause a search that went backward
and landed on the closest prior letter ``p''.  ``3f-'' would make
the search run forward within the current line and stop on the third
instance of a hyphen.  ``2T '' would cause a backward search that
ended one character short of the second closest space character.</P>

<P>This search system has its own repeat-search characters, which use
storage buffers completely independent of those used for storing
previous / and ? search strings.  A
semicolon ``;'' repeats the last inline search, in the same direction.
A comma ``,'' repeats the last search but reverses the direction.
Any count to the original search is not included in the repeat,
but you can give a count to either repeat character which will be
passed to the search command that is repeated.  While a search is
limited to the current line, you can run a search, move to another
line, then use a semicolon or comma to repeat the original search
on the new line.</P>

<P><A NAME="pipe">Another very useful address</A> that operates within
a single line is the vertical bar ``|''.  When preceded by a count,
this address takes the cursor to the <EM>n</EM>th character on the
current line, where <EM>n</EM> is the count, regardless of where the
cursor was when the address was given.  (In this address, <EM>n</EM> is
absolute, not relative, starting from character one at the left edge
of the text.)</P>

<P>This address can also be used with a command.  If the target
character position is forward from the cursor position, the furthest
character affected will be the last one before the target character.
If the target is backward from the cursor, the target character as well
as all those between it and the cursor will be affected by the
command.</P>

<H3><A NAME="cols">Editing in Columns</A></H3>

<P>Although the Vi/Ex editor was not specifically designed to
deal with columnar material, there are ways to use it
effectively for this kind of work.  Your choice of techniques
will depend on whether you are dealing with <A
HREF="#single">single-character columns</A> wherein each
character in a line is in a separate column, or <A
HREF="#multi">multi-character columns</A> where the columns
are set apart from each other by a separator character.</P>

<P><STRONG><A NAME="single">SINGLE-CHARACTER COLUMNS</A></STRONG></P>

<P>Here I'm using ``columns'' the way most programmers do.  A column
in this sense is simply the characters in a vertical section of
a file, one character wide.  That is, the first character on each
line of the file is in the first column, the second character of
each line is in the second column, and so on.  You'll find this
usage in systems that use punch-card images, such as early Fortran
programs; in the blocked records in certain databases, such as
the ones used for very large mailing lists; etcetera.</P>

<P>The essential point is that the systems that use these records
absolutely depend on each piece of information being entirely
within a certain column or range of columns, and nothing else
being within those columns except padding characters to fill up
any column positions not needed for the information in a
particular record.</P>

<P>For example, a mailing list may require that a suite or
apartment number be in columns 122 through 125 in each record
(line), with any padding following the actual number, so that an
address printing program that finds ``316&nbsp;'' in those
columns will print ``,&nbsp;#316'' at the end of the street
address line.  If it finds ``3A&nbsp;&nbsp;'' it will then print
``,&nbsp;#3A'', etcetera.  Should the suite number be even
partially shifted out of the designated columns, the system will
either print garbage as the suite number or issue an error
message and skip that address altogether.  The principle is the
same, and even more important, with computer programs in punch-
card image form.</P>

<P>When you are making changes in existing records, and editing
visually, the first important point is to be sure your are at the
start of the particular field you need to modify.  The <A
HREF="#pipe"><NOBR>``|'' address I've explained above</NOBR></A>
takes care of that -- wherever you are in a line, typing
<CODE><STRONG>122|</STRONG></CODE> brings the cursor to the 122nd
column.  Unless there are not 122 columns in that line: then the
cursor will be placed in the last column that does exist, without
any warning or error message.  But files of this sort have
generally been checked for exact block sizing, and if yours have
not been, it's easy to check visually.</P>

<P>To check visually that all the lines in the file are of the
proper length, start by running a <CODE><STRONG>:se
list</STRONG></CODE> command, which will display a dollar sign
at the end of each file line.  Then scan through the file to check
that all those dollar signs are aligned vertically.  If so, then
check that the uniform line length is the correct one -- if your
line length should be 66 characters (not counting the nonvisible
newline), then run a <CODE><STRONG>65|</STRONG></CODE> command on
any line, and make sure that the cursor lands one column away from
the end of the line.</P>

<P>When you are at the start of the field to be changed, you have a
choice of ways to change it.  If the change area is 12 characters
long, then typing <CODE><STRONG>12cl</STRONG></CODE> followed by the
12 new characters and then the escape key will do it.  But if you
miss the count by even one character; if the actual number of
characters you type in is 11 or 13; then all the subsequent fields
on that line will be shifted one character out of place, which is
probably a recipe for disaster.</P>

<P>To avoid this hazard, make use of the little-known
<CODE><STRONG>R</STRONG></CODE> command.  It starts like the
familiar <CODE><STRONG>r</STRONG></CODE> command, in that when you
type the letter ``R'' in visual command mode the system waits to
see what character you type next, and whatever that next character
is, it replaces the character that was under the cursor.  But
instead of then returning you to command mode, the
<CODE><STRONG>R</STRONG></CODE> command then moves the cursor one
character to the right and again waits to see what character you
type next -- the character you now type replaces the character
that is now under the cursor.  This process continues until you
stop it by hitting the escape key.  So if your cursor is on the
capital P in the following line:</P>

<PRE>
but the greatest ancient Greek was Plato, who
</PRE>

<P>and you type in ``RHomer'' followed by the escape key,
your line will now read:</P>

<PRE>
but the greatest ancient Greek was Homer, who
</PRE>

<P>and the cursor will be on the letter r at the end of ``Homer''.
This character at a time replacement is the way to make sure you
don't inadvertently shift any fields.  Just be certain that you
don't keep typing replacement characters beyond the existing end
of the line; you would extend the line length that way.  You can
give a count to the <CODE><STRONG>R</STRONG></CODE> command, but
you don't want to in this use because the count will multiply the
number of times the new character string is inserted.  That is,
in that example above about replacing ``Plato'' with ``Homer'',
if you had typed <CODE><STRONG>3R</STRONG></CODE> instead of
<CODE><STRONG>R</STRONG></CODE> your revised line would read:</P>

<PRE>
but the greatest ancient Greek was HomerHomerHomer, who
</PRE>

<P>Entering completely new lines of information is another matter.
You should just type them straight across, as you would with any
text entry, but if the existing lines are cryptic to human eyes
you may not be able to tell by looking just where one field ends
and another begins.  You can try to keep count of the characters,
of course, but a single mistake will throw all the subsequent fields
in that line out of position.</P>

<P>What you need here is an on-screen template to show you what
goes where.  You can make one on the spot, just by typing a
template line into your file, entering each data line just above
it, and deleting that template line when you are finished adding
lines.  For example, suppose you are adding to a name file where
each record (line) starts with a month, day and year, continues
with a source code (each of the preceding as a two-digit number,
with a leading zero to pad it if necessary), and then has fields
for a last name, first name, and middle initial.  It would not
be practical to judge where fields break just by looking at the
existing data lines, which might look like this:</P>

<PRE>
07215854von TarekenstuttLeopold  J
12077338Henderson-Blyth La Toya  P
10108972Thistlethwaites Geraldine
</PRE>

<P>But a simple template line can clear it all up.  Here is one
for the job above:</P>

<PRE>
m|d|y|s|LLLLLLLLLLLLLLL|FFFFFFFF|M
</PRE>

<P>It has mnemonic characters to remind you of what goes in each
field, and the ``|'' to indicate the last position of each field
more noticeably.  I've even used a lower-case letter for each field
that takes numeric characters right justified and zero padded,
and a capital letter for each field that takes alpha characters
left justified and space padded.</P>

<P>The way to use this template is to start entering data lines
immediately above the template line.  That way, as you hit return
to start a new line, that new line replaces the one you've just
finished in the position right above the template line.  Yes,
eventually the template line will be driven down off the bottom of
the screen, but returning to command mode and typing the
lower-case letter ``z'' followed by the return key will move the
template line and the lines around it to the top of the screen.</P>

<P>But there will be times when you don't want to spend time
making individual changes that you should be able to handle
globally.  Suppose an obsolescent operations code has been
replaced, and you now need to change every ``B27'' to ``K53''
throughout your file, but only when the ``B27'' appears in the
operations code columns, which are columns 9 through 11.  This
odd-looking command will do it:</P>

<PRE><STRONG>
:%s/^\(........\)B27/\1K53
</STRONG></PRE>

<P>Those eight consecutive dots in the search pattern guarantee
that a match will occur only when there are exactly eight
characters between the beginning of the line and the ``B27''.
So of necessity, the ``B'' must occur in column 9, and so on.
The ``\1'' puts those eight characters right back in again, so
only the ``B27'' is actually replaced.</P>

<P>If your columnar file has all lines of equal length, as most do,
you can use this technique from the right side, too.  If all lines
in the file have 66 characters, then typing that last command as:</P>

<PRE><STRONG>
:%s/B27\(...\)$/K53\1
</STRONG></PRE>

<P>will accomplish the changes in a case where the operations code
columns are 61 through 63, without the need to type (and carefully
count) sixty consecutive dots.</P>

<P>But there will be times when the columns to be changed are in
the middle of horrendously long record lines.  There are still a
couple of tricks you may be able to use.  One is to find a
landmark somewhere in mid-line.  Does column 158 always contain
either a ``*'' or a ``|'' character, neither of which can appear
anywhere else in the lines?  Then you can make the above change
in columns 163 through 165 by typing:</P>

<PRE><STRONG>
:%s/\([*|]....\)B27/\1K53
</STRONG></PRE>

<P>Failing a landmark, let the editor count out a long string of
dots for you.  To use this technique, you must first create your
substitution command as a text line within the file you are
editing, next write that line as a separate file (and then
delete the command line from your original file), and finally
use the <CODE><STRONG>:so</STRONG></CODE> command to pull in that
one-line file and run it as a line-mode command.  If you need a
string of 92 consecutive dots in your command, create a blank line
at the end of your file, next type:</P>

<PRE><STRONG>
:1,92g/^/$s/^/.
</STRONG></PRE>

<P>to put those 92 dots there, and finally put the rest of the
command around that dot string.</P>


<P><STRONG><A NAME="multi">MULTI-CHARACTER COLUMNS</A></STRONG></P>

<P>The other meaning of ``editing in columns'' has to do with text
rather than data files.  It refers to tables of data such as you
might find accompanying a technical article, columns of text
and/or illustrations running in parallel as you'd find on a
newspaper page, and the like.</P>

<P>Yes, Unix formatting utilities and some word processing programs
will format your final output into columns.  But you may not have
all these utilities, you may not want to spend time trying to get
the results you want from those benighted programs, or you may
plan to direct your output where formatters won't work.</P>

<P>Visually editing the columns of data in a table requires little
explanation.  The one thing to remember: use the
<CODE><STRONG>R</STRONG></CODE> as far as possible, to avoid
shifting subsequent columns out of alignment inadvertently.
This holds for creating tables, too; start by setting up a
rectangular block of space characters, then replace spaces with
the column entries you want, to keep your next entry from
misaligning previous ones.  This is also the best way to create
pictures, diagrams, graphs and maps using ASCII characters.</P>

<P>Things become problematic when you want to shift whole
columns around -- there are no built-in Vi facilities for doing
this.  Here is what it is practical to do in the editor.  As
a real life example, consider the piece below, which I use as
the tail end of Usenet (Net news) posts that announce Indonesian
classical music and dance performances at a local restaurant:</P>

<PRE>
   It's at the Dutch East Indies Restaurant       ;,,,,;,,,,;,,,,;,,,,;  
on Oakland's downtown waterfront.  The food      /%%%%%%%%%%%%%%%%%%%%%\ 
there is very good Indonesian cuisine at        /%%%%%%%%%%%%%%%%%%%%%%%\
reasonable prices - dinners $8.95 to $17.50.     "|""|"""|"""""|"""|""|" 
Views are spectacular from the second floor      _|__|___|_   _|___|__|_ 
picture windows, out over the water to Jack      =|==|===|=====|===|==|= 
London Square, Alameda and San Francisco.       ~~~~~~~~~~~( (~~~~~~~~~~~
Formality is medium - cloth napkins and oil                 ) )
candles at the tables, but no supercilious
waiters, and the wall decorations are mostly Indonesian handicrafts.
The phone number for information and reservations is 510/444-6555.

( ( (             | Broadway ||I      The Dutch East Indies Restaurant is
 ) ) )Jack London |==========||==  in Jack London Village, a boutiques &
( ( ( Square      |E         ||8   bistros cluster that is just down the
 ) ) )            |m         ||8   estuary from Jack London Square.  Jack
( ( ( JACK LONDON |b         ||0   London Village is rustic, picturesque,
 ) ) )VILLAGE     |a         ||    quiet and safe.  To get there from the
( ( (        Alice|r Amtrak  ||f   Interstate 880 freeway heading north,
 ) ) ) -----------|c station ||r   take the Oak Street exit and turn left;
( ( (       Street|a         ||e   five blocks will bring you to Embarca-
 ) ) )            |d  Jackson||e   dero on your right, just before Oak
( ( ( parking lot |e   ------||--  curves away to the left.  (Going south
 ) ) )            |r   Street||w   on I-880, take the Jackson Street exit
( ( (             |o         ||a   and go two blocks straight ahead before
 ) ) )            |          ||y   you turn right on Oak Street.)  Turn
( ( (           -------------||--  right onto Embarcadero and go three
 ) ) )             Oak Street||    blocks, until you go under an overpass
                                   of Victorian ironwork.  Immediately
turn left onto Alice Street, where you will see Jack London Village on
your right, and a large lot that offers validated parking on the left.
Walk into the Village's central courtyard, and you'll see the Dutch East
Indies on the estuary side, toward the right, and upstairs.
</PRE>

<P>To create this, I started by drawing the stylized building and then
the map.  In each case I created a large rectangular block of space
characters, then began trying ideas with the
<CODE><STRONG>R</STRONG></CODE> command until I had something that
satisfied me.  (The pavilion sketch eventually became wider than I had
planned, so I had to run a
<CODE><STRONG><NOBR>:%s/.*/   &   /</NOBR></STRONG></CODE> command to give
me more working space.)  Next I put additional blocks of space characters
on the left of the drawing and the right of the map, to make a place for the
text I wanted to include.  Then I started replacing spaces with text,
rewriting the text as I went along to fit it in nicely.  When the text
reached the bottom of the figure I was fitting it to, I went to
full-width text lines, entering them the usual way.  A tedious labor,
but pretty straightforward.</P>

<P>Now suppose I decided to redo this piece, by moving the picture
to where the map is now, and vice versa.  A few well chosen substitution
and deletion commands would make copies of the two figures minus the text,
and I could just as easily copy the text without the two figures.  But
how would I recombine them?</P>

<P>Short of typing the text in again from scratch, the best I could do
is to yank the lines of each figure, one at a time, and put them after
(or before) the appropriate text lines, one at a time.  Not that I
would have to move back and forth between files with each yank and put;
I could yank up to 26 lines into the named buffers, then move to the
other file and put all 26 in their proper places.  But there is no
Vi command to yank a rectangular block of characters.</P>

<P>Also take note that I should yank using addresses that are not
line addresses, even though I will be yanking whole lines.  If I
should yank with line addresses, putting the pieces into the other
file must make those pieces separate lines -- then I would have
to join each pair of lines to create the columns I want.</P>

<H3><A NAME="next">Next Time Around</A></H3>

<P>In the next part of this tutorial, I will go over host of
complications and opportunities that come from allowing the
replacement commands I've discussed to use metacharacters.  Then
I'll answer a couple of questions from readers that should be of
use to quite a few of you from time to time.</P>

<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 7</H1>

<H2>A Little ``R'' and ``r'': The Fine Points of those
Replacement Commands</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter
Alan Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Wait!  First read my <A
HREF="guidelines.html">guidelines for question submissions</A>.</P>

<P>[<EM>Editor's Note:</EM>. This installment is one of a series.
This tutorial series is a ``work in progress'' and will evolve
over time.  We'll announce each new addition and expand its <A
HREF="009.html">table of contents</A>.]</P>

<UL>

<LI><A HREF="#more">There's more to <CODE><STRONG>R</STRONG></CODE> than
to <CODE><STRONG>r</STRONG></CODE></A>

<LI><A HREF="#quote">Quoting in Characters</A>

<LI><A HREF="#ask">Readers Ask</A>

<UL>

<LI><A HREF="#tommy">Tommy Spratlin writes:</A>

<LI><A HREF="#thai">Thai-Nghia Dinh writes:</A>

</UL>

<LI><A HREF="#next">Next Time Around</A>

</UL>

<P>This installment of our Vi/Ex tutorial series is a diversion
from the subjects I promised at the end of the previous part --
the change is my fault, and yet it is necessary.  When I blithely
suggested last time that the <CODE><STRONG>R</STRONG></CODE>
command is just like the familiar <CODE><STRONG>r</STRONG></CODE>
command, except for a few differences I mentioned, I was leading
you astray.</P>

<P>There are several differences that can cause problems in
certain uses unless you understand those differences.  And you
won't really comprehend the greatest of those differences until
you know about metacharacters in insert mode.
But as an encouragement to follow all this, consider that almost
all of what I say here about the <CODE><STRONG>R</STRONG></CODE>
command also is valid with all the other commands that put you
into text insertion mode: <CODE><STRONG>a A i I o O c s
:a :i</STRONG></CODE> etcetera.</P>

<H3><A NAME="more">There's more to <CODE><STRONG>R</STRONG></CODE> than
to <CODE><STRONG>r</STRONG></CODE></A></H3>

<P>The <CODE><STRONG>r</STRONG></CODE> command replaces whatever
character is presently under the cursor, so there must be some
character under the cursor for it to replace -- otherwise it just
gives you an error beep.  Not so with <CODE><STRONG>R</STRONG></CODE>.
<A NAME="empty">You can give the <CODE><STRONG>R</STRONG></CODE>
command</A> on an empty line; whatever you type after that, up to the
next escape character, will take the place of that empty line
just as though you had typed past the
end of an existing line after giving an <CODE><STRONG>R</STRONG></CODE>
command.  (I was going to say ``just as though you had given an
<CODE><STRONG>a</STRONG></CODE> command'', but I'm now very leary of
making comparisons that are incomplete without paragraphs of
explanations.)  You can even start entering text into a brand-new
file via the <CODE><STRONG>R</STRONG></CODE> command.</P>

<P>The factor above can be useful in various situations; I only have
space to mention one.  At times I want to type new characters to
replace blank spaces in a place where some of the lines are empty.
These do not have any blanks; no characters at all.  But I do not have
to look at each line before I start typing on it, to see whether I
should use an <CODE><STRONG>R</STRONG></CODE> or an
<CODE><STRONG>a</STRONG></CODE> command, because
<CODE><STRONG>R</STRONG></CODE> will work in either case.</P>

<P>The <CODE><STRONG>R</STRONG></CODE> command is more forgiving of
your typing errors, too.  Whatever character you type after an
<CODE><STRONG>r</STRONG></CODE> is final.  If you accidentally
typed the wrong character, you can only put back what was there
by typing a <CODE><STRONG>u</STRONG></CODE> command, if the mistake
was the last editing command you typed, or put in the replacement
you had in mind by returning the cursor to the spot and running
another, more careful, <CODE><STRONG>r</STRONG></CODE> command.</P>

<P>But if you mistype during an <CODE><STRONG>R</STRONG></CODE>
command, you can backspace over the error with the backspace key.
Then you can type in the character (or characters; you can back
up multiple spaces by repeating the backspace key) you should have
typed.  And if you simply typed too far, you'll be glad to know
that backspacing doesn't just remove the incorrect characters, it
restores the characters that were there, either right away or as
soon as you hit the escape key.  You can even backspace over
everything you've typed during this <CODE><STRONG>R</STRONG></CODE>
command before you type escape, because the editor does not object
to a replacement string length of zero.</P>

<P>One caveat here, though, lest my clarification turn out to need
a clarification of its own.  With either of these commands it is
possible to break a line, just by typing the return key as a
replacement character, and with the <CODE><STRONG>R</STRONG></CODE>
command this linebreaking can be done either while actually replacing
characters or when typing on beyond the end of the existing line.
With almost all versions of the editor, it is not possible to
backspace over an inserted linebreak, even while you are still in
<CODE><STRONG>R</STRONG></CODE> insertion mode.</P>

<P>The most important difference, though, is the handling of
metacharacters.  Yes, text insertion utilizes metacharacters too,
quite apart from the ones that the replacement patterns in
<CODE><STRONG>:substitute</STRONG></CODE> commands use.  The
<CODE><STRONG>r</STRONG></CODE> command recognizes hardly any of
these metacharacters, and quoting those in as literal characters is
very simple.  The <CODE><STRONG>R</STRONG></CODE> command, though,
recognizes almost all of them, and quoting characters in with
<CODE><STRONG>R</STRONG></CODE> is rather complicated.</P>

<H3><A NAME="quote">Quoting in Characters</A></H3>

<P>The phrase ``quoting in'' is standard terminology, but it is
rather misleading in the editor.  Unlike Unix shells, the editor
does not use any of the ASCII quotation marks: <CODE><STRONG>` '
"</STRONG></CODE> (backquote, single and double quote) to quote
characters into a file.  Instead, it uses the backslash
(``<CODE><STRONG>\</STRONG></CODE>'') and control-V
(``<CODE><STRONG>^V</STRONG></CODE>''); the latter is what you
send when you press the V key while holding the CONTROL or CTRL
key down.  In either case, you quote a character in by typing the
quoting character just prior to the character you want to quote
in.  So if @ is your line kill character, and you want to put
that character in the text you are typing in, you would have to
type either \@ or ^V@ to get it there.  And if you want several
consecutive characters quoted in, you must quote each of them
individually.  That is, if you want to put @@@ into a line, you
must type either ^V@^V@^V@ or \@\@\@ to put that string there.</P>

<P>But \ and ^V are not always interchangeable.  In many cases
either will work; but sometimes you must choose the right one.
Which one to use depends both on what character you want to quote in
and whether you're using the <CODE><STRONG>r</STRONG></CODE> or
<CODE><STRONG>R</STRONG></CODE> command.</P>

<P>One obvious use for quoting is to insert a character that normally
erases part or all of what you've just typed in.  The ASCII backspace
character, control-H, must be quoted in, and so must your own line-kill
character (@ in the example above) and your own erase character if it
is not control-H.  With the <CODE><STRONG>r</STRONG></CODE> command
you quote in any of these with a backslash; when using
<CODE><STRONG>R</STRONG></CODE> you may quote any of these in using
either backslash or control-V.</P>

<P>A pause here, to answer a question that might be in the minds
of people who know a little about Unix internals.  Ordinarily it
is the asynchronous serial terminal line (or TTY) driver that
recognizes the erase and line-kill characters and edits the input
line accordingly without including these characters in the final
result.  Then, how can one enter these same input-line characters
into the edit buffer if they don't get past the TTY driver?
Because Vi/Ex places the TTY driver into a special ``raw'' mode
that ignores the line-editing characters passing them on to the
editor.  Otherwise you would not be able to quote these
characters in.  Also, the editor is set up to discover your erase
and line-kill characters by querying your personal environment,
and then interpret these characters as the line driver would
have.  A nifty feature -- but unfortunately, the editor has no
way to let the user turn this feature off.</P>

<P><A NAME="atsign">The editor's creators</A> came up with a
curious method for repeating short text insertions, where the text
to go in is always the same but any outgoing text varies.  They decided
that when you are in screen mode, and have just gone into typing-in-text
submode, and make Control-@ (``^@'') the first character you type in,
then the editor should insert the last piece of text you had previously
inserted (if it was not more than 128 characters long) and take you back
to command mode.  Unfortunately, they never made this work as promised.</P>

<P>In actuality, ^@ operates anywhere in a text insertion, not just
in the first character position.  What a ^@ does there depends on the
situation.  If your last <CODE><STRONG>c d y</STRONG></CODE> command,
or one of their variants such as <CODE><STRONG>s D</STRONG></CODE>
etcetera, removed or copied a full line of text or parts of two or
more lines, or if you haven't run one of those commands in your
current editing session, then typing ^@ is just a nuisance.  It will
take you out of text input submode and probably move the cursor back
a few characters from where the input ended.</P>

<P>But if you have done at least one <CODE><STRONG>c d y</STRONG></CODE>
command or a variant, and if the very last one you did removed or
copied only a part of a single line of text, then surprise!  Typing a
^@ in this case will do three things:</P>

<OL>

<LI>Unless you typed it at the first character position on a line,
it will move the cursor back one character.  This will move over the
last character you typed in if you've typed any, or over one existing
character if you type ^@ as the first character of your insertion,
but will not erase the character it passes over.</LI>

<LI>Just to the left of the new cursor position, the editor will
insert the text that was removed or copied by your last
<CODE><STRONG>c d y</STRONG></CODE> command or variant.
(If you went into text-insertion submode via a
<CODE><STRONG>c</STRONG></CODE> command or a variant of it, the text
you just took out is what will be put back in.)</LI>

<LI>Finally, the text insertion will automatically end and you will
be back in command submode, with the cursor positioned at the start
of the last simple word that was inserted by the ^@ metacharacter.</LI>

</OL>

<P>Quoting a ^@ into your text isn't possible, because the editor
reserves that character for internal use and will not accept it as
itself in any file you may edit.  Not that there would be any reason
to put ^@ in a file anyway: it is the ASCII character NUL, a padding
character that is routinely inserted in data streams by device
drivers, and just as routinely stripped at the receiving end, so
any ^@ characters you might add would be lost in the shuffle.
But when you are using the <CODE><STRONG>R</STRONG></CODE> command,
or any other command that lets you insert an indefinite amount of
text, you can quote a ^@ anyway by preceding it with a ^V.  The
result will be to quote ^[Pb into your file at that point; this
being the command string the editor issues to perform the odd
operation I've detailed above.</P>

<P>Those of you who are skillful with the editor may wonder why
the ^@ insertion operates only when your last text extraction was
a fragment of one line.  After all, the <CODE><STRONG>P</STRONG></CODE>
command by itself inserts the contents of the unnamed buffer, and
that buffer holds whatever was extracted last, be it half a line or
a hundred lines, doesn't it?  The answer lies in one of the editor's
undocumented features.  When you give a command to insert text, even
the <CODE><STRONG>r</STRONG></CODE> command that only inserts a
single character, the editor simultaneously flushes the unnamed
buffer and leaves it empty -- if and only if that buffer contained
more than a fragment of one line.  So, when you entered the text
insertion mode from which ^@ operates, you emptied the unnamed
buffer unless there was only a fragment of one line in it.</P>

<P>At times you may want to use the <VAR>beautify</VAR> option to
the <CODE><STRONG>set</STRONG></CODE> command.  This tells the
editor to throw away most, but not all, control characters you may
try to type in -- the exceptions usually are the tab (^I),
newline (^J), and form feed (^L) -- in order to keep you from
inadvertently putting in invisible control characters that will
be hard to detect later.  This option is normally off, but you
can type <CODE><STRONG>:se bf</STRONG></CODE> to turn it on.</P>

<P>But even when you want most control characters thrown out, there
will be occasions when one must go in.  This is not possible using a
<CODE><STRONG>r</STRONG></CODE> command.  The usual
<CODE><STRONG>r</STRONG></CODE> technique of backslashing will
usually bite
back in this case -- the editor will interpret the control character
by acting on its control meaning rather than inserting it in the text.
Using <CODE><STRONG>R</STRONG></CODE>, though, you can
insert most control characters by preceding each with ^V.</P>

<P>Even this may not be enough.  Some systems are set up so that
when certain control characters are typed in, even though preceded by
^V, the system acts on them as control characters before the editor
ever sees them.  To get around this problem, many implementations of
the editor, especially older ones, interpret an ordinary character
typed right after a ^V as a control character.  That is, on these
systems, typing ^VF or ^Vf while running an
<CODE><STRONG>R</STRONG></CODE> command inserts a ^F in the file,
just as typing ^V^F would on systems that don't have this challenge.</P>


<H3><A NAME="ask">Readers Ask</A></H3>

<P>Here are the latest questions, and my solutions, from inquiring
readers with problems you might face someday.</P>

<H4><A NAME="tommy">Tommy Spratlin writes:</A></H4>



<P>Hi Walter,</P>

<P>In moving
files from Windows machines to UNIX, some of our users do binary
transfers which result in ^M characters in the ASCII files.  Usually
they occur at the ends of individual lines and I do:</P>

<PRE><STRONG>
:1,$ s/^M//g
</STRONG></PRE>

<P>where ^M is generated by ^V^M and everything works fine to
delete these characters.  I now have a new problem: I found a
file with ^M characters embedded in it, but the file is one long
line.  I need to replace them with Vi's line-end character to
split this long line into multiple lines.  But I can't because
it's the same as pressing the ENTER or RETURN key in the middle
of the substitution command.  How can I replace the superfluous
carriage return?  We have several files like this and it's
causing problems viewing them with Web browsers.</P>

<P>I tried substituting a newline with the character code and the
octal code unsuccessfully, and tried the ^M as a last
unsuccessful resort.</P>



<P>Things aren't as complicated as you make them seem, Tommy.  First
of all, Web browsers generally ignore carriage-return and/or linefeed
characters while formatting text for display.  If your browser is
choking on these all-one-line files, it is probably because the lines
are too long for your browser, or for some other cause not related to
embedded ^M characters.</P>

<P>Now, as you have deduced, the difference between Microsoft and
Unix text file formats is that Microsoft operating systems seem
to favor carriage-return followed by linefeed (^J) as the line
separator, while Unix systems use linefeed alone.</P>

<P>As you've discovered, you cannot directly quote a ^J into any
editor command.  And yet, you put a ^J into your file every time
you hit return during text entry, although the return key on most
terminals sends a ^M character.  That's the trick; the
<CODE><STRONG>substitute</STRONG></CODE> command regards a ^M in
the input pattern as a signal to insert a ^J and discard
the ^M.  So you only need to get that ^M into the replacement
pattern by typing in your command line like this:</P>

<PRE><STRONG>
:1,$ s/^V^M/^V^M/g
</STRONG></PRE>

<P>You just have to overlook the appearance of futility in this
command line, as though it were going to replace each ^M with
itself.  That first ^M is in the outgoing pattern, so it matches
a real ^M. The second, in the replacement pattern, calls for a ^J
as I explained above.</P>

<P>However, these all-one-line files may be too long for the Vi
editor, which cannot handle lines much more than a thousand
characters long in most common implementations, with shorter
limits in older versions.  The editor will truncate lines that
exceed the limit, with only a minimal and rather cryptic warning.
In such cases, use the <CODE><STRONG>tr</STRONG></CODE> utility
to replace the ^M characters (which is a very straightforward job
with that tool), before you bring the file into the Vi
editor.</P>

<P>You may wonder then, how you would use the
<CODE><STRONG>substitute</STRONG></CODE> command to put ^M
characters into your file.  The answer is to backslash the
quoted-in ^M. To add a ^M at the end of every line in your file,
so as to conform it to Microsoft practice, type this command:</P>

<PRE><STRONG>
:%s/$/\^V^M
</STRONG></PRE>

<P>(Note that it is important to type the \ first, then the ^V,
followed by the ^M.) The ^V puts the immediately-following ^M
into the command line, and the backslash tells the command that
this ^M is to be considered a real one, not a metacharacter for
^J. In fact, these are the general principles for quoting
characters almost everywhere except in typing-in-text mode:</P>

<OL>

<LI>Precede a character by ^V to keep that character from being
interpreted as a metacharacter at the moment you type it.  In
this case, you don't want typing ^M to immediately end the
substitution command.</LI>

<LI>Precede a character by a backslash to keep that character
from acting as a metacharacter later, when what you've typed is
interpreted by the editor -- for example, when what you have
typed in is run as a command, or interpreted as a search
pattern.  This command uses a backslash to keep the command from
inserting ^J instead of ^M at the time it executes.</LI>

<LI>When you must use both, as in this case, type the backslash
before you type the ^V. (If you think that this backslash would
then affect the immediately following ^V rather than the later
^M, remember that the ^V is not there when the backslash takes
effect.  The ^V disappears as soon as it tells the editor to
insert the ^M in the command instead of taking the ^M as the
signal to end the command.)</LI>

</OL>

<P>Finally, you can replace linefeed characters with something
else via line mode commands, but you must use two commands and
only one of them is the <CODE><STRONG>substitute</STRONG></CODE>
command.  Suppose you need to change a short file's format from a
number of lines to the format Tommy encountered: a single line with
^M separators.  That is, replace each ^J (except the last) with a
^M. (This had better be a fairly short file, because even newer
versions of the editor can't handle any lines longer than 1024
characters.)</P>

<P>Start by using a command similar to the one above to put
^M at the end of every line except the last.  (Since these ^M
characters are to separate lines, there's no use for one at the
end of the last line.)  Then use this command:</P>

<PRE><STRONG>
:%j!
</STRONG></PRE>

<P>to join all the lines into one.  The ``j'' in this command line is
the shortest abbreviation for the line mode
<CODE><STRONG>join</STRONG></CODE> command, and the ``!'' switch at
the end of it tells the command not to insert blank space between
the lines it joins.</P>


<H4><A NAME="thai">Thai-Nghia Dinh writes:</A></H4>



<P>Hi,</P>

<P>I have a question (rather simple, really) but no one seem able
to know the answer.  Not even the help desk (with all the Vi
gurus :) ). I'm hoping you can help me with it.</P>

<P>I have a text file of unknown length.  Each line of the file
can be very short or very long (from 3 characters up to 1000
characters).</P>

<P>Within this file, I'm trying to locate (search) the <EM>n</EM>th
occurrence of a word.</P>

<P>Here are a few things I've tried:</P>

<OL>

<LI>The simple solution would be (from visual command mode):
a <CODE><STRONG>/foobar</STRONG></CODE> command followed by
the <CODE><STRONG>n</STRONG></CODE> command typed <EM>n</EM>-1
times.  But what if <EM>n</EM> is large, say 200 or
greater?)</LI>

<LI><CODE>:1,$ global /^/ /foobar/</CODE> (and its variations)
Nothing useful...</LI>

</OL>

<P>Can you suggest a better way?</P>



<P>Yes, although it involves a slightly tricky procedure.  Consider
the following command string:</P>

<PRE><STRONG>
:$|/\&lt;foobar\&gt;/s//QQQ
</STRONG></PRE>

<P>The first command in this string takes us to the last line of
our file and -- incidentally -- displays it on our screen, which is
not important here.  The second command searches forward for a line
containing ``foobar'' as a word, and starting from the last line the
search must wrap around and find the first instance in the file.
Then that second command replaces the word ``foobar'' with ``QQQ'',
leaving the cursor at the point where the substitution was made.</P>

<P>Now let us make an addition to the start of this command string:</P>

<PRE><STRONG>
:1,199g/^/$|/\&lt;foobar\&gt;/s//QQQ
</STRONG></PRE>

<P>This revised string repeats the procedure 199 times; each time the
first instance of ``foobar'' remaining in the file is the one replaced.
So we end up sitting on the ``QQQ'' string that replaced the 199th instance
of ``foobar''; simply typing <CODE><STRONG>n</STRONG></CODE> will bring
us to the 200th instance.  And if we move off that 200th instance for
any reason, going to the top of the file and searching for ``foobar''
will bring us right back to it, because the first 199 are now gone.</P>

<P>When we are finished with that 200th ``foobar'', this command:</P>

<PRE><STRONG>
:%s/QQQ/foobar/g
</STRONG></PRE>

<P>will change those 199 ``QQQ'' strings back to ``foobar''.  Of course,
if there is any chance that ``QQQ'' might occur in the document as
itself, we can choose another dummy string.</P>



<P>And while I'm at it, I've got another question.</P>

<P>How do I delete all lines beginning with a certain string,
say, !@#$ (or foobar for that matter). And a related question:
how to delete lines containing the word foobar (anywhere within
the line)?</P>



<P>The first command line following will solve your first problem, and
the second will solve your second:</P>

<PRE><STRONG>
:g/^foobar/d
:g/\&lt;foobar\&gt;/d
</STRONG></PRE>


<H3><A NAME="next">Next Time Around</A></H3>

<P>To make room to answer two readers' questions, I had to skip
presenting three great Vi tools -- <VAR>autoindent</VAR>,
<CODE><STRONG>abbreviate</STRONG></CODE>, and
<CODE><STRONG>map!</STRONG></CODE> -- and the effect their
metacharacters have in text-insertion mode.  They'll be first up
in the next part of this tutorial.</P>

<P>More answers to reader questions are coming, too.  I have
queries to answer about the semicolon address separator and about
yanking within macros -- and if a few more significant problems
arrive here, I'll try to fit them in, too.</P>

<P>And this time you won't have to wait and wait for the next
tutorial part.  As I write this paragraph, I'm already in the
middle of creating the next part, so you should see it within
a month after this part appears online.</P>

<HR>
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?netgate1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 8</H1>

<P><A HREF="/uworld/copyrights/bsd-daemon.txt">

<H2>Indent, Like a Typewriter</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter
Alan Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ifn.net</EM>. Keep those challenging
questions coming -- I haven't gotten any good ones lately.  But
wait!  First read my <A HREF="guidelines.html">guidelines for
question submissions</A>.</P>

<UL>

<LI><A HREF="#auto">Automatic Indentation</A></LI>

<LI><A HREF="#back">Backing off Indentation</A></LI>

<LI><A HREF="#set">Juggling some <CODE><STRONG>:set</STRONG></CODE>
options</A></LI>

<LI><A HREF="#you">An Exercise for You</A></LI>

<LI><A HREF="#hard">Hard Tabs</A></LI>

<LI><A HREF="#endis">Enable and Disable <VAR>autoindent</VAR></A></LI>

<LI><A HREF="#next">Next Time</A></LI>

</UL>

<H3><A NAME="auto">Automatic Indentation</A></H3>

<P>Computer editing is a great advance over typing on paper, the
consensus has it.  But wouldn't you be happier yet if you had the
tabstop-setting capability of your old typewriter, too?  With the
Vi and Ex editor, you have a feature that's just as powerful and
a lot easier to use, but not many users know it's there.  Yet
there it is, on even early versions of the editor -- its name is
<EM>autoindent</EM>.</P>

<P>With <EM>autoindent</EM> turned on, you can start a running
indent any time you are in text-insert mode -- whether initiated
from an <CODE><STRONG>R</STRONG></CODE> or from any other command
that starts you typing in text.  Just put some whitespace at the
start of the first line you want indented.  From then on, each
time you hit the return key, the editor will automatically insert
exactly the same amount of whitespace at the start of the next
line.  That is, if you begin a line with five space characters,
every following line you type in will begin with five space
characters also; causing the left margin to line up nicely, but
five spaces in from the normal margin setting.</P>

<P>Note that I said ``whitespace'' above, which includes the
tab character as well as the space character.  Autoindentation
works whether you start a line with spaces, or tabs, or some
combination of the two.  In fact, it even understands redundant
combinations, such as starting a line with two space characters
followed by a tab character.</P>

<P>We both know that tabbing from two spaces in will reach the
first tabstop, as surely as tabbing from the left margin would --
those two spaces have no effect as far as where the indented line
actually starts.  Autoindentation knows this too, and will start
each subsequent line with just a tab character.  But if you
started a line with a tab followed by two space characters, then
the spaces would have an effect -- moving the margin to the right
two more character positions than the tab alone would have.  In
this case, autoindentation will incorporate those two following
space characters, as well as the leading tab, into the text at
the start of each subsequent line.</P>
  
<P>The general rule is that while autoindentation will always put
in the same amount of leading whitespace that you did, or at
least try hard to do so, it may use its own discretion as to the
combination of tab and space characters it uses to do this.</P>

<P>If you want to increase the indentation at some point, just
type more whitespace at the beginning of an (already indented)
line, and your new indentation depth will be the rule from that
point on.  You can even leave insert mode to correct a mistake
without losing the indented margin setting, providing you return
to insert mode with an <CODE><STRONG>o</STRONG></CODE> or
<CODE><STRONG>O</STRONG></CODE> command.</P>

<H3><A NAME="back">Backing off Indentation</A></H3>

<P>To set the indentation back (or off), you need to use the
Control-D character.  When you want to stop the indentation
temporarily, for just one or a few lines, type a circumflex
(^) followed by Control-D at the start of each such line, to
move the start of just that one line back to the left margin.
If you type the numeral zero followed by control-D at the
start of a line, automatic indentation
disappears completely until you again start a line with
whitespace.  This takes effect starting with the line you are on
when you type it.</P>

<P>To set the indentation point back to the nearest shiftwidth
(discussed below) stopping place that's to the left of your
present indent point, and leave it there until you change it
again, type just control-D at the start of the line.  If that is
not enough margin reduction for you, just type several
consecutive control-D characters to get the amount you want.  This
setback also takes effect starting with the line you are on when
you type the control-D.</P>

<H3><A NAME="set">Juggling a few <CODE><STRONG>:set</STRONG></CODE>
options</A></H3>


<P>And that brings up the whole vexed question of lengths of tabs
and lineshifts, which are controlled by three options of the
<CODE><STRONG>:set</STRONG></CODE> command.  When you are in the
editor, type in the <CODE><STRONG>:set</STRONG></CODE> command
query as in the first line below, and see whether the response is
the default -- as given in the line following it:</P>

<PRE><STRONG>
:se sw ts ht</STRONG>
shiftwidth=8 tabstop=8 hardtabs=8
</PRE>

<P>The first of these reflects the primary problem in using
autoindentation.  The <EM>shiftwidth</EM> option was created
to control some commands I haven't discussed yet, which add or
subtract whitespace at the start of each line you designate;
this option sets the number of spaces these commands add or
subtract.  In addition, though, the value of this option also
determines where your left margin will land when you go back
part of the way to your window or screen's left margin.</P>

<P>So if your <EM>shiftwidth</EM> option is set to the default
value of eight spaces, as shown above, then there will be a
stopping point every eight spaces across your screen or window --
in the ninth column, in the seventeenth column, in the 
twenty-fifth column, etcetera.  (This presumes that you call the
leftmost character position on your window or screen column one,
which is what the editor calls it, and not column zero.)  So if
your autoindented margin is in the twenty-first column, typing
control-D at the start of a line will put it back to the
seventeenth column.  If the margin is presently in the eighteenth
or the twenty-fourth column, the effect would be the same.  But
if the present margin is in the twenty-seventh or thirtieth
column, then a single control-D would set it back to column
twenty-five.</P>

<P>Of course, you can reset the <VAR>shiftwidth</VAR> value via the
<CODE><STRONG>:set</STRONG></CODE> command.  Many programmers
reset that value to four.  Then the stop points will be in every
fourth column -- in column five, in column nine, in column
thirteen, in column seventeen, and so on.  This reduces line wrap
in program source code with many levels of tab indentation.</P>

<P>Here's a visual representation of the difference: first of the
default tab stops every eight columns, then as they are when
reset to every four columns:</P>

<PRE>
+-------+-------+-------+-------+-...
1       9      17      25      33

+---+---+---+---+---+---+---+---+-...
1   5   9  13  17  21  25  29  33
</PRE>


<P>But you just might be creating a problem by doing this.  With
identical <EM>shiftwidth</EM> and <EM>tabstop</EM> values,
backing up via a control-D requires only erasing one tab
character or erasing one or more space characters; never anything
more complex.  With a <EM>shiftwidth</EM> value of four and a
<EM>tabstop</EM> value of eight, though, there will be times when
a control-D requires the editor to remove one tab from the
whitespace sequence with which it starts each line, and
simultaneously add four space characters.  A few versions of the
editor cannot handle this complexity in some circumstances, and
will at times put garbage in your file.  Even more likely is that
the editor will mess up when it encounters tab characters in the
middle of lines.</P>

<P>The <EM>tabstop</EM> option controls the number of spaces the
editor thinks you want between tabstops.  With this option at its
default value of eight, there will be a tabstop every eight
spaces, falling in the same columns as the <EM>shiftwidth</EM>
stop points when that option's value was also at its default
value of eight.  So if you set the values of both options to
four, you will still have both options' stop points falling in
the same columns, solving the problem posed in the last
paragraph.</P>

<P>Solving it at quite a price, though.  The editor can use your
special value of four spaces between tabstops (or any other value
you choose to give) when it is inserting and removing tabs as you
type, but it has no way to mark those characters in your file to
say ``This is a four-column tab character'' and ``That is an
eight-column tab character''. Not that there is any difference
between the tab characters themselves.  A tab always moves the
cursor to the next tabstop point in the line, wherever that may
be.  The difference is that some of your tabs will be inserted
when you expected the editor to find a tabstop point every four
columns; others when you (or someone else) were expecting
tabstops every eight columns.</P>

<P>So when you set your tabs value to four and then edit a file
that was composed with tabs at their default value of eight,
indentations will be only about half as deep as the original
writer intended they should be.  And when you write this file
back to permanent storage, anyone who uses the file after you and
has default tab settings will find the indentations you added to
be about twice as deep as you intended -- this will often cause
deeply indented lines to be too long to be displayed on a single
line of the user's screen or window.</P>

<P>Since you've gotten this far in the tutorial, you're surely a
skilled user who can see how to get around this -- by writing a
<CODE>.exrc</CODE> file entry to translate eight-column-tab
indentations into four-column-tab equivalents as you pull in a
file to edit, and a macro to do the reverse in the course of
writing your work out to permanent storage.</P>


<H3><A NAME="you">An Exercise for You</A></H3>

<P>It was several tutorial parts ago that I last put exercises
for the reader in the tutorial itself.  This seems like a good
place to revive that practice.  Just how would you write a
command sequence to handle that latter operation as regards
start-of-line indentations?  Let's say you edit in screen mode,
with your <VAR>tabstop</VAR> option set to a value of four, so that
a ten-column indentation consists of two tabs followed by two
spaces and a thirteen-column indent is three tabs followed by one
space.  But when you write the file to permanent storage, you
want it to be in the conventional format of eight columns between
tab points (at least for indentations) -- so that same ten-column
indentation will now consist of just one tab followed by two
spaces, and the thirteen-column indent will have a single tab
followed by five spaces -- to keep the indentations at the same
depth they were.  What sequence of commands will accomplish
this?</P>

<P>To simplify the problem, assume that the curly brace
characters (``{'' and ``}'') never appear in files you edit (if
they are present, which is common for program source code, choose
another character pair) and that you will only be writing to the
original file name, let ^I stand for a real tab character when
you write your answer, and don't worry about how you would turn
your command sequence into a macro.  But, definitely do remember
that you will be doing a write in the middle of your editing
session from time to time, to guard against losing work in a
system crash, so your command sequence must leave the file copy
in the editor buffer just as it was before you wrote the modified
version to storage, ready for you to continue editing.</P>

<P>This exercise is not so difficult if you've been following
this tutorial carefully.  The biggest hazard for those readers is
that they may come up with a sequence that will work, but is much
longer than it needs to be.  So if your solution seems long-winded, 
take a look at my <A HREF="009.ans.part8.html#h.indent">hint</A> 
before you jump to my <A HREF="009.ans.part8.html#indent">solution</A>.
</P>

<P>These translator macros will work nicely for leading
whitespace (indentations), but it would take incredibly complex
scripts (whether Vi editor scripts or scripts for most other Unix
utilities) to deal with tabs in the interiors of lines.  The
pestilential problem there is that you don't know just where an
interior tab character is placed -- how many positions in from
the start of the line.  For example, when you are trying to
translate eight-column tabs into four-column equivalents, and
your macro finds a single eight-column tab in the middle of a
line, is that tab in a column that is five or more columns from
the next tab stopping point?  If yes, it must be replaced by two
of the four-column tabs; if no, it is correct as it is.
Similarly, when going from four-column to eight-column tabs, a
solitary tab in the middle of a line may be left there or may
have to be replaced by space characters, depending on its column
position.</P>

<P>If you must do this kind of translation, your best bets are
the <CODE>-e</CODE> and <CODE>-i</CODE> options to recent
versions of the <CODE><STRONG>pr</STRONG></CODE> Unix command.
Running a file through this utility will make the conversions
correctly, even when the whitespace appears in the middle of
lines.  The downside is that your text may be reformatted to some
degree.</P>



<H3><A NAME="hard">Hard Tabs</A></H3>

<P>And then there is the <VAR>hardtabs</VAR> option to the
<CODE><STRONG>:set</STRONG></CODE> command.  That option is
used to tell the editor how far apart the tab stopping points
are on your physical terminal -- the editor uses this information
to decide what mix of tab and space characters will represent on
your screen the indentation depth that's in your file.  That is,
the editor runs its own translator program, if necessary, to
make the spacings on your screen the same depth as those in your
file.  Here too, any difference between this value and either of
the previous two is likely to cause problems.  It's fortunate
that any value you give to this option will be overridden by the
spacing value that is in your Termcap or Terminfo file, because a
difference between the terminal tab setting Vi expects and that
which your terminal is actually using will scramble your screen
for sure.</P>

<P>So my reluctant admonition to you is to leave all three of
these options set at their default values of eight.  Messing
around with any of them is just too likely to cause trouble.</P>

<H3><A NAME="endis">Enable and Disable <VAR>autoindent</VAR></A></H3>

<P>Of course, all this means that when you have autoindentation
on, the control-D, circumflex followed by control-D, and zero
followed by control-D
sequences are all metastrings at the beginning of an indented
line.  To turn the metavalue off, so you can put one of these
strings into the text at the start of an indented line, quote in
the control-D character by preceding it with a control-V.</P>

<P>So how do you turn the whole <EM>autoindent</EM> mode on and off?
It's normally off when you begin an editor session, and the usual way
to turn it on is to use the <CODE><STRONG>:set</STRONG></CODE> command.
Just type <CODE><STRONG>:se ai</STRONG></CODE> to turn this feature on.
When you want to tell the editor to stop automatically indenting every
time you start a line with whitespace, type <CODE><STRONG>:se
noai</STRONG></CODE> (from command mode) to turn <EM>autoindent</EM>
off again.</P>

<P>Autoindent also works with the line-mode <CODE><STRONG>append
insert</STRONG></CODE> commands, which can be abbreviated 
<CODE><STRONG>a i</STRONG></CODE> respectively.  These commands
let you type in new lines of text, below or above the current
line, respectively.  That is, they are generally the line-mode
equivalents of the screen-mode <CODE><STRONG>o O</STRONG></CODE>
commands.  They can only be run when you are in line mode; even
preceding one of them with a colon (``:'') will not let you run
it from screen mode.</P>

<P>The setting of the <EM>autoindent</EM> option controls
autoindentation within these text insertions, too, but there is
also another way to control it that works only with these 
line-mode commands.  Whenever you follow one of these commands or
its abbreviation with an exclamation point (``!''), without any
characters or space in between, you toggle the autoindention
setting for that insertion only.  That is, if autoindentation was
off, the ! turns it on during this insertion.  Similarly, if
autoindentation was on at the time, the ! turns it off just for
this insertion.</P>

<P>[<EM>Editor's Note</EM>: Here's an example where it really
helps to disable autoindent.  When programming, I use a simple
<CODE>.exrc</CODE> file containing an <CODE><STRONG>se ai bf nu sw=4
ts=4 wm=0</STRONG></CODE> line.  If I cut a section of indented
lines from one window and paste it into my program I get a
staircase effect as each line is inserted with one more tab than
the last.  Most annoying.]</P>

<H3><A NAME="next">Next Time</A></H3>

<P>The next part of this tutorial will cover the
<CODE><STRONG>:abbreviate</STRONG></CODE> and
<CODE><STRONG>:map!</STRONG></CODE> commands, both of which help
you save typing while you are in text-insertion submode.
Then, on to the editor's several facilities for creating macros
and pseudo-macros that you can use from the command submode.
And it will finish with more readers' questions and my answers,
if you readers will send me some worthwhile questions soon.</P>

<P>You may be laughing at that final word, ``soon'', if you
remember how long it took for this part to appear.  Well, things
will be different this time around.  You have to realize that much
of the delay in posting this part was due to circumstances that
are not likely to be repeated.  Specifically, I was banged up in
a car crash (from which I am recovering fairly well, thank you),
and my editor was called away from editing by McGraw-Hill to
rescue a couple of programming projects that were going awry.</P>

<P>But my secret weapon this time is that, while my editor was
away I spent some time writing about half of the next part.  So,
when she returns from a week of well-deserved vacation in
mid-November, I plan to have the completed tutorial installment
waiting for her.  Wish me luck.</P>

<HR>
 
<DIV ALIGN="center">
<TABLE 	BORDER="0" CELLPADDING="0" CELLSPACING="0" ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">
	<A TARGET = "V" HREF="/cgi-bin/uworld/ads/uwcad?uworld1">




	</TD></TR>
</TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" 
ALIGN="CENTER">
	<TR><TD ALIGN="CENTER">


	</TD></TR>
</TABLE>

</DIV>




<H1>UnixWorld Online: Tutorial: Article No. 009: Part 9</H1>


<H2>Take Charge with Macros</H2>

<P>By <A HREF="/uworld/authors/walter-zintz/bio.html">Walter
Alan Zintz</A>.</P>

<P>Questions regarding this article should be directed to the
author at <EM>walter@ccnet.com</EM></P>

<UL>

<LI><A HREF="#text">Text-Insertion Macros</A></LI>

    <UL>

    <LI><A HREF="#do">What These Tools Do</A></LI>

    <LI><A HREF="#work">Working Principles</A></LI>

    </UL>

<LI><A HREF="#sub">Command-Submode Macros</A></LI>

    <UL>

    <LI><A HREF="#map"><CODE><STRONG>:map</STRONG></CODE> Macros</A></LI>

    <LI><A HREF="#buf">Buffer Macros</A></LI>

    <LI><A HREF="#so"><CODE><STRONG>:source</STRONG></CODE> Macros</A></LI>

    <LI><A HREF="#bang">Write and Read Macros</A></LI>

    </UL>

<LI><A HREF="#next">In The Next Installment of this Tutorial</A></LI> 

<Li><A HREF="#timeout">SIDEBAR: The <VAR>timeout</VAR> Function</A></Li>

</UL>

<H3><A NAME="text">Text-Insertion Macros</A></H3>

<P>As befits an editor with all those built-in metacharacters
that operate while you are typing in text, there are two ways to
create your own macros for use during text insertion.  Both can
be useful in the right circumstances, so you'll probably want to
put them to work at times.  You may not have a choice -- often <A
HREF="009.part5.html#sectionL">the <CODE>.exrc</CODE> file</A>
that you may be given when you get a new Unix shell account has
some of these shorthand dodges built in.  These two tools have as
many similarities as differences, so I will expound them in
parallel.</P>

<H4><A NAME="do">What These Tools Do</A></H4>

<P>Both tools act only when you are in text-insertion submode of
screen-editing mode.  Nonetheless, the commands that set them up
and manage them are line-mode commands like:</P>

<PRE><STRONG>
:ab ucb University of California at Berkeley
:map! } Control-[k2cc
</STRONG></PRE>

<P>The two example lines above will set up two shorthand forms
that you can use without further preliminaries.  The first line
provides that whenever you type ``ucb'' as a separate word in
your text, the editor will replace it with ``University of
California at Berkeley''. It happens right on the spot, and
without any special signal from you.</P>

<P>The second line is for use if you frequently discover that
what you are typing has become a mess, and that the mess started
back on the previous line.  With this shorthand form in effect,
whenever there is a ``}'' character in what you type in, the
editor removes it and instead acts as if you had typed in
``Control-[k2cc''. That is, the Control-[ (generated by the
``Escape'' key on your keyboard) causes the editor to escape from
text-insertion to command mode, the ``k'' causes the cursor to
move up a line, and the ``2cc'' removes both of the lines
involved and puts you back in text-insertion mode, ready to type
in a replacement for those lines and continue on with your text
insertion.  As with the previous tool, this happens as soon as
you type in the shorthand form, without any special action by
you.</P>

<P>Note that whitespace separates either of these setup commands
into three parts.  The first part, from the start of the line up
to the first stretch of whitespace, is just the command name.
Part two, between the first and second stretches of whitespace,
is the short form that you will type into the text.  The third
part, everything following the second stretch of whitespace, is
what the editor will insert (and/or execute) when you type in the
short form.  Only the first two stretches of whitespace are
separators -- any later stretches are integral components of part
three.  And whitespace includes both space characters and tabs,
in any mixture.</P>


<H4><A NAME="work">Working Principles</A></H4>

<P>Now that you've seen what these two tools do, let's consider
how they work:</P>

<DL>

<DT><CODE><STRONG>:abbreviate</STRONG></CODE>

<DD><P>(Shortest abbreviation is
<CODE><STRONG>:ab</STRONG></CODE>). This tool acts when you type
in a certain character or string as a separate word, each end
bounded by whitespace, or a punctuation character, or the start
or end of a line, or the start or end of an insertion.  As soon
as the editor sees that the abbreviation is a word by itself, it
replaces that abbreviation with the longer word or phrase you
have set as equivalent.</P>

<P>As an example, you might have declared ``cat'' as your
abbreviation for ``felix domesticus''. Then, wherever you type in
a line such as ``the habits of the common cat include'', the
editor will promptly change it to read ``the habits of the common
felix domesticus include''. But there will be no such change in
words that happen to include the string ``cat'' in them, such as
``catamaran'' or ``concatenation''. Be careful with this, because
while the word ``catlike'' will not be changed, the word ``cat-
like'' will be.</P>

<P>Neither a backslash (\) nor a control-V will quote an
abbreviation into a file as itself.  Usually, the easiest way to
insert an abbreviation into your text is to escape from 
text-insertion submode (back to command submode) in the middle of
typing the abbreviation, then re-enter text-insertion submode and
type in the rest of the abbreviation.  If your abbreviation is
only one character long, though, you must fall back on typing the
abbreviation with a letter immediately before or after it, then
returning to command submode to erase the unwanted extra
letter.</P>


<DT><CODE><STRONG>:map!</STRONG></CODE>

<DD><P>(No editor-accepted abbreviation). Very similar to the
abbreviation tool discussed above, but with three major
differences:</P>

<OL>

<LI>The shorthand form defined with this command does not need to
be typed into your inserted text as a separate word in order to
operate.  Even if it is embedded within another word, the short
form will disappear and its related text will be entered in its
place.</LI>

<LI>This tool does not simply insert the related text into the
file, as the <CODE><STRONG>:abbreviate</STRONG></CODE> tool does;
it acts as though the user had typed in the related text instead
of the short form.  That is, if there is an escape character in
the related text, that escape will put the editor back into
command submode, and interpret any following characters as
screen-mode commands.  (Unless one of those characters returns
you to text insertion submode -- then characters following that
insert-text command will be all be put into the file, unless and
until there is another escape character.)  That makes
accidentally triggering this tool rather dangerous.</LI>

<LI>Quoting in a character or string that you've defined as a
short form via this command is simple.  Type control-V before the
metacharacter, or the first character of the metastring, and into
the text it goes.  Even that may not be required if you are
dealing with a metastring, and if the <VAR><A
HREF="#timeout">timeout</A></VAR> option to the
<CODE><STRONG>:set</STRONG></CODE> command is still in its
default state: turned on.  In this case, all you need to do is be
sure that you take more than one full second to type in the
entire metastring, and it will have no meta effect.  (This, by
the way, is one reason that this tool's metastrings should be
short -- so you can depend on being able to type one of them in
less than a full second when you do want the metavalue.)</LI>

</OL>

</DL>

<P>Questions naturally arise regarding these tools.  One frequent
query is why anyone would want to mess around with
<CODE><STRONG>:abbreviate</STRONG></CODE> when it seems much
easier to do a general substitution command when the document is
complete.  That is, instead of that abbreviation I set up at the
start of this explanation, just run a
<CODE><STRONG>:%s/\&lt;ucb\&gt;/University of California at
Berkeley/g</STRONG></CODE> command after all the text has been
entered.  There are several reasons to use Vi's abbreviation
feature instead:</P>

<UL>

<LI>It's not hard to unknowingly type in your abbreviated string
where you don't want it expanded, as in a direct quotation (Savio
told the students, ``We don't want ucb to get the upper hand!''),
or where it has an entirely different meaning (Next, punch in the
code: aQr PxN ucb JHt.)  Using the substitution command above,
you would never see that these sentences were being disfigured.
But with on-the-spot replacement the mistaken use would be right
in your face.</LI>

<LI>Lines can get very long when abbreviations are expanded,
especially when there are several abbreviations in one line.
When you use a general substitution command after text entry,
there's no way to know that certain lines have become
unreasonably long.  But with the
<CODE><STRONG>:abbreviate</STRONG></CODE> tool, you see the final
length of each line as you go along.  And if you use the
<VAR>wrapmargin</VAR> option to the
<CODE><STRONG>:set</STRONG></CODE> command, line breaks will
generally be inserted after any abbreviations have been
expanded.</LI>

<LI>It's easy to forget to run a general substitution command.
But a <CODE><STRONG>:abbreviate</STRONG></CODE> command can be
made automatic by putting it in a <CODE>.exrc</CODE> file, and the
user can see while typing whether it is or is not in
operation.</LI>

<LI>This tool can do more than save typing.  For example, suppose
a technical writer is in the habit of typing ``unix'', while
company policy requires ``UNIX(R)''. Either a general
substitution or the <CODE><STRONG>:abbreviate</STRONG></CODE>
tool will correct that writer's recurring errors, but only the
latter will continuously teach him that ``unix'' is not to be
used.  As another example, consider a writer who begins far too
many sentences with the word ``The'', which makes for dull
reading.  A <CODE><STRONG>:ab The DON'T OVERDO
IT!</STRONG></CODE> command will ensure that every time this
writer types the word ``The'' at the start of the sentence, it
will promptly be transmuted into the billboard phrase ``DON'T
OVERDO IT!'', which can be backspaced over to insert a new
sentence beginning.  Note that this will not be triggered by
words such as ``These'' or ``Then'', nor by the word ``the'' in
the middle of a sentence.</LI>

</UL>

<P>Another common question concerns precedence of metacharacters.
You can use most of the text-input metacharacters I've discussed
previously as short-form names in
<CODE><STRONG>:map!</STRONG></CODE> commands.  Suppose you did
use control-D as such a short form -- what would happen when you
typed control-D at the start of an autoindented line?  Would it
wipe out the indentation or type in the phrase that
<CODE><STRONG>:map!</STRONG></CODE> has associated with it?  Or
if you used control-H as a short form?  When you subsequently
typed a control-H during text entry, would the cursor back up a
space, or would type in a stored phrase?</P>

<P>The answer is that the <CODE><STRONG>:map!</STRONG></CODE>
value would prevail.  By preceding either character with a
control-V, you could type in in as itself, but there would be no
way to use the ordinary metavalue of either character.  If you
were to map control-D followed immediately by another control-D
or two consecutive control-H characters or any other doubling of
an ordinary metacharacter, the situation would be more complex.
You could then type the two control-D or control-Hs within one
second to get the mapped text typed in, or you could type
control-D or control-H followed by a one-second pause to invoke
the ordinary metavalue.</P>

<P><STRONG>Time for another exercise</STRONG>.<BR>
Suppose that you used control-D or control-H as a short form with
the <CODE><STRONG>:abbreviate</STRONG></CODE> command.  Or
suppose that you used some ordinary character string as both an
abbreviation and a mapping short form.  (The editor will allow
you to do this.)  What would happen when you typed in this
double-use short form during text insertion?  This exercise is
straightforward enough that I expect most of you will find the
correct answer before you look at <A
HREF="009.ans.part9.html#double">my solution</A>.</P>


<P>Two final warnings.  Do not try to define a non-alphanumeric
character or string as a short form with the
<CODE><STRONG>:abbreviate</STRONG></CODE> command.  You probably
will be able to do this -- the editor won't object -- but when
you try to use this abbreviation, nothing will happen.  And with
either <CODE><STRONG>:abbreviate</STRONG></CODE> or
<CODE><STRONG>:map!</STRONG></CODE>, do not put any metacharacter
as itself into the long-form string.  Even if you manage to get
it into the string as itself, it will not go into your text that
way.</P>

<P>What if you have forgotten what short forms you have set up,
or are uncertain as to whether some may have been set up for you
via a <CODE>.exrc</CODE> startup file?  Well, you can query
either tool just by giving its setup command without any
arguments.  Here are examples of those queries, with the
responses you might receive from the editor:</P>

<PRE>
<STRONG>:ab</STRONG>
cat   cat   felix domesticus
wolf  wolf  canis lupus

<STRONG>:map!</STRONG>
{     {     ^[o^I^IThe End^[
}     }     ^[o^I^I-XXX-^[
~     ~     (more to come)^[
</PRE>

<P>Note that each response line has at least three strings of
printing characters, separated by whitespace.  It's that second
string in a line that is the short form; the string that when
typed in will be replaced by the last string shown.  (Yes, in
every example line above the first string is identical to the
second, but that isn't always so.)  The last string is what will
be inserted and/or executed.</P>

<P>So now you know what characters and strings will have to be
quoted in when you want to insert them as themselves.  And if one
or more of those short forms is something you will be typing in
so often that you can't spare the time to quote it in each time
you use it, you can disable the metavalue for the rest of the
present editing session.  Just give the command name for the tool
that uses this short form but precede it with ``un'', and as the
only argument give the short form you want to disable.  For
example, here are the commands that will disable the first entry
in each of the lists above:</P>

<PRE><STRONG>
:unab cat
:unmap! {
</STRONG></PRE>


<H3><A NAME="sub">Command-Submode Macros</A></H3>

<P>It's common that a text editor has a facility that lets a user
create personalized commands, usually as macros built on existing
commands.  The Vi/Ex editor has four such facilities -- something
for every need.  While these facilities don't have the low-level
programmability of mock-Lisp, they can accomplish a lot to
simplify your editing, and you don't need to learn a programming
language to use them.</P>

<P>I'll be discussing each facility (or family) in its own
section below, because their structures are quite different.
Nonetheless, you can often combine them to good effect, by using
a macro of one type to call a macro of a different type.</P>


<H4><A NAME="map"><CODE><STRONG>:map</STRONG></CODE> Macros</A></H4>

<P>This is the editor tool that's closest to what most users
think of as a macro facility.  It uses the command
<CODE><STRONG>:map</STRONG></CODE> as its setup tool, and the
macros it creates operate when the user is in command submode of
screen-editing mode.  Otherwise it works just the way its very
close relative, the <CODE><STRONG>:map!</STRONG></CODE> tool,
works -- which I explained in depth in the first half of this
tutorial part, above.  Consider the three command lines
below:</P>

<PRE><STRONG>
:map v :!wc -w %Control-M
:unmap v
:map
</STRONG></PRE>

<P>The first line sets up a macro that does a word count on the
file I am editing, as of the last write to storage, whenever I
type the letter v from command submode while I am screen editing.
The second unsets that macro, so that a v command no longer does
anything.  The third displays a list of the
<CODE><STRONG>:map</STRONG></CODE> macros that are currently in
effect.  All this should be transparently plain to readers who
understand the <CODE><STRONG>:map!</STRONG></CODE> tool.  Still,
there are a few points worth noting that are particularly
applicable to the <CODE><STRONG>:map</STRONG></CODE> side of the
family.</P>

<P>Choosing a short-form for <CODE><STRONG>:map</STRONG></CODE>
macros should not be difficult.  Half a dozen of the printing
ASCII characters and many of the control characters are not used
as screen-editing commands or addresses.  Hardly any strings of
two duplicate characters (such as ``DD'' above) are in use, and
most editor versions will let you map such strings.  You don't
need to avoid duplicating your
<CODE><STRONG>:map!</STRONG></CODE> short forms because the name
spaces are completely separate.  That is, if you use a particular
character or string as a <CODE><STRONG>:map</STRONG></CODE>
short-form and also as a <CODE><STRONG>:map!</STRONG></CODE>
short-form; for example:</P>

<PRE><STRONG>
:map }} :!wc -w %Control-M
:map! }} Control-[j0R
</STRONG></PRE>

<P>there is no conflict.  The editor will allow both mappings,
and will use the correct long-form based on the context; whether
you typed }} from command or text-insertion submode.  As the
first example above shows, your command string can include any of
the line-mode commands that can be invoked from screen mode,
providing you begin each one with a colon ``:'' as you would when
invoking it directly while in screen mode, and quote in a
Control-M (the RETURN character) to terminate the command.</P>

<P>Suppose that you ran the two following setup commands, either
one first:</P>

<PRE><STRONG>
:map Q 2dd
:map V 3jQ
</STRONG></PRE>

<P>The first command clearly provides that the
<CODE><STRONG>Q</STRONG></CODE> command, which ordinarily is the
command that takes you out of screen mode and into line mode,
does not do that any more.  Instead, it now deletes two lines,
and you now have no way to leave screen mode without unmapping
the ``Q'' character.  But what does the new
<CODE><STRONG>V</STRONG></CODE> do?</P>

<P>If you've left the <CODE><STRONG>:set</STRONG></CODE>
command's <VAR>remap</VAR> option turned on, its default value,
then the <CODE><STRONG>V</STRONG></CODE> drops down three lines
and then deletes that third line and the one following.  That is,
when it comes to the ``Q'' character in that mapping, it
discovers that ``Q'' itself has been mapped, and brings in the
mapped value of ``Q''. But if you had previously run a
<CODE><STRONG>:se noremap</STRONG></CODE> command, then the
editor would not check for any mappings of the characters within
a macro, and would use the standard meaning of ``Q'' when it
executed the ``V'' macro.  So then typing a ``V'' character would
move you down three lines and then put you into line-editing
mode.  (Yes, that means that while you would no longer be able to
execute the <CODE><STRONG>Q</STRONG></CODE> as itself directly,
your macros could still access it!)</P>


<H4><A NAME="buf">Buffer Macros</A></H4>

<P>There are limits to the amount of macro text you can store by
mapping it -- not as severe now as with earlier versions of the
editor, but still somewhat confining.  To remedy that, the editor
offers a quite-similar tool with practically unlimited storage.
It involves those buffers where you store text pulled from your
file, for later reinsertion at various places.  Specifically I
mean the twenty-six buffers named ``a'' through ``z''.</P>

<P>From screen-editing command sub-mode, you can type an at-sign
``@'' followed by a letter of the alphabet, and the editor will
take the contents of the buffer with that letter-name and execute
it as a screen-mode command string.  For example, if you have
``0d3w'' (without the quotation marks) stored in named-buffer 
``k'', then typing <CODE><STRONG>@k</STRONG></CODE> will delete the
first three words on the current line.  After you start using
this method in your editing session, there's an extra added
convenience available: typing <CODE><STRONG>@@</STRONG></CODE>
will repeat the last such buffer command you ran.</P>

<P>To put a command into a named buffer, get the line or lines of
your command into your file one way or another, then delete or
yank them into the buffer of your choice, as by:</P>

<PRE><STRONG>
"p3dd
:ya m
</STRONG></PRE>

<P>to delete a three-line macro into buffer ``p'' and yank a 
one-line macro into buffer ``m'', respectively.  You need not
tell the editor that you regard the contents of a buffer as a
command macro until you choose to execute it with a ``@''
command.  In fact, you can use a buffer's contents both ways,
executing it as a command at one moment and putting it back into
your file as text the next.</P>

<P>One important difference from macros created by mapping: if
you need a linebreak character in a buffer macro, don't try to
quote it in.  Instead, type it in the ordinary way, so that it
forms a line break between two lines of your macro text.  And
don't break a line in your macro text for any other reason,
because the linebreak character that appears there will be
treated as a command character by the editor when you execute the
buffer contents as an editing command string.</P>


<H4><A NAME="so"><CODE><STRONG>:source</STRONG></CODE> Macros</A></H4>

<P>Line-mode commands have a macro tool in this editor, too.  Of
course you can insert most line-mode commands in the previous two
types of macros, but this tool is dedicated entirely to line-mode
commands, and can include even commands that can't be run
interactively from screen mode via a preceding colon.  The only
line-mode commands that can't be run with this tool are the
<CODE><STRONG>visual</STRONG></CODE> and
<CODE><STRONG>open</STRONG></CODE> commands.  With this tool, you
set up your macros by putting their commands into one or more
files, then invoke them with command lines like:</P>

<PRE><STRONG>
:so /u/myname/commands.1
</STRONG></PRE>

<P>Your command files should contain strictly line-mode commands,
one per line unless you separate them within the line by pipe
``|'' characters, and should not have a colon before each
command.  The other restrictions depend on how you plan to invoke
your macro files.  Ideally you should give your
<CODE><STRONG>source</STRONG></CODE> commands while you are in
line mode -- then the above limitations are all you will face.
But if you insist on invoking
<CODE><STRONG>:source</STRONG></CODE> while in screen mode, there
are two other limitations:</P>

<OL>

<LI>Only the first line of your command file will execute.  Due
to the editor restriction against running multi-line line-mode
commands while in screen mode, all lines after the first in your
command file will be silently discarded.</LI>

<LI>If your first command is not complete on the first line (for
instance, an <CODE><STRONG>append</STRONG></CODE> is not), even
that command will not execute.  In this case the failure will not
be silent.</LI> 

</OL>

<P><STRONG>Another Exercise</STRONG><BR>
So if you want to source in command files from within screen
mode, it's a very good idea to create one-line command files.
But there will be a few cases where multi-line command files will
be a worthwhile thing, even when you may be invoking them from
screen mode.  Here's an easy exercise for you: come up with a
specific case in which a command file that you may source in from
either line or screen mode should nonetheless have more than one
line.  Of course there are multiple possibilities here, so don't
be disturbed if the solution that occurs to you is not one of
those I arbitrarily chose for my <A
HREF="009.ans.part9.html#multi">answer</A>.</P>

<P>When you really get into sourcing, you'll be pleased to know
that <CODE><STRONG>:source</STRONG></CODE> files can contain
commands to call other <CODE><STRONG>:source</STRONG></CODE>
files.  This is the basis for truly modular editor scripts, and
for a raft of rather tricky maneuvers.  It also saves typing when
you need to invoke a source file from screen mode, but the list
of commands is simply too long to fit on one line: a single line
in your initial source file is long enough to call a very large
number of other source files, each with a single long line of
commands.  You will probably find that invoking nested
<CODE><STRONG>:source</STRONG></CODE> files from line mode will
turn off line mode's colon prompt, but you can turn it back on
again via a <CODE><STRONG>:se prompt</STRONG></CODE> command.</P>


<H4><A NAME="bang">Write and Read Macros</A></H4>

<P>The Vi/Ex editor has tools for running some or all of the
lines in the file you're editing through a program outside the
editor, then using the transformed lines to replace the original
lines in your file.  It can also run a program with any or no
input and insert the program's output in your file, or write some
or all of your file lines as input to a program that may send its
output anywhere.</P>

<P>And where is the macro capability in all this?  Well, when you
use these tools you are not limited to standard Unix utilities as
your outside programs -- your own coding will do just as well.
Compiled or scripted, one line or a thousand, in a standard
language like C or Perl or in a specialized one such as Snobol;
the rule is that if your Unix system will execute it, the editor
can pass it over your text.</P>

<P>This tutorial is not going to get into writing these personal
text processors, in any language, so I will only be explaining
how to send your text in and/or out via editor tools.  In the
examples below, I will suppose you have a text-processing program
named <CODE>myhack</CODE> that lives within your searchpath.</P>

<P>[<EM>Editor's note</EM>: One external program I use frequently
reformats paragraphs into nicely looking text blocks that are
easier to read.  I use the program named <CODE>reform</CODE>,
published on pages 320-321 in the first edition of the famous
book <CITE>Programming Perl</CITE> by Larry Wall and Randal L.
Schwartz.  At first blush you may ask, why use such an external
program when I can simply set Vi's wrapmargin variable?  Of
course, the answer is how do you easily reform paragraphs that
are already ragged, say due to the problem Walter posed above
(using find and replace to expand abbreviations, instead of
expanding abbreviations using the built-in Vi abbreviation
macro facility?]</P>

<P>Note that the command to execute the outside program should be
typed as you would type it at your shell prompt, because it will
be passed to the shell intact except for the addition of input
and/or output redirection.</P>

<P>If you want to take some (or all) of the lines out of your
file, use them as input to your outside program, then put the
resulting output in place of the original lines, you can use
either a line-mode or a screen-mode command to do it, as shown
below:</P>

<PRE><STRONG>
:196,254 ! myhack -n6
!L myhack -n6
12!! myhack -n6
!/^CHAPTER/- myhack -n6
</STRONG></PRE>

<P>The line-mode command can be invoked from line mode, or from
screen mode by preceding it with a colon.  In either case, you
give an address or address range, next the exclamation point,
then everything following until you type return is passed to the
shell as a command line.  The line-mode command must have at
least one address because there is no default address for this
command.  But the whitespace I show before and after the
exclamation point is permissible but not necessary; I put it in
solely for readability.</P>

<P>Screen-mode command form is the exclamation point as the
command name, followed by the target address, then the outside
command (with arguments and/or whitespace as would be required or
permitted on your shell command line), ending when you hit the
escape or return key.  As with the <CODE><STRONG>c d
y</STRONG></CODE> commands, you can type two consecutive
exclamation points to send just the current line, and use a count
to send that number of lines as shown in my third example
command.  The last example involves an extra escape character --
at the end of a search pattern address, whether / or ? based and
including any + or - suffix, you must press the escape key before
you start typing the outside command.</P>

<P>You're not limited to just one outside program at a time.  You
can pipeline two or more together as your shell permits,
ordinarily with the ``|'' character.  (Because a | character and
what follows it will be passed to the shell, this editor command
cannot appear in a line-mode command string, including a
<CODE><STRONG>:global</STRONG></CODE> string, unless it is the
last command in the string.)  The final output of the pipeline is
what will go into your file.  And you can undo the effect of the
outside command or pipeline, putting your file back the way it
was, with a <CODE><STRONG>u</STRONG></CODE> command.</P>

<P>You may not want your text to make a round trip, though.  You
may want to send your text, as modified by your outside program,
off to some other destination, or you may want to pull some text
into your file that originated in your outside program, or was
taken from some outside source.  In these cases, use the 
line-mode commands that appear below:</P>

<PRE><STRONG>
:1,.w ! myhack -n6 &gt; nufile
:217r ! myhack -n6 &lt; oldfile
</STRONG></PRE>

<P>The first command above sends the initial lines from the file
you are editing as input to your <CODE>myhack</CODE> program, and
redirects the output to a file.  It does not erase the affected
lines from the file you are editing.  The second runs your
<CODE>myhack</CODE> program using the contents of another file as
the input, then places the output in the file you are editing,
right after line 217.</P>

<P>Both line-mode commands are shown with addresses, but they are
not necessary.  The default address for a
<CODE><STRONG>:write</STRONG></CODE> command is the entire file;
for a <CODE><STRONG>:read</STRONG></CODE> command, right after
the current line.  The space character just before the
exclamation-point flag after each command is absolutely
essential; without it you would get something greatly different
from what you expected.</P>

<P>Usually there will be output redirection for the
<CODE><STRONG>:write&nbsp;!</STRONG></CODE> command, and input
redirection for the <CODE><STRONG>:read&nbsp;!</STRONG></CODE>
command, but not always.  For example, you may want to
<CODE><STRONG>:read&nbsp;!</STRONG></CODE> an outside command
that generates a pseudo-random number, using no input at all.
When you do need input or output, you can build the necessary
redirection into your outside program or you can put the
redirection on the command line as shown above, using your own
shell's notation.</P> 


<H3><A NAME="next">In The Next Installment of this Tutorial</A></H3> 

<P>I'll be putting the techniques I've taught so far to work,
showing how to set up the editor for special purposes.  Your
suggestions on what special purposes to consider are welcome, of
course.  One purpose that is already in my mind is an arrangement
of the editor for computerphobes: very simple, with beginner
features such as ``stateless'' editing, and fortified against
common user errors.</P>


<H3><A NAME="timeout">SIDEBAR: The <VAR>timeout</VAR> Function</A></H3>

<P>The <CODE><STRONG>:set</STRONG></CODE> command's <VAR>timeout</VAR>
option seems arcane in purpose and tricky to use, at least to some
editor users.  But it becomes pretty plain when you know why and how
it actually works.</P>

<P>Basically, when the <VAR>timeout</VAR> option is on (its default
state) and you type in a short form you've set up by a
<CODE><STRONG>:map</STRONG></CODE> or
<CODE><STRONG>:map!</STRONG></CODE> command, you must type the entire
short form in no more than one second.  If you miss that deadline,
the editor will ignore the metavalue, and take the characters you've
typed at their face value.</P>

<P>This odd requirement serves a purpose; preventing deadlock.  As
an example, suppose you have defined ``DD'' (without the quotation
marks) as a macro via the <CODE><STRONG>:map</STRONG></CODE>
command, and have turned off the <VAR>timeout</VAR> option.  Now,
while editing, you type a plain <CODE><STRONG>D</STRONG></CODE>
command to delete part of a line.  When the editor receives this
single ``D'' it is uncertain what to do.  Are you actually telling it
to delete that partial line?  Or are you starting to type in your
double-D macro?  The only way the editor can resolve this question
is to wait and see what character you type in next.  But if you are
waiting to see the result of your deletion before you do any more
editing, the mutual wait will last indefinitely.  With the
<VAR>timeout</VAR> option left turned on, the wait will only be
a second or so before the editor acts on your D command.</P>

<P>One moral of this story is to leave <VAR>timeout</VAR> on
unless you have a compelling reason to turn it off, and choose
your macro names so that you can easily type them in within the
one-second limit.  If you are not particularly nimble fingered, or
if other people may be using your editor macros, then for practical
purposes this means either a single character or two repetitions
of one character as in my example above.  (Some fussy versions of
the editor will refuse to map anything except a single character.)</P>

<P>Another moral is to avoid certain macro names, such as ``jj''
(again, without the quotation marks).  The standard address j
is one that you might want to type twice in rapid succession, to
move directly down two lines without the trouble of reaching away from
the central keyboard to hit the 2 key.  But the user with a macro
named jj had better not move down too quickly via that method,
or he/she will accidentally invoke the macro of that name.</P>

<P>Finally, you should realize that the one-second count before
timing out is not hair-splittingly accurate.  The design of the
standard Unix software clock means that the time-out interval may
be a little less or somewhat more than precisely one second.</P>

<HR>
 
<FONT SIZE="-1">
Copyright &#169; 1995-1998 Walter Alan Zintz. All Rights Reserved.<BR>
<ADDRESS>
Edited by Becca Thomas / Online Editor / UnixWorld Online / editor@unixworld.com
</ADDRESS>

Last Modified: Wednesday, 04-Feb-98 13:09:38<BR>
URL: http://www.unixworld.com/uworld/archives/95/tutorial/009/009.part9.html
</FONT>
 


Modified: Mon 02 Jul 2001 08:51:48 (Bob Heckel)
<H3><U>Solutions</U></H3>
<A NAME="#q1pt2"></A>
<B>Solution to ``EXPORT'' Problem </B>
<BR>
1 ; ?EXPORT? delete
<BR>
will do it. By starting from the first line in the file and searching
backwards, you guarantee the the first line to be searched will be the last
line of the file (due to wraparound), then the second-to-last line, etcetera.
As soon as the editor finds a match it stops, so there cannot be another
``EXPORT'' lower down in the file. 
<BR>
<BR>
<BR>
<A NAME="#q2pt2"></A>
<B>Solution to First-Line Problem </B>
<BR>
This requires two commands: 
<BR>
$ print
<BR>
/EXPORT/ delete
<BR>
The first command prints the last line in the file, which is not helpful in
itself, but also leaves that last line as the current line. Then, the address
of the second command causes a forward search and, due to wraparound, the
search must begin with the file's first line. 
<BR>
<BR>
<BR>
<A NAME="#q3pt2"></A>
<B>Solution to Noninclusive Problem.</B>
<BR>
Just add a plus sign after the address before the comma, and a minus sign to
the address after it, like this: 
<BR>
?abc? + , /xyz/ -
<BR>
or better  
<BR>
?abc? 1, /xyz/ -1 d
<BR>
Each of these offsets moves one line toward the center of the text section the
combined address specifies, so each has the effect of leaving out the line
where the match was found. (That the first search was backward and the second
forward is not relevant. The point is that the address before the comma,
whatever it is, receives the plus offset, while the address after the comma
gets the minus offset.) 
<BR>
<BR>
<BR>
<A NAME="#q1pt3"></A>
<B>Solution to Copy and Decapitalize Problem </B>
<BR>
One straightforward solution is: 
<BR>
global /^CHAPTER/ mark a | copy $ | 'a substitute /APTER/apter/
<BR>
which marks the original line, then copies it in its all-caps version to the
end of the file, and finally returns to the original line to run the
decapitalizing substitution. 

Another, not quite so obvious but just as good, is to decapitalize "CHAPTER"
first, then copy the decapitalized version to the end of the file, and finally
run a substitution command on the current line (which is now the copied line at
the end of the file) which changes the capitalization back to "CHAPTER". 
<BR>
<BR> 
<BR> 
<A NAME="#q1pt4"></A>
<B>Solution to k37 Problem </B>
<BR>
% substitute /\(.*\)k37\(.*k37\)/\1q53\2
<BR>
will do it. When there are two or more wild cards in a search pattern, the
editor finds the longest match for the first one that allows any match for the
subsequent ones, and so on. 
<BR>
<BR>
<BR>
<A NAME="#q2pt4"></A>
<B>Solution to Capitalization Problem </B>
<BR>
237 , 289 substitute :[^ ]*:\L\u&:g
<BR>
Since the ``\u'' and ``\l'' metacharacters have limited reach, they don't end
the effect of a ``\L'' or ``\U'' metacharacter--they only make a one-character
exception. 
<BR>
<BR>
Author's Note: Since I wrote this solution, I have learned that it will not
work under many implementations of the editor. So, I've added below an
alternate solution, more complex but more powerful, that should work
everywhere. 
<BR>
<BR>
237 , 289 substitute :\([A-Za-z]\)\([A-Za-z-]*\):\u\1\L\2:g
<BR>
<BR>
Even in editing environments where my first solution would work, the second one has certain advantages: 
<BR>
<BR>
The second solution is not fooled by situations where a punctuation mark leads
off a word.  It's up to you whether the second solution does or does not
capitalize any but the first word in hyphenated compounds such as
Frankfurt-am-Main. If you want to capitalize those subsequent words, just
remove the last of the three hyphens within the second character class in my
alternate solution. 
<BR>
<BR>
<BR>
<A NAME="#q3pt4"></A>
<B>Answer to No-Op Problem </B>
<BR>
The editor thinks a substitution has been successfully made whenever the
outgoing search patter n is matched and no error condition is encountered, even
if it is only replacing nothing with nothing. So when the editor finishes up by
reporting the number of substitutions it has made, it is giving me a count of
the empty lines in my file, which tells me how many paragraphs plus headlines
plus list items I have. Then I divide this number into the count of lines in
the file, to see whether my paragraphs have gotten too long. 
<BR>
<BR>
<BR>
<A NAME="#q4pt4"></A>
<B>Solution to HTML tags problem </B>
<BR>
Where the substitution command to add a tag at
the start of a paragraph presently removes and then replaces any first
character on the line, now it should remove and replace anything except a
``<'' character in that position. If that first character is a ``<'' it is
necessary that the substitution command fail so it will change nothing. To
arrange this, replace that period in the search pattern with a negative
character class--``[^<]''-- which matches any character except the one that
begins every HTML tag. 
<BR>
<BR>
Similarly, replace the period in the other substitution pattern with the
negative character class that matches any character except the one that always
ends an HTML tag. Now the two commands will look like this: 
<BR>
<BR>
<pre>
global /^$/ + substitute /^[^&lt;]/&lt;P&gt;&amp;/
global /^$/ - substitute :[^&gt;]$:&amp;&lt;/P&gt;:
</pre>


<pre>

</BODY>
</HTML>

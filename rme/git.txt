# Adapted https://think-like-a-git.net/sections/rebase-from-the-ground-up/a-helpful-mnemonic-for-git-rebase-arguments.html

        F <-- G <-- H foo
       /
 A <-- B <-- C <-- D <-- E bar
             \
              I <-- J <-- K baz

git checkout foo
git checkout -b newbar
git cherry-pick C D E

        F <-- G <-- H <-- C' <-- D' <-- E' newbar
       /
 A <-- B <-- C <-- D <-- E bar
             \
              I <-- J <-- K baz

git checkout bar
git reset --hard newbar
git branch -d newbar

        F <-- G <-- H <-- C' <-- D' <-- E' foo
       /
 A <-- B <-- C
             \
              I <-- J <-- K baz

BUT NOW THAT YOU KNOW THAT...
All that is equivalent to this:

git rebase foo bar

---

# Adapted https://think-like-a-git.net/sections/testing-out-merges/the-savepoint-pattern.html
You're on the master branch and you want the changes from the
spiffy_new_feature branch to be incorporated into master. You're reasonably
confident that you'll want to keep the changes, but you want to be able to abort it.

$ git status
# On branch master
nothing to commit (working directory clean)

Create a new branch to use as a savepoint, but don't switch to it:
$ git branch savepoint

Do the merge:
$ git merge spiffy_new_feature

If you're lucky, there won't be any merge conflicts you can't resolve.
But if you want to abort the merge at this point, just type git reset --hard savepoint

* After a merge, you should see a new commit.
* The new commit should have a message like "Merge branch 'spiffy_new_feature' into master".
* Your master branch label should have moved to this new commit, while the spiffy_new_feature branch label should still be in the same place.

Are you happy with the result?
If YES: Delete the savepoint:
$ git branch -d savepoint
If NO: Reset your branch to the savepoint:
$ git reset --hard savepoint

If you want to clean up, you can now delete the savepoint with git branch -d savepoint.

BUT NOW THAT YOU KNOW THAT...
Just skip the savepoint branch since git doesn't care what you call your branches.  Then after the whoops:
$ git log  # find the previous sha1 that you merged into
$ git reset --hard 4ce7e40

---

-- Change remote
14093  2021-08-17 12:01:10 exec ssh-agent bash
14094  2021-08-17 12:01:31 git remote remove origin
14096  2021-08-17 12:01:45 ssh-add ~/.ssh/id_rsa2
14097  2021-08-17 12:02:00 git remote add origin git@github.com:as-institute-corp/rion-data.git
14098  2021-08-17 12:02:04 git remote show origin
                           git remote -v
                           ??git branch --set-upstream-to=origin/rion-data develop
                           ??git branch --set-upstream-to=origin/develop develop
alias ss 'exec ssh-agent bash; ssh-add ~/.ssh/id_rsa2'

---

 8556  2020-10-12 09:26:37 gco
 8557  2020-10-12 09:26:41 gpul
 8558  2020-10-12 09:50:53 gco 46628
 8559  2020-10-12 09:52:30 git merge develop
 8570  2020-10-12 09:52:35 gpul
 8561  2020-10-12 09:52:54 gco
 8562  2020-10-12 09:53:49 git merge --squash feature/RION-46628
 8564  2020-10-12 09:55:37 git add . && git commit -m 'RION-46628: RION_LIFECYCLES_DETAILS data request' && git push
 8573  2020-10-12 10:10:16 git branch -d feature/RION-46628
 8574  2020-10-12 10:10:30 git fetch -p
 8575  2020-10-12 10:10:44 git push origin --delete feature/RION-46628

---

https://stackoverflow.com/questions/2472254/when-should-i-use-git-pull-rebase
Alice creates topic branch A, and works on it
Bob creates unrelated topic branch B, and works on it
Alice does git checkout master && git pull. Master is already up to date.
Bob does git checkout master && git pull. Master is already up to date.
Alice does git merge topic-branch-A
Bob does git merge topic-branch-B
Bob does git push origin master before Alice
Alice does git push origin master, which is rejected because it's not a fast-forward merge.
Alice looks at origin/master's log, and sees that the commit is unrelated to hers.
Alice does git pull --rebase origin master
Alice's merge commit is unwound, Bob's commit is pulled, and Alice's commit is applied after Bob's commit.
Alice does git push origin master, and everyone is happy they don't have to read a useless merge commit when they look at the logs in the future.
Note that the specific branch being merged into is irrelevant to the example. Master in this example could just as easily be a release branch or dev branch. The key point is that Alice & Bob are simultaneously merging their local branches to a shared remote branch.

---

$ git pull && git checkout -b feature/RION-40225 && git push --set-upstream origin feature/RION-40225
Already up to date.
Switched to a new branch 'feature/RION-40225'
Total 0 (delta 0), reused 0 (delta 0)
remote:
remote: Create a pull request for 'feature/RION-40225' on GitHub by visiting:
remote:      https://github.as.com/rion/data/pull/new/feature/RION-40225
remote:
To github.as.com:rion/data.git
 * [new branch]              feature/RION-40225 -> feature/RION-40225
Branch 'feature/RION-40225' set up to track remote branch 'feature/RION-40225' from 'origin'.

...do commits on your feature...

WITHOUT GITHUB PR/UI: gco && gpul && gco 39 && git merge develop && gpul && gco && git merge --squash feature/DMA-39 && git add . && git commit -m 'DMA-39: SP Issue #8 - Prevent ORA-04065 UI Errors' && git push && git branch -D feature/DMA-39 && git fetch -p && git push origin --delete feature/DMA-39

---

1. Using git to commit a small fix directly into a local branch directly tracking the same remote branch.  In this example we will commit a small fix into the develop branch
git checkout develop
checks out your local develop branch which brings your file system to that version of the files

git pull
 Fetches any changes from the remote develop and merges them into your local develop branch.  If this is a clean environment (no commits to be pushed) this should be a simple fast forward to the latest commit.

Edit files in IntelliJ or elsewhere

git commit -a
This commits any tracked files (files git already knows about).  By default it will launch an editor where you can view the modified files, and provide a commit message.  It also provides some summary information about the status of the local branch (for example how many commits it is behind/ahead/etc.

git push
Pushes your new commit to the remote.  If this was a small enough change, and no one has pushed any additional changes since you last pulled, then this should be seamless.  If not you will need to decide if you want to rebase your change on top of the current commits on the remote, or merge those changes into your local develop branch before pushing again.  In general for small fixes without a lot of commit history I prefer to rebase which will recreate your commit on top of the commit on the remote.   You would have to deal with any merge conflicts at this point.


2. Using git to create a feature branch and then merge that feature branch into a remote tracking branch before pushing to the remote.
git checkout develop
Check out your local develop branch as that is the branch we want to create our new feature branch from

git pull
Fetch any changes from the remote we might be missing and then merge them in.

git branch RION-1111
Create a new branch based on the current commit which should be the latest develop after the pull above

git checkout RION-1111
Switches your active branch from develop to RION-1111

Make file changes as you work

git commit -a 
Commit any tracked files, hopefully in logical chunks that help you logically organize the work you have done.

Continue editing (#5 above) and committing (#6) until the feature is complete.  Hopefully with many logical commits.

git checkout develop
Checkout your develop branch again

git pull
Catch your development branch back up to the remote

git merge RION-1111 --no-ff
Merges your feature branch back into develop.  The "--no-ff" tells git to ALWAYS create a merge commit even if it can fast forward the feature branch commits on top of develop.  At this point you would need to handle any merge conflicts that might have arisen

git push
Push your merge commit and all the commits it brought in to the remote develop


3. Using git to create a feature branch, pushing that feature branch to github to generate a pull request
git checkout develop
Check out your local develop branch as that is the branch we want to create our new feature branch from

git pull
Fetch any changes from the remote we might be missing and then merge them in.

git branch feature/RION-1111
Create a new branch based on the current commit which should be the latest develop after the pull above

git checkout feature/RION-1111
Switches your active branch from develop to RION-1111

Make file changes as you work

git commit -a 
Commit any tracked files, hopefully in logical chunks that help you logically organize the work you have done.

Continue editing (#5 above) and committing (#6) until the feature is complete.  Hopefully with many logical commits.

git push --set-upstream origin feature/RION-11111
Set the upstream feature branch for your local feature branch and push (after this you can just git push)

Go to github.as.com and select the feature branch you would like to create a pull request for.  It will usually notice new feature branches

Once reviewed, you can merge and delete the remote feature branch from github.as.com if there are no conflicts.

---

# When you run git push, you are using two Gits, with two different
# repositories. You are telling your Git to call up someremote Git. Once your
# Git has the other Git on the Internet-phone (via https or ssh or whatever),
# your Git sends some of your commits to their Git, and then your Git asks them
# to set their branches, usually based on the commits you just sent.

# Take local mybranch and make it the remote’s mybranch
#          TO          FROM
#                 local    remote
git push origin mybranch:mybranch

---

Working Directory: Sandbox
Index: Proposed next commit snapshot, populated by 'git add's. AKA “Staging Area”. This is what Git looks at when you run 'git commit'.
HEAD: Last commit snapshot, next parent. It’s generally simplest to think of HEAD as the snapshot of your last 'git commit' on that branch.

    WD               Index          HEAD
     <------checkout the project------
     -------stage files->
                         -----commit->
                         hash id created

'git status' will give us no output when all three trees are the same

---

# New feature branch
git checkout develop
git pull
git branch feature/RION-26857 && git checkout feature/RION-26857
# or just git checkout -b feature/RION-26857
git push --set-upstream origin feature/RION-26857
Total 0 (delta 0), reused 0 (delta 0)
To github.as.com:RION/data.git
 * [new branch]              feature/RION-26857 -> feature/RION-26857
 Branch 'feature/RION-26857' set up to track remote branch 'feature/RION-26857' from 'origin'.

vi SET_CONTACT_MATCH_CODE.prc
git add . && git commit -m 'RION-26857: Replace SET_CONTACT_MATCH_CODE'
git push  # PR initiated
# ...approval occurs
$ git checkout develop
$ git pull
$ git merge --no-ff feature/RION-26857
$ git push [origin develop]
git branch -d feature/RION-26857
git push origin --delete feature/RION-26857
git fetch -p  # prune other's deleted branches
git branch -a  # confirm

---

Approved PR collision https://bocoup.com/blog/git-workflow-walkthrough-merging-pull-requests

# github merge PR button is not available
git checkout master
git fetch origin master
git checkout docs
git merge master  # or this?? git mergetool
# fix conflict... test code on this feature branch...
git add . && git commit -m 'Fix'
git push
# ...github merge PR button is available now so click it or do:
git checkout master
git pull origin master
git merge --no-ff docs
# Take my master and make it the remote's master
git push origin master
git branch -d docs
git push origin --delete docs

---

git stash list
# nothing

git stash save --include-untracked 'sales comp'
# now you can switch branches

# then later
git stash apply stash@{0}
# or
git stash pop 
# to remove stash if no collisions

# delete all stashes
git stash clear

---

# View an older version of a file
git log --name-only --pretty=format:"%h - %an, %ar : %s"
# to find  Source/SQL/SALES_COMP_ACCRUAL.pck is 923ab5b2d98
git show 923ab5b2d98:Source/SQL/SALES_COMP_ACCRUAL.pck
# or better?
gitk /c/RION/workspace/data/Source/SQL/SALES_COMP_ACCRUAL.pck

---

# Feature Branch Workflow:

# This checks out a branch called marys-feature based on master, and the -b flag
# tells Git to create the branch if it doesn’t already exist. On this branch,
# Mary edits, stages, and commits changes in the usual fashion, building up her
# feature with as many commits as necessary:
git checkout -b marys-feature master

git add <some-file>
git commit

# Push her new feature branch up to the central repository. This serves as a
# convenient backup, but if Mary was collaborating with other developers, this
# would also give them access to her initial commits.

# This command pushes marys-feature to the central repository (origin), and the
# -u flag adds it as a remote tracking branch. After setting up the tracking
# branch, Mary can call git push without any parameters to push her feature.
git push -u origin marys-feature
# same?
# git push --set-upstream origin feature/RION-26857

# Before merging it into master, she needs to file a pull request letting the
# rest of the team know she's done. But first, she should make sure the central
# repository has her most recent commits:

git push

# Then she files the pull request in her Git GUI asking to merge marys-feature
# into master, and team members will be notified automatically

# Once Bill is ready to accept the pull request, someone needs to merge the
# feature into the stable project (this can be done by either Bill or Mary):
git checkout master
git pull
git pull origin marys-feature
git push

# This process often results in a merge commit. Some developers like this because
# it's like a symbolic joining of the feature with the rest of the code base. 

---

# https://www.atlassian.com/git/tutorials/syncing
# Upload the local state of <branch-name> to the remote repository specified by
# <remote-name> (i.e. URL shortcut origin) 
git push <remote-name> <branch-name>

---

cd /cygdrive/c/RION/workspace
git clone git@github.as.com:RION/data.git

xoheck@xxxx523 MINGW64 /c/RION/workspace/data (feature/RION-31044)
$ git remote show origin
* remote origin
  Fetch URL: git@github.as.com:RION/data.git
  Push  URL: git@github.as.com:RION/data.git
  HEAD branch: develop
  Remote branches:
    develop             tracked
    feature/RION-30886 tracked
    feature/RION-31044 tracked
    feature/RION-31487 tracked
    feature/RION-31587 tracked
    master              tracked
  Local branches configured for 'git pull':
    develop             merges with remote develop
    feature/RION-31044 merges with remote feature/RION-31044
    feature/RION-31587 merges with remote feature/RION-31587
  Local refs configured for 'git push':
    develop             pushes to develop             (local out of date)
    feature/RION-31044 pushes to feature/RION-31044 (up to date)
    feature/RION-31587 pushes to feature/RION-31587 (up to date)

---

git pull origin develop  =  PULL FROM o to   d
git push origin develop  =  PUSH TO   o from d

---

git config --local -e

edit .git/config:

[branch "feature/RION-31587"]
         remote = origin
         merge = refs/heads/feature/RION-31587

---

https://github.com/new

…or create a new repository on the command line

echo "# code" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin git@github.com:bheckel/code.git
git push -u origin master

the above defaulted to http and user password prompting:
0 bheckel@appa[master] code/ Fri Dec 15 11:58:47  
$ git remote -v
origin  https://github.com/bheckel/code.git (fetch)
origin  https://github.com/bheckel/code.git (push)

so changed to this:
0 bheckel@appa[master] code/ Fri Dec 15 12:03:37  
$ git remote set-url origin git@github.com:bheckel/code.git
$ git remote -v
origin  git@github.com:bheckel/code.git (fetch)
origin  git@github.com:bheckel/code.git (push)

---

Compare what changed locally prior to push:
git show  # one big less-like context diff
git difftool  # vimdiff one file at a time

Which files were affected in each commit:
git log --date=short --name-only

---

# Collaborating on a bugfix:

# Alice:
# It's possible to make changes to the working directory before creating a new
# branch, as long as those changes haven't yet been committed.
vi index.htm
git checkout -b fix-trademark
git commit -am "Add placeholders for the trademark fix"
git push -u origin fix-trademark

# MadHatter:
git pull
# nothing-because the branch is associated with the remote origin, such branches aren't displayed by default
git branch
git branch -a  # show list of local & remote
git checkout fix-trademark
git diff master  # what did Alice's comment say
vi index.htm
git commit -am "Fix trademark character display" && git push

# Alice:
git pull
# looks good
git checkout master
git merge fix-trademark
git push  # the remote master branch on GitHub gets the fix

# MadHatter:
git pull

---

Git status sequence for a changing file:

                      git add           git commit              git push
 UNTRACKED/UNSTAGED -----------> STAGED ----------> LOCAL REPO -------------> REMOTE REPO


---

# Instructions - work on an existing remote repo (after clicking New, naming and allowing a README.md to be created by github)
cd
git clone git://github.com/bheckel/transfer.git
cd transfer/
vi wtf.txt
# Copy sas0's id_rsa.pub to github.com Settings::Keys if first time:
# "You can't push to git://github.com/bheckel/transfer.git..." error
git remote set-url origin git@github.com:bheckel/transfer.git 
git remote -v  # list your remote aliases
git add . 
git commit -m 'initial'
git push origin master

---

# Current project (only edits .git/config):
git config color.ui false

git config --help
# or
git help config
# or 
man git-config

$ cat ~/project/.gitignore
*.a       # no .a files
*.[oa]    # or .o and .a 
!lib.a    # but do track lib.a, even though you're ignoring .a files above
/TODO     # only ignore the root TODO file, not subdir/TODO
build/    # ignore all files in the build/ directory
doc/*.txt # ignore doc/notes.txt, but not doc/server/arch.txt
*~

---

$ cd datapost/
$ git init
$ git add .  # all files & subdirectories in pwd
$ git commit -m 'initial'
$ git status
$ vi t2  # new file
$ git status
$ git diff  # for anything uncommitted
$ git log  # to get hashes
$ git diff 043e478  # or git diff bc2b733 043e478 to be verbose
$ git commit -am 'first'
$ git status
$ vi cfg/newbie  # new file
$ git add .  # gets subdirs
$ git status
$ vi t2
$ git status
$ git commit -am '2nd'
# On branch master
nothing to commit (working directory clean)
$ git show  # a last commit diff
$ git fshow # list last commit files
$ git branch  # print which branches exist git branch -v (or branch -rv if remotes) for more detail
$ git branch ccf1  # !!don't forget next command or you'll be editing the parent!!
$ git checkout ccf1
$ vi cfg/DataPost_Configuration.xml
$ >code/NEWFCCF1
$ git status
$ git add .
$ git commit -am 'first on ccf1branch'
$ git checkout master
$ >data/foofrommaster
$ git add . && git commit -am 'another master chg b4 merge'
$ git checkout master
$ git merge ccf1
$ git branch -D ccf1  # delete unmerged branch
$ git log
$ git ls-files  # list which files are tracked under git source control not just staged
$ git count-objects
$ git gc  # compress to save space
$ git count-objects
$ git reflog  # log of where your HEAD and branch references have been for the last few months

---

# Rename move local (current) branch:
git branch -m mynewbranchname

git branch -d ccf1  # delete branch remove branch

# Undo, delete, destroy, last commit:
git reset --hard HEAD^
git reset --hard HEAD~  # same
git reset --hard HEAD~1  # same

# Edit modify rewrite rename existing git commit message.  Actually will
# replace the old commit with a new commit incorporating your changes, giving
# you a chance to edit the old commit message first.
git commit --amend -m 'change your previous last wrong commit message to this'

# Download a complete github project into a non-git-aware directory:
git clone git://github.com/bheckel/dotfiles.git  
# ...which dumps into ./dotfiles/ unless you do something like:
git clone git://github.com/bheckel/dotfiles.git dotfiles-copy

# Simple stash: working on mywipbranch and need to fix an emergency bug so do:
git stash  # or git stash save "work in progress for foo feature"
git checkout master
# .. do stuff to prod branch's b21_0003e.sas ... then
git add code/b21_0003e.sas && git commit -m 'bugfix on master'
# ...now we're ready to leave this emergency branch...
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
git checkout mywipbranch  # use  git checkout -f  when you forget this step and fup prod
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
# DO NOT FORGET TO SWITCH BRANCHES BACK!!!
git stash list
git stash pop  # most recent

# More complex stash:
# Do not use stash -u unless all files are being tracked! Untrackeds get whacked.
git stash  # or if >1 stash expected:  git stash save 'your message here'
git checkout master
# ...do stuff to master branch and commit...
git checkout myotherbranch
git stash list
git stash apply stash@{1}  # or just:  git stash apply  or git stash pop
git stash clear  # deletes ALL stashes

# Poor man's snapshot prior to doing something dangerous
git stash save && git stash apply

# Add new file to repo (need -f for my ~/code/misccode/ because .gitignore holds '*'):
git add _tmux.conf && git commit -m'initial' && git push origin master

# Remove existing file from repo:
git rm dotfiles.sh && git commit -m'remove' && git push origin master

# Get "HTTPS clone URL" from github page first then:
git clone https://github.com/grayghostvisuals/Practice-Git.git

# Github
# If you've already forked in the past:
git clone https://github.com/bheckel/Practice-Git.git
cd Practice-Git
#                             any name
git remote add --track master upstream git://github.com/grayghostvisuals/Practice-Git.git
# Next two are instead of  git pull:
git fetch upstream  # no apparent changes yet
git merge upstream/master
git branch july13
git checkout july13
# ...make 3 changes to be squashed into one...
# DO NOT REBASE COMMITS THAT YOU HAVE PUSHED TO A PUBLIC REPOSITORY.
# Normally, rebasing replays changes from one line of work onto another in the
# order they were introduced, whereas merging takes the endpoints and merges
# them together but here we're just compressing log entries.
# It's "~3" because we're trying to edit the last three commits; but keep in mind
# that we're actually designating four commits ago, the parent of the last
# commit you want to edit:
git rebase -i HEAD~3  
# ...now change the 'pick' for the commit(s) to squash into the other (don't
# touch the commit msgs yet)
# Then in the resulting commit screen, save your preferred commit message (or
# just keep all 3).
# For no good reason it's likely you'll need to do this one time to avoid https
# password prompts:
git config remote.origin.url git@github.com:bheckel/Practice-Git.git
git push origin july13  # your github is updated
# base fork is grayghost/Practice-Git, base master and head fork is
# bheckel/Practice-Git, compare july13.  Click PR link and wait for Dennis
git checkout master  # ok to drop july13 branch i think
git fetch upstream
git merge upstream/master  # syncronized with my recent hacks

---

# Are you working on a project that uses some other version control system, and
# you sorely miss Git? Then initialize a Git repository in your working directory:
$ git init
$ git add .
$ git commit -m "Initial commit"
$ git clone . /some/new/private/directory  # a local clone
# Now go to the new directory and work there instead.  Once in a while, you'll
# want to sync with everyone else, in which case cd to the original directory,
# sync using the other version control system then:
$ git commit -am "Sync with everyone else and their SCM tool"
# Then cd back to your private directory and run:
$ git pull  # their changes to your private
# After *you* later make changes in private, cd back to the original dir and
# pull (don't use push from private):
$ git pull /some/new/private/directory
# Then use their SCM to merge that change

---

# Instructions - create new project (master) after all the ssh setup work is done on github.com
# https://github.com/new to name it
# (origin):
git init
git remote add origin git@github.com:bheckel/test.git
touch README.md
git add README.md  # use git add -f README.md to force add if it's excluded by .gitignore
git commit -m 'first commit'
git push -u origin master
# ...now it's on github
#
git remote -v  # list your remote aliases like these:
# origin	git@github.com:bheckel/dotfiles.git (fetch)
# origin	git@github.com:bheckel/dotfiles.git (push)
#
# ...make changes to local files (master)...
git push origin master
# e.g. ssh-add && git add _bashrc && git commit -m 'mod' && git push origin master

# ...then you accidentally delete the whole repo and want it restored to a new dir:
cd ~/projects/git  # no git init, project will create ~/project/git/test/
git clone git://github.com/bheckel/test.git
# ...new edits...
git add dotone && git commit -m 'chaos' && git push git@github.com:bheckel/test.git master

# Temporarily ignore a previously committed, i.e. tracked, file temporarily (not
# using a .gitignore approach):
git update-index --assume-unchanged foo.txt
# ...commit...
git update-index --no-assume-unchanged foo.txt

# After adding a new filename (that you're already tracking) to .gitignore must
# do this to stop it from continuing to appear:
git rm --cached foo.txt
git ls-files  # verify foo.txt is gone (but still exists on the filesystem)

git log --oneline
git log --pretty=oneline  # not exactly pretty, just shows full hash
git log --graph --pretty=oneline --abbrev-commit 
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'
git log --since='6 weeks ago' --grep='LADD'
# best
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short

---

# Unstage a new file:
git reset HEAD oops.txt
# Revert, throw away, discard changes since last commit:
git checkout -- oops.txt  # BEST single file trash changes for unstaged file
git checkout .   # ALL changes that are not staged for commit
git checkout -f  # ALL changes, good after accidental unstash in wrong branch
# or if some files are staged and you want to keep those only but abandon
# the "not staged for commit" ones (untried):
git stash save --keep-index && git stash drop
git stash
# Drop the last stash - when no <stash> is given, it removes the latest one. i.e. stash@{0}
git stash drop

git reflog  # see all branch changes from way back

# Poke around in the past, revert to a specific old checkin TEMPORARILY from
# mynormalbranch without wasting time branching and branch deleting.
# If you don't know the SHA1 or the tag name, do this first:
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
git checkout 9deec7a  # detached HEAD
# ...poking finished...
git checkout mynormalbranch

# If you only know the topic but want the SHA1:
git rev-parse sas93branch

# Revert to specific checkin, tossing later one(s)...
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
# ...choose hash of commit to revert to (i.e. land in)
git reset --hard 4171fb3

# New branch on the fly without jumping to it:
git branch mynewbranch master  # branch from a specific branch in this case master
git branch mynewbranch 2f13ab6  # branch from a specific commit

$ git checkout master  # branch switch
$ git merge ccf1

# Merge collision CONFLICT - edit out the git <<< ====== >>> stuff in
foo.txt, choosing which edit to keep then  git add foo.txt

# View a merge conflict (don't use for binary collisions!):
git show :1:code/_ADO_LIFT.qry  # common base
git show :2:code/_ADO_LIFT.qry  # ours
git show :3:code/_ADO_LIFT.qry  # theirs
# Better merge conflict resolution if vim is set as difftool:
git mergetool
# Edit/delete lines you don't want
rm _bashrc.orig

# Diff a merge collision in vim (if config is setup correctly) but must save
# as code/_ADO_LIFT.qry when done prior to commit:
git difftool :2:code/_ADO_LIFT.qry :3:code/_ADO_LIFT.qry

git show :2:code/_ADO_LIFT.qry >| code/_ADO_LIFT.qry  # use our version
git add code/_ADO_LIFT.qry
git commit -am 'post semi-manual merge'

# Better if using v1.6.1+.  Assumes we're in committed master branch
git checkout --ours cfg/DataPost_Configuration.xml  # use master
# or 
git checkout --theirs cfg/DataPost_Configuration.xml  # use non-master
git commit -am 'post merge collision - just use theirs'

# or give up
git merge --abort

# Abandon everything since your last commit; this command can be DANGEROUS. But
# if merging has resulted in conflicts and you'd like to just forget about the
# merge, this command will do that.
git reset --hard

# Use git's move instead of OS'. Also can rename.
git mv readme.txt lib/read.me.txt

# Need the backslash, git does its own expansions
git rm log/\*.log
# Remove an accidentally staged file.  Or keep the file in your working tree
# but remove it from your staging area. In other words, you may want to keep
# the file on your hard drive but not have Git track it anymore. This is
# particularly useful if you forgot to add something to your .gitignore file
# and accidentally added it, like a large log file 
git rm --cached big.log

# Delete throw away branch after merge
git branch -d experimental  # or -D if unmerged

git tag 2.0
git tag mystable1tag 1b2e1d63ff  # create "lightweight" tag
git show 2.0
git show HEAD^:path/to/file

# View old version of file from different branch or commit (in pager):
git show eacbd91:code/ods_0002e.sas

############################### COMPARE / REPLACE ##############################################
# Compare specific file in current branch to another branch (then :%diffput etc):
git difftool anotherbranch code/DataPost_Trend.sas
# or
# Compare old version of file from different commit to this commit - current (hash-less) commit must come 2nd!!:
git difftool eacbd91:code/ods_0002e.sas code/ods_0002e.sas
# or
# Compare, sync, all files between 2 commits in same or in any 2 branches:
git difftool 10ed0d7 bd37098
git difftool foo bar
# ...then use vim's dp command to update the lefthand version or, less usefully...
# Replace a single file with a copy from another branch.  We're in master and want the version from anotherbranch:
#            _____________ branch, not a commit!
git checkout anotherbranch code/DataPost_Trend.sas
# Verify by comparing previous commit to the newly replaced file (f8a79b8 is the previous commit on current branch):
git difftool f8a79b8
# If you change your mind after difftool, unstage & restore old:
git reset HEAD code/DataPost_Trend.sas
git checkout -- code/DataPost_Trend.sas  # sometimes not needed-why??
############################### COMPARE / REPLACE ##############################################

# Show files touched in this commit (via custom .gitconfig alias:  fshow = ! sh -c 'git show --pretty="format:" --name-only $1 | grep -v "^$" | uniq | sed -e "s#^#`git rev-parse --show-toplevel`/#"' - ):
git fshow 5fcb8eb  # hash is optional for last commit
# Using custom alias specify a range of commits:
git fshow sas93@{3.days.ago}
git fshow master..junk  # files updated in junk since branching

# Compare files across branches and commits. This fails unless file is in
# previous master commit (fatal: Path 'cfg/Configuration.xml' exists on disk,
# but not in 'master'.) - use  git fshow master  to check.
git difftool master:cfg/Configuration.xml 5fcb8eb:cfg/Configuration.xml
git difftool master:cfg/Configuration.xml trip:cfg/Configuration.xml

# Dry run (-n) deletion of untracked files including ones in .gitignore (-x):
git clean -n -d -x .

# Local squash the previous (whoops) commit that should have been done in the 1st commit (hide your whoops):
git rebase -i HEAD~2  # last two commits will appear in picklist
Replace 'pick' with 's' for the last commit, :wq, another window will appear
Delete the comment from the whoops commit, :wq
# Now only the first commit and its comment appears in git log

---

github config
on yoniso 09-Feb-12

sudo apt-get install git-core git-gui git-doc

cd ~/.ssh

ssh-keygen -t rsa -C "heckel@gmail.com"

paste id_rsa.pub into webform

git config --global user.name "Bob Heckel"
git config --global user.email "sh@rshdev.com"

---

# on what-if 
$ gb
  develop
  feature/RION-37551
  feature/RION-37880
  feature/RION-39245
  feature/RION-39366
  feature/RION-39939

$ git remote show origin
* remote origin
  Fetch URL: git@github.as.com:rion/data.git
  Push  URL: git@github.as.com:rion/data.git
  HEAD branch: develop
  Remote branches:
    Interaction_attendee_data_work         tracked
    RION-38469                             new (next fetch will store in remotes/origin)
    RION-38733                             tracked
    RION-39866                             tracked
    develop                                tracked
    feature/RION-28181                     tracked
    feature/RION-33319                     tracked
    feature/RION-39859                     tracked
    feature/RION-39939                     tracked
    master                                 tracked
    refs/remotes/origin/feature/RION-38419 stale (use 'git remote prune' to remove)
    refs/remotes/origin/feature/RION-38969 stale (use 'git remote prune' to remove)
    what-if                                 tracked
  Local branches configured for 'git pull':
    develop             merges with remote develop
    feature/RION-37551 merges with remote feature/RION-37551
    feature/RION-37880 merges with remote feature/RION-37880
    feature/RION-39245 merges with remote feature/RION-39245
    feature/RION-39366 merges with remote feature/RION-39366
    feature/RION-39939 merges with remote feature/RION-39939
    what-if             merges with remote what-if
  Local refs configured for 'git push':
    develop             pushes to develop           (local out of date)
    feature/RION-37880 pushes to feature/RION-37880 (up to date)
    feature/RION-39245 pushes to feature/RION-39245 (up to date)
    feature/RION-39366 pushes to feature/RION-39366 (up to date)
    feature/RION-39939 pushes to feature/RION-39939 (up to date)
    what-if             pushes to what-if           (up to date)

---

$ stash && git pull && git stash pop   && git add  . && git commit -m 'rion-63193: Update Primary DNB Number:  Creative Educ Prep Inst 1(SA #3835468)' && git push #stashit
Saved working directory and index state On develop: saved Thu, Feb  2, 2023  3:39:17 PM
remote: Enumerating objects: 18, done.
remote: Counting objects: 100% (18/18), done.
remote: Compressing objects: 100% (8/8), done.
remote: Total 18 (delta 10), reused 12 (delta 10), pack-reused 0
Unpacking objects: 100% (18/18), 33.11 KiB | 210.00 KiB/s, done.
From github.com:sintitute-corp/rion-data
   77ead2b5925..63a8a33a7ce  develop    -> origin/develop
Updating 77ead2b5925..63a8a33a7ce
Fast-forward
 Source/SQL/2023rionScripts/23.02rionScripts/23.02_GoLive_Script.sql    | 11 +++++++++++
 Source/SQL/2023rionScripts/23.02rionScripts/rion-60247_ddl_change.sql | 29 +++++++++++++++++++++++++++++
 Source/SQL/SALES_COMP_MACRO.pck                                          | 24 ++++++++++--------------
 3 files changed, 50 insertions(+), 14 deletions(-)
 create mode 100644 Source/SQL/2023rionScripts/23.02rionScripts/rion-60247_ddl_change.sql
On branch develop
Your branch is up to date with 'origin/develop'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   USER_ON_CALL.pck

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (fa90119528d6dc79cc653d680a12def495373ac5)
[develop 82cc5e35740] rion-63193: Update Primary DNB Number:  Creative Educ Prep Inst 1(SA #3835468)
 1 file changed, 22 insertions(+), 11 deletions(-)
To github.com:sintitute-corp/rion-data.git
 ! [rejected]                develop -> develop (fetch first)
error: failed to push some refs to 'git@github.com:sintitute-corp/rion-data.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:39:36
$ git pull
remote: Enumerating objects: 7, done.
remote: Counting objects: 100% (7/7), done.
remote: Total 7 (delta 6), reused 7 (delta 6), pack-reused 0
Unpacking objects: 100% (7/7), 562 bytes | 5.00 KiB/s, done.
From github.com:sintitute-corp/rion-data
   63a8a33a7ce..c9808a5f6a4  develop    -> origin/develop
fatal: Not possible to fast-forward, aborting.
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:39:58
$ gs
On branch develop
Your branch and 'origin/develop' have diverged,
and have 1 and 1 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)

nothing to commit, working tree clean
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:41:03
$ git pull
remote: Enumerating objects: 7, done.
remote: Counting objects: 100% (7/7), done.
remote: Total 7 (delta 6), reused 7 (delta 6), pack-reused 0
Unpacking objects: 100% (7/7), 533 bytes | 2.00 KiB/s, done.
From github.com:sintitute-corp/rion-data
   c9808a5f6a4..78a497f9582  develop    -> origin/develop
fatal: Not possible to fast-forward, aborting.
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:41:20
$ git push
To github.com:sintitute-corp/rion-data.git
 ! [rejected]                develop -> develop (non-fast-forward)
error: failed to push some refs to 'git@github.com:sintitute-corp/rion-data.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:51:33
$ git pull --rebase
Successfully rebased and updated refs/heads/develop.
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:55:30
$ gs
On branch develop
Your branch is ahead of 'origin/develop' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
4 bheck@l10g[develop] /cygdrive/c/rion/workspace/rion-data/Source/SQL/ Thu Feb 02 15:55:36
$  git push
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 8 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 847 bytes | 65.00 KiB/s, done.
Total 5 (delta 4), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
To github.com:sintitute-corp/rion-data.git
   78a497f9582..d53879b86a1  develop -> develop


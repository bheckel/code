#!/usr/local/bin/perl
# Metrics - Utility Package
#
# Mark Hewett 23-Mar-2000
# Factory Networks Group, NTP
# Nortel Networks Corp.

package Util;

# Add a message to the DebugInfo buffer (in the style of sprintf()) if
# traceing is enabled in either the [main] or [module] config, or if the
# value of _trace_ is true in the context hash.  Debugging
# messages added this way can be turned off globally by setting
# trace={on|off} in the config file.
sub Trace
	{
	my($fmt, @params) = @_;

	if (textLib::affirmative($Cfg->{main}{trace}) ||
		textLib::affirmative($Cfg->{module}{trace}) ||
		$Ctx->{_trace_})
		{ $Screen::DebugInfo .= sprintf($fmt, @params); }
	}

# Immediately generate HTTP headers for a plain-text document.  This will
# cause everything else generated by the program on STDOUT to be rendered
# by the browser as plain text.  This allows debugging of headers, cookies
# and unplanned emissions (things written to STDOUT that you didn't expect).
sub TraceDump
	{
	cgiLib::httpGenHeader("text/plain");
	}

# Simplified string formatting.
sub Format
	{
	$fmt = shift @_;
	$fmt = defined($Cfg->{format}{$fmt}) ? $Cfg->{format}{$fmt} : $fmt;
	sprintf($fmt, @_);
	}

# Simplified token replacement.  Requires only a template specification
# and optionally a reference to the hash containing the values to replace
# the tokens with.  If no value hash is specified, the main context ($Ctx)
# is assumed.
#
# The template specification can be:
# 1) a key in $Cfg->{templates} whose value is a filename (with baseDir)
# 2) a key in $Cfg->{templates} whose value is a template string
# 3) a template string
#
# The return value is always the resulting text after the token replacement
# operation.
sub TokenReplace
	{
	my($tspec, $vh) = @_;
	my($buffer, $tfile);

	$vh = defined($vh) ? $vh : $Ctx;

	if (defined($Cfg->{templates}{$tspec}))
		{
		if ($tfile = TemplateFile($tspec))
			{
			# looks like a template file name
			textLib::tokenReplaceBuffer($tfile, $buffer, $vh);
			}
		else
			{
			# must be a configured "immediate" template
			$buffer = textLib::tokenReplaceImmediate(
				$Cfg->{templates}{$tspec}, $vh);
			}
		}
	else
		{
		# must be an un-configured "immediate" template
		$buffer = textLib::tokenReplaceImmediate($tspec, $vh);
		}

	return $buffer;
	}	

# Find the most specific template configured
sub Template
    {
    my($ttype, @suggestions) = @_;
	my($template, $tpath);
 
    foreach $id (@suggestions)
        {
        $template = $Cfg->{templates}{$ttype.":".$id};
        last if ($template);
        }
 
    # if all else fails use the base template definition
    $template = $Cfg->{templates}{$ttype} if (!$template);

	return $template;
    }

# Find the path to the most specific template file configured
sub TemplateFile
    {
    my($ttype, @suggestions) = @_;
	my($tfile, $tpath);
 
    foreach $id (@suggestions)
        {
        $tfile = $Cfg->{templates}{$ttype.":".$id};
        last if ($tfile);
        }
 
    # if all else fails use the base template definition
    $tfile = $Cfg->{templates}{$ttype} if (!$tfile);

	my(@searchPath) = split(/:/, $Cfg->{templates}{baseDir});

	foreach $dir (@searchPath)
		{
		$tpath = join("/", $dir, $tfile);
		if (-f $tpath) { return $tpath; }
		}

	return "";
    }

# Generate markup for a selection widget for the specified token.
sub SelectionControl
	{
	my($token, $ch, $selfmt, $optfmt) = @_;
	my($markup);

	$selfmt = $selfmt ? $selfmt : "defaultSelect";
	$optfmt = $optfmt ? $optfmt : "defaultOption";

	foreach $type (split(/,/, $Cfg->{$ch}{types}))
		{
		$markup .= Util::Format(
			$optfmt,
			$type,
			($type eq $Ctx->{$token}) ? " SELECTED" : "",
			$Cfg->{$ch}{$type,'desc'});
		}

	return Util::Format($selfmt, $token, $markup);
	}

# Generate markup for a set of radio buttons for the specified token.
sub RadioButtonControl
	{
	my($token, $ch, $fmt) = @_;
	my($markup);

	$fmt = $fmt ? $fmt : "defaultRadio";

	foreach $type (split(/,/, $Cfg->{$ch}{types}))
		{
		$markup .= Util::Format(
			$fmt,
			$token,
			$type,
			($type eq $Ctx->{$token}) ? " CHECKED" : "",
			$Cfg->{$ch}{$type,"desc"});
		}

	return $markup;
	}

sub AddToolbar
	{
	my($tbname, $ctxname, $prepend) = @_;
	my($buffer, $sep);

	$ctxname = $ctxname ? $ctxname : "TOOLBAR";

	$sep = defined($Cfg->{'toolbar:'.$tbname}{separator}) ?
		$Cfg->{'toolbar:'.$tbname}{separator} : "&nbsp;";

	foreach $btn (split(/,/, $Cfg->{'toolbar:'.$tbname}{buttons}))
		{
		if ($btn eq "separator")
			{ $buffer .= $sep; }
		else
			{ $buffer .= make_button($btn, $Cfg->{'toolbar:'.$tbname}); }
		}

	if ($prepend)
		{ $Ctx->{$ctxname} = $sep.$buffer.$Ctx->{$ctxname} if ($buffer); }
	else
		{ $Ctx->{$ctxname} .= $sep.$buffer if ($buffer); }

	$buffer;
	}

# Use a special context token "_dev_" to turn on developer access.  Use a 
# cookie to make it persistent.  Developers will have to set _dev_=1 at least
# once to get the cookie set.  Cookie lifetime is set to 1 month.
sub SetDeveloperFlag
	{
	if (defined($Ctx->{_dev_}))
		{
		if ($Ctx->{_dev_})
			{ cgiLib::httpSetCookie("c_dev", 1, $Ctx->{'COOKIEPATH'}, 43200); }
		else
			{ cgiLib::httpSetCookie("c_dev", 0, $Ctx->{'COOKIEPATH'}, -1); }
		}
	else
		{ $Ctx->{_dev_} = $Ctx->{c_dev} ? 1 : 0; }
	}

# Retrieve a list of tokens from the specified cookie and place their values
# back in context, if and only if there are no values by the same name
# already in context.
sub GetCookie
	{
	my($cookie_name, @tokens) = @_;

	my(@crumbs) = split(/:/, $Ctx->{"c_".$cookie_name});

	for ($c=0; $c<(scalar @crumbs); $c++)
		{
		$Ctx->{$tokens[$c]} = $crumbs[$c]
			if (!defined($Ctx->{$tokens[$c]}));
		}
	}

# Set the specified cookie's value from current context if the tokens
# are defined, otherwise use the previous value from the cookie.
sub SetCookie
	{
	my($cname, @tokens) = @_;

	my(@oldcrumbs) = split(/:/, $Ctx->{"c_".$cname});
	my(@newcrumbs) = ();

	for ($c=0; $c<(scalar @tokens); $c++)
		{
		if (defined($Ctx->{$tokens[$c]}))
			{ push(@newcrumbs, $Ctx->{$tokens[$c]}); }
		else
			{ push(@newcrumbs, $crumbs[$c]); }
		}

	my($cookieLife) = $Cfg->{main}{cookiePersistMinutes};

	if (defined($Cfg->{module}{$cname."PersistMinutes"}))
		{ $cookieLife = $Cfg->{module}{$cname."PersistMinutes"} }
	elsif (defined($Cfg->{main}{$cname."PersistMinutes"}))
		{ $cookieLife = $Cfg->{main}{$cname."PersistMinutes"} }

    cgiLib::httpSetCookie("c_".$cname,
        join(":", @newcrumbs),
        $Ctx->{'COOKIEPATH'},
        $cookieLife);
	}

# Set a context token to a default value if and only if it is not
# already defined.
sub ProvideDefault
	{
	my($token, $default) = @_;

	if (!defined($Ctx->{$token}))
		{ $Ctx->{$token} = $default; }
	}

# Merge values from one hash into another.  Source and destination hashes
# are specified by reference ($dh and $sh, respectively).  If a key in the
# source hash matches one in the destination, the destination gets
# overwritten!
sub Merge
	{
	my($dh, $sh, @items)  = @_;

	if (scalar @items == 0)
		{ @items = keys %$sh; }

	foreach $key (@items)
		{
		next if ($key eq "_KEYS_");
		$dh->{$key} = $sh->{$key};
		}
	}

# Return a list of all forwardable context tokens
sub AllForwardTokens
	{
	my(@list);

	foreach $item (keys %$Ctx)
		{
		# do not forward cookies or ACI
		next if $item =~ /^c_/;
		next if $item =~ /pw|un/;
		next if $item =~ /POSTFORWARD|USERSTATE|SCRIPT|COOKIEPATH|f_Passthru/;
		push @list, $item;
		}

	return @list;
	}

# Return both a filesystem path and a URL-space path to temporary file
# name in the chart cache.  Any caller-supplied arguments are joined with
# dashes to help create a unique filename.
sub ChartPath
    {
    my($fn) = join("-", @_, sprintf("%X%X.gif", time, $$));
    return (
        join("/", $Cfg->{main}{chartCacheDir}, $fn),
        join("/", $Cfg->{main}{chartCacheURL}, $fn)
        );
    }

# Generic input data validation engine.  Formal parameters should be
# a list of array references.  Each referenced array should contain
# three values:
#   [0] a context variable name
#   [1] a rule name to validate against
#   [2] a message string to return if the validation fails
#
# Rules supported are:
#   NOTNULL			- value must not equal ""
#   DATE			- value must be in the form MM/DD/YY[YY]
#   INTEGER			- value must be a number
#   INTEGER(m:n)	- value must be a number between m and n (inclusive)
#
#   need more?
#
sub Validate
	{
	my($rc);
	foreach $rule (@_)
		{
		$rule->[1] = uc($rule->[1]);

		if ($rule->[1] =~ /NOTNULL/)
			{
			notNull($Ctx->{$rule->[0]})
				or return (0, $rule->[2]);
			}
		elsif ($rule->[1] =~ /DATE/)
			{
			validDate($Ctx->{$rule->[0]})
				or return (0, $rule->[2]);
			}
		elsif ($rule->[1] =~ /INTEGER\((\d+):(\d+)\)/)
			{
			integerBetween($Ctx->{$rule->[0]}, $1, $2)
				or return (0, $rule->[2]);
			}
		elsif ($rule->[1] =~ /INTEGER/)
			{
			integer($Ctx->{$rule->[0]})
				or return (0, $rule->[2]);
			}
		else
			{
			return (-1, "Unrecognized data validation type \"".$rule->[1]."\"");
			}
		}

	return (1, "validation succeeded");
	}

#-----------------------------------------------------------------------
# Private methods for this package
#-----------------------------------------------------------------------

# data validation methods

sub notNull
	{ ($_[0] ne ""); }

sub integer
	{ ($_[0] =~ /\d+/); }

sub integerBetween
	{
	my($v, $ll, $ul) = @_;
	(($v =~ /\d+/) && ($v >= $ll) && ($v <= $ul));
	}

sub validDate
	{ timeLib::parseDate($_[0]); }

# generate markup for a toolbar button
sub make_button
	{
	my($bname, $ch) = @_;
	my($markup, $btype, $evh);

	$fmt = ($btype = $ch->{$bname.':type'}) ?
		$Cfg->{format}{'toolbarButton:'.$btype} :
		$Cfg->{format}{'toolbarButton'};

	$name = $ch->{$bname.':function'} ?
		"f_".ucfirst($ch->{$bname.':function'}):
		"f_".ucfirst($bname);
		
	$value = $ch->{$bname.':label'} ?
		ucfirst($ch->{$bname.':label'}):
		ucfirst($bname);
	
	if ($ch->{$bname.':onClick'})
		{
		$js = Util::TokenReplace($ch->{$bname.':onClick'});
		$evh = " onClick=\"".$js."\"";
		}
	elsif ($msg = $ch->{$bname.':confirm'})
		{ $evh = " onClick=\"return confirm('".$msg."')\""; }

	sprintf($fmt, $name, $value, $evh);
	}

1;

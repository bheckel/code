<HTML>
<HEAD>
  <TITLE>Perl 5 Reference Guide (Heckel)</TITLE>
  <META NAME="description" CONTENT="Perl 5 Reference Guide (in HTML) by Rex Swain">
  <META NAME="keywords" CONTENT="perl, reference, summary">
</HEAD>

<BODY BGCOLOR="FFE4C4">
  <A NAME="top"></A>
  <CENTER>
  <H2>Perl 5 Reference Guide Main Update 5 August 1997</H2> </CENTER>
<!--   <P><font size=-2> -->
<!--   <UL> -->
<!--   <LI>Local link added -- Fri 11/13/98 03:22:43 (Bob Heckel) -->
<!--   <LI>Clarification of split added -- Thu 11/19/98 11:14:56 (Bob Heckel) -->
<!--   <LI>Added Perl By Example Appendix C to bottom -- Mon Dec 21 1998 12:58:17 (Bob Heckel) -->
<!--   <LI>Local hyperlinks to <I>Perl By Example</I> added. -- Tue Dec 22 1998 13:55:52 (Bob Heckel) -->
<!--   <LI>Changed Manual Online from MIT to CPAN. (Wed Feb 03 1999 15:05:45 Bob Heckel) -->
<!--   <li>Added link to Perl By Example toc. -->
<!--   <li>Changed link locations. Modified: Fri, 12 Nov 1999 11:24:13 (Bob Heckel) -->
<!--   <li>Added link to CPAN Duke. Modified: Tue, 29 Feb 2000 10:40:55 (Bob Heckel) -->
<!--   </UL> -->
<!--   </P> -->

  <H4 ALIGN=center>Jump to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <P><font size=-2>
  <P>This is a Bob Heckel modified HTMLified version of the <I>Perl 5 Desktop Reference</I>
  , ISBN 1-56592-187-9, copyright &copy; 1996 by <A HREF="http://www.xs4all.nl/~jvromans/">Johan Vromans</A>.
  HTML copyright &copy; 1996-1997 by <A HREF="http://www.pcnet.com/~rhswain/">Rex Swain</A>.</P></font>
  </font>

  <p><a href="file:///C|/perl/html/index.html">Perl Manual -- ActiveState (local)</A>
  <p><a href="ftp://ftp.duke.edu/pub/perl/CPAN.html">CPAN Duke</A>

  <H4 ALIGN=center>Jump to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="contents"></A>
  <H2>Contents</H2>

  <TABLE>
  <TR>
  <TD><UL>
  <LI><A HREF="#conventions">Conventions</A>
  <LI><A HREF="#options">Command-Line Options</A>
  <LI><A HREF="#literals">Literals</A>
  <LI><A HREF="#variables">Variables</A>
  <LI><A HREF="#operators">Operators</A>
  <LI><A HREF="#statements">Statements</A>
  <LI><A HREF="#subroutines">Subroutines, Packages and Modules</A>
  <LI><A HREF="#object">Object-Oriented Programming</A>
  <LI><A HREF="#arithmetic">Arithmetic Functions</A>
  <LI><A HREF="#conversion">Conversion Functions</A>
  <LI><A HREF="#structure">Structure Conversion</A>
  <LI><A HREF="#string">String Functions</A>
  <LI><A HREF="#array">Array and List Functions</A>
  <LI><A HREF="#regular">Regular Expressions</A>
  <LI><A HREF="#search">Search and Replace Functions</A>
  </UL></TD>

  <TD><UL>
  <LI><A HREF="#filetest">File Test Operators</A>
  <LI><A HREF="#fileoperations">File Operations</A>
  <LI><A HREF="#input">Input / Output</A>
  <LI><A HREF="#formats">Formats</A>
  <LI><A HREF="#directory">Directory Reading Routines</A>
  <LI><A HREF="#systeminteraction">System Interaction</A>
  <LI><A HREF="#networking">Networking</A>
  <LI><A HREF="#systemv">System V IPC</A>
  <LI><A HREF="#miscellaneous">Miscellaneous</A>
  <LI><A HREF="#information">Information from System Files</A>
  <LI><A HREF="#specialvariables">Special Variables</A>
  <LI><A HREF="#specialarrays">Special Arrays</A>
  <LI><A HREF="#environment">Environment Variables</A>
  <LI><A HREF="#debugger">The Perl Debugger</A>
  </UL></TD>
  </TR>
  </TABLE>

  <H4 ALIGN=center>Jump to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="index"></A>
  <H2>Index</H2>

  <A HREF="#arithmetic">abs</A>&nbsp;
  <A HREF="#networking">accept</A>&nbsp;
  <A HREF="#systeminteraction">alarm</A>&nbsp;
  <A HREF="#operators">and</A>&nbsp;
  <A HREF="#specialarrays">ARGV</A>&nbsp;
  <A HREF="#arithmetic">ArithmeticFunctions</A>&nbsp;
  <A HREF="#array">ArrayListFunctions</A>&nbsp;
  <A HREF="#specialarrays">ArraysSpecial</A>&nbsp;
  <A HREF="#arithmetic">atan2</A>&nbsp;
  <A HREF="#subroutines">BEGIN</A>&nbsp;
  <A HREF="#networking">bind</A>&nbsp;
  <A HREF="#input">binmode</A>&nbsp;
  <A HREF="#subroutines">bless</A>&nbsp;
  <A HREF="#subroutines">caller</A>&nbsp;
  <A HREF="#systeminteraction">chdir</A>&nbsp;
  <A HREF="#fileoperations">chmod</A>&nbsp;
  <A HREF="#string">chomp</A>&nbsp;
  <A HREF="#string">chop</A>&nbsp;
  <A HREF="#conversion">chr</A>&nbsp;
  <A HREF="#systeminteraction">chroot</A>&nbsp;
  <A HREF="#input">close</A>&nbsp;
  <A HREF="#directory">closedir</A>&nbsp;
  <A HREF="#operators">cmp</A>&nbsp;
  <A HREF="#options">CommandLineOptions</A>&nbsp;
  <A HREF="#networking">connect</A>&nbsp;
  <A HREF="#contents">Contents</A>&nbsp;
  <A HREF="#statements">continue</A>&nbsp;
  <A HREF="#conventions">Conventions</A>&nbsp;
  <A HREF="#conversion">ConversionFunctions</A>&nbsp;
  <A HREF="#structure">ConversionStructure</A>&nbsp;
  <A HREF="#arithmetic">cos</A>&nbsp;
  <A HREF="#string">crypt</A>&nbsp;
  <A HREF="#input">dbmclose</A>&nbsp;
  <A HREF="#input">dbmopen</A>&nbsp;
  <A HREF="#debugger">Debugger</A>&nbsp;
  <A HREF="#miscellaneous">defined</A>&nbsp;
  <A HREF="#array">delete</A>&nbsp;
  <A HREF="#systeminteraction">die</A>&nbsp;
  <A HREF="#directory">DirectoryReadingRoutines</A>&nbsp;
  <A HREF="#statements">do</A>&nbsp;
  <A HREF="#subroutines">do</A>&nbsp;
  <A HREF="#miscellaneous">do</A>&nbsp;
  <A HREF="#miscellaneous">dump</A>&nbsp;
  <A HREF="#array">each</A>&nbsp;
  <A HREF="#statements">else</A>&nbsp;
  <A HREF="#statements">elsif</A>&nbsp;
  <A HREF="#subroutines">END</A>&nbsp;
  <A HREF="#specialarrays">ENV</A>&nbsp;
  <A HREF="#environment">EnvironmentVariables</A>&nbsp;
  <A HREF="#input">eof</A>&nbsp;
  <A HREF="#operators">eq</A>&nbsp;
  <A HREF="#string">eval</A>&nbsp;
  <A HREF="#miscellaneous">eval</A>&nbsp;
  <A HREF="#systeminteraction">exec</A>&nbsp;
  <A HREF="#array">exists</A>&nbsp;
  <A HREF="#systeminteraction">exit</A>&nbsp;
  <A HREF="#arithmetic">exp</A>&nbsp;
  <A HREF="#specialarrays">EXPORT</A>&nbsp;
  <A HREF="#specialarrays">EXPORT_OK</A>&nbsp;
  <A HREF="#regular">ExpressionsRegular</A>&nbsp;
  <A HREF="#input">fcntl</A>&nbsp;
  <A HREF="#input">fileno</A>&nbsp;
  <A HREF="#fileoperations">FileOperations</A>&nbsp;
  <A HREF="#information">FilesSystemInformationFrom</A>&nbsp;
  <A HREF="#filetest">FileTestOperators</A>&nbsp;
  <A HREF="#input">flock</A>&nbsp;
  <A HREF="#statements">for</A>&nbsp;
  <A HREF="#statements">foreach</A>&nbsp;
  <A HREF="#systeminteraction">fork</A>&nbsp;
  <A HREF="#formats">Formats</A>&nbsp;
  <A HREF="#formats">formline</A>&nbsp;
  <A HREF="#arithmetic">FunctionsArithmetic</A>&nbsp;
  <A HREF="#array">FunctionsArrayList</A>&nbsp;
  <A HREF="#conversion">FunctionsConversion</A>&nbsp;
  <A HREF="#search">FunctionsSearchReplace</A>&nbsp;
  <A HREF="#string">FunctionsString</A>&nbsp;
  <A HREF="#operators">ge</A>&nbsp;
  <A HREF="#input">getc</A>&nbsp;
  <A HREF="#systeminteraction">getlogin</A>&nbsp;
  <A HREF="#networking">getpeername</A>&nbsp;
  <A HREF="#systeminteraction">getpgrp</A>&nbsp;
  <A HREF="#systeminteraction">getppid</A>&nbsp;
  <A HREF="#systeminteraction">getpriority</A>&nbsp;
  <A HREF="#networking">getsockname</A>&nbsp;
  <A HREF="#networking">getsockopt</A>&nbsp;
  <A HREF="#systeminteraction">glob</A>&nbsp;
  <A HREF="#conversion">gmtime</A>&nbsp;
  <A HREF="#statements">goto</A>&nbsp;
  <A HREF="#subroutines">goto</A>&nbsp;
  <A HREF="#array">grep</A>&nbsp;
  <A HREF="#operators">gt</A>&nbsp;
  <A HREF="#conversion">hex</A>&nbsp;
  <A HREF="#environment">HOME</A>&nbsp;
  <A HREF="#statements">if</A>&nbsp;
  <A HREF="#subroutines">import</A>&nbsp;
  <A HREF="#specialarrays">INC</A>&nbsp;
  <A HREF="#index">Index</A>&nbsp;
  <A HREF="#string">index</A>&nbsp;
  <A HREF="#information">InformationFromSystemFiles</A>&nbsp;
  <A HREF="#input">InputOutput</A>&nbsp;
  <A HREF="#arithmetic">int</A>&nbsp;
  <A HREF="#systeminteraction">InteractionSystem</A>&nbsp;
  <A HREF="#input">ioctl</A>&nbsp;
  <A HREF="#specialarrays">ISA</A>&nbsp;
  <A HREF="#array">join</A>&nbsp;
  <A HREF="#array">keys</A>&nbsp;
  <A HREF="#systeminteraction">kill</A>&nbsp;
  <A HREF="#statements">last</A>&nbsp;
  <A HREF="#string">lc</A>&nbsp;
  <A HREF="#string">lcfirst</A>&nbsp;
  <A HREF="#operators">le</A>&nbsp;
  <A HREF="#string">length</A>&nbsp;
  <A HREF="#fileoperations">link</A>&nbsp;
  <A HREF="#array">ListArrayFunctions</A>&nbsp;
  <A HREF="#networking">listen</A>&nbsp;
  <A HREF="#literals">Literals</A>&nbsp;
  <A HREF="#miscellaneous">local</A>&nbsp;
  <A HREF="#conversion">localtime</A>&nbsp;
  <A HREF="#arithmetic">log</A>&nbsp;
  <A HREF="#environment">LOGDIR</A>&nbsp;
  <A HREF="#fileoperations">lstat</A>&nbsp;
  <A HREF="#operators">lt</A>&nbsp;
  <A HREF="#search">m</A>&nbsp;
  <A HREF="#array">map</A>&nbsp;
  <A HREF="#miscellaneous">Miscellaeous</A>&nbsp;
  <A HREF="#fileoperations">mkdir</A>&nbsp;
  <A HREF="#subroutines">Modules</A>&nbsp;
  <A HREF="#miscellaneous">my</A>&nbsp;
  <A HREF="#operators">ne</A>&nbsp;
  <A HREF="#networking">Networking</A>&nbsp;
  <A HREF="#statements">next</A>&nbsp;
  <A HREF="#subroutines">no</A>&nbsp;
  <A HREF="#operators">npt</A>&nbsp;
  <A HREF="#object">ObjectOrientedProgramming</A>&nbsp;
  <A HREF="#conversion">oct</A>&nbsp;
  <A HREF="#input">open</A>&nbsp;
  <A HREF="#directory">opendir</A>&nbsp;
  <A HREF="#fileoperations">OperationsFile</A>&nbsp;
  <A HREF="#operators">Operators</A>&nbsp;
  <A HREF="#filetest">OperatorsFileTest</A>&nbsp;
  <A HREF="#options">OptionsCommandLine</A>&nbsp;
  <A HREF="#operators">or</A>&nbsp;
  <A HREF="#conversion">ord</A>&nbsp;
  <A HREF="#input">OutputInput</A>&nbsp;
  <A HREF="#specialarrays">OVERLOAD</A>&nbsp;
  <A HREF="#structure">pack</A>&nbsp;
  <A HREF="#subroutines">package</A>&nbsp;
  <A HREF="#subroutines">Packages</A>&nbsp;
  <A HREF="#environment">PATH</A>&nbsp;
  <A HREF="#environment">PERL5DB</A>&nbsp;
  <A HREF="#environment">PERL5LIB</A>&nbsp;
  <A HREF="#environment">PERLLIB</A>&nbsp;
  <A HREF="#input">pipe</A>&nbsp;
  <A HREF="#array">pop</A>&nbsp;
  <A HREF="#search">pos</A>&nbsp;
  <A HREF="#input">print</A>&nbsp;
  <A HREF="#input">printf</A>&nbsp;
  <A HREF="#array">push</A>&nbsp;
  <A HREF="#string">quotemeta</A>&nbsp;
  <A HREF="#arithmetic">rand</A>&nbsp;
  <A HREF="#input">read</A>&nbsp;
  <A HREF="#directory">readdir</A>&nbsp;
  <A HREF="#directory">ReadingDirectoryRoutines</A>&nbsp;
  <A HREF="#fileoperations">readlink</A>&nbsp;
  <A HREF="#networking">recv</A>&nbsp;
  <A HREF="#statements">redo</A>&nbsp;
  <A HREF="#miscellaneous">ref</A>&nbsp;
  <A HREF="#regular">RegularExpressions</A>&nbsp;
  <A HREF="#fileoperations">rename</A>&nbsp;
  <A HREF="#search">ReplaceSearchFunctions</A>&nbsp;
  <A HREF="#subroutines">require</A>&nbsp;
  <A HREF="#miscellaneous">reset</A>&nbsp;
  <A HREF="#subroutines">return</A>&nbsp;
  <A HREF="#array">reverse</A>&nbsp;
  <A HREF="#directory">rewindir</A>&nbsp;
  <A HREF="#string">rindex</A>&nbsp;
  <A HREF="#fileoperations">rmdir</A>&nbsp;
  <A HREF="#directory">RoutinesDirectoryReading</A>&nbsp;
  <A HREF="#search">s</A>&nbsp;
  <A HREF="#array">scalar</A>&nbsp;
  <A HREF="#miscellaneous">scalar</A>&nbsp;
  <A HREF="#search">SearchReplaceFunctions</A>&nbsp;
  <A HREF="#input">seek</A>&nbsp;
  <A HREF="#directory">seekdir</A>&nbsp;
  <A HREF="#input">select</A>&nbsp;
  <A HREF="#networking">send</A>&nbsp;
  <A HREF="#systeminteraction">setpgrp</A>&nbsp;
  <A HREF="#systeminteraction">setpriority</A>&nbsp;
  <A HREF="#networking">setsockopt</A>&nbsp;
  <A HREF="#array">shift</A>&nbsp;
  <A HREF="#networking">shutdown</A>&nbsp;
  <A HREF="#specialarrays">SIG</A>&nbsp;
  <A HREF="#arithmetic">sin</A>&nbsp;
  <A HREF="#systeminteraction">sleep</A>&nbsp;
  <A HREF="#networking">socket</A>&nbsp;
  <A HREF="#networking">socketpair</A>&nbsp;
  <A HREF="#array">sort</A>&nbsp;
  <A HREF="#specialarrays">SpecialArrays</A>&nbsp;
  <A HREF="#specialvariables">SpecialVariables</A>&nbsp;
  <A HREF="#array">splice</A>&nbsp;
  <A HREF="#array">split</A>&nbsp;
  <A HREF="#input">sprintf</A>&nbsp;
  <A HREF="#arithmetic">sqrt</A>&nbsp;
  <A HREF="#arithmetic">srand</A>&nbsp;
  <A HREF="#fileoperations">stat</A>&nbsp;
  <A HREF="#statements">Statements</A>&nbsp;
  <A HREF="#string">StringFunctions</A>&nbsp;
  <A HREF="#structure">StructureConversion</A>&nbsp;
  <A HREF="#search">study</A>&nbsp;
  <A HREF="#subroutines">sub</A>&nbsp;
  <A HREF="#subroutines">Subroutines</A>&nbsp;
  <A HREF="#string">substr</A>&nbsp;
  <A HREF="#fileoperations">symlink</A>&nbsp;
  <A HREF="#systeminteraction">syscall</A>&nbsp;
  <A HREF="#input">sysread</A>&nbsp;
  <A HREF="#systeminteraction">system</A>&nbsp;
  <A HREF="#information">SystemFilesInformationFrom</A>&nbsp;
  <A HREF="#systeminteraction">SystemInteraction</A>&nbsp;
  <A HREF="#systemv">SystemVIPC</A>&nbsp;
  <A HREF="#input">syswrite</A>&nbsp;
  <A HREF="#input">tell</A>&nbsp;
  <A HREF="#directory">telldir</A>&nbsp;
  <A HREF="#filetest">TestFileOperators</A>&nbsp;
  <A HREF="#subroutines">tie</A>&nbsp;
  <A HREF="#arithmetic">time</A>&nbsp;
  <A HREF="#systeminteraction">times</A>&nbsp;
  <A HREF="#search">tr</A>&nbsp;
  <A HREF="#fileoperations">truncate</A>&nbsp;
  <A HREF="#string">uc</A>&nbsp;
  <A HREF="#string">ucfirst</A>&nbsp;
  <A HREF="#systeminteraction">umask</A>&nbsp;
  <A HREF="#miscellaneous">undef</A>&nbsp;
  <A HREF="#statements">unless</A>&nbsp;
  <A HREF="#fileoperations">unlink</A>&nbsp;
  <A HREF="#structure">unpack</A>&nbsp;
  <A HREF="#array">unshift</A>&nbsp;
  <A HREF="#subroutines">untie</A>&nbsp;
  <A HREF="#statements">until</A>&nbsp;
  <A HREF="#statements">until</A>&nbsp;
  <A HREF="#subroutines">use</A>&nbsp;
  <A HREF="#fileoperations">utime</A>&nbsp;
  <A HREF="#array">values</A>&nbsp;
  <A HREF="#variables">Variables</A>&nbsp;
  <A HREF="#environment">VariablesEnvironment</A>&nbsp;
  <A HREF="#specialvariables">VariablesSpecial</A>&nbsp;
  <A HREF="#conversion">vec</A>&nbsp;
  <A HREF="#systeminteraction">wait</A>&nbsp;
  <A HREF="#systeminteraction">waitpid</A>&nbsp;
  <A HREF="#miscellaneous">wantarray</A>&nbsp;
  <A HREF="#systeminteraction">warn</A>&nbsp;
  <A HREF="#statements">while</A>&nbsp;
  <A HREF="#formats">write</A>&nbsp;
  <A HREF="#operators">xor</A>&nbsp;
  <A HREF="#search">y</A>&nbsp;

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="conventions"></A>
  <H2>Conventions</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR>
  <TD><TT><B>fixed&nbsp;&nbsp;</B></TT></TD>
  <TD>denotes literal text.</TD>
  </TR>

  <TR>
  <TD><FONT SIZE="-1">THIS</FONT></TD>
  <TD>means variable text, i.e., things you must fill in.</TD>
  </TR>

  <TR>
  <TD><FONT SIZE="-1">THIS&#134;</FONT></TD>
  <TD>means that <FONT SIZE="-1">THIS</FONT> will default to <TT><B>$_</B></TT> if omitted.</TD>
  </TR>

  <TR>
  <TD><B>word</B></TD>
  <TD>is a keyword, i.e., a word with a special meaning.</TD>
  </TR>

  <TR>
  <TD><FONT SIZE="-1">RETURN key&nbsp;&nbsp;</FONT></TD>
  <TD>denotes pressing a keyboard key.</TD>
  </TR>

  <TR>
  <TD>[...]</TD>
  <TD>denotes an optional part.</TD>
  </TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="options"></A>
  <H2>Command-Line Options</H2>

  <DL COMPACT>

  <DT><TT><B>-a</B></TT>
  <DD>turns on autosplit mode when used with <TT><B>-n</B></TT> or <TT><B>-p</B></TT>.
  Splits to <TT><B>@F</B></TT>.

  <DT><TT><B>-c</B></TT>
  <DD>checks syntax but does not execute.

  <DT><TT><B>-d</B></TT>
  <DD>runs the script under the debugger.
  Use <TT><B>-de 0</B></TT> to start the debugger without a script

  <DT><TT><B>-D</B></TT> <FONT SIZE="-1">NUMBER</FONT>
  <DD>sets debugging flags.

  <DT><TT><B>-e</B></TT> <FONT SIZE="-1">COMMANDLINE</FONT>
  <DD>may be used to enter a single line of script.
  Multiple <TT><B>-e</B></TT> commands may be given to build up a multiline script.

  <DT><TT><B>-F</B></TT> <FONT SIZE="-1">REGEXP</FONT>
  <DD>specifies a regular expression to split on
  if <TT><B>-a</B></TT> is in effect.

  <DT><TT><B>-i</B></TT><FONT SIZE="-1">EXT</FONT>
  <DD>files processed by the <TT><B>&lt; &gt;</B></TT> construct are
  to be edited in place.

  <DT><TT><B>-I</B></TT><FONT SIZE="-1">DIR</FONT>
  <DD>with <TT><B>-P</B></TT>, tells the C preprocessor where to look for include files.
  The directory is prepended to <TT><B>@INC</B></TT>.

  <DT><TT><B>-l</B></TT> [<FONT SIZE="-1">OCTNUM</FONT>]
  <DD>enables automatic line-end processing, e.g., <TT><B>-l013</B></TT>.

  <DT><TT><B>-n</B></TT>
  <DD>assumes an input loop around your script. Lines are not printed.

  <DT><TT><B>-p</B></TT>
  <DD>assumes an input loop around your script. Lines are printed.

  <DT><TT><B>-P</B></TT>
  <DD>runs the C preprocessor on the script before compilation by Perl.

  <DT><TT><B>-s</B></TT>
  <DD>interprets <TT><B>-xxx</B></TT> on the command line as a switch and sets
  the corresponding variable <TT><B>$xxx</B></TT> in the script.

  <DT><TT><B>-S</B></TT>
  <DD>uses the <TT><B>PATH</B></TT> environment variable to search for the script.

  <DT><TT><B>-T</B></TT>
  <DD>forces taint checking.

  <DT><TT><B>-u</B></TT>
  <DD>dumps core after compiling the script. To be used with the <I>undump</I>(1)
  program (where available).

  <DT><TT><B>-U</B></TT>
  <DD>allows perl to perform unsafe operations.

  <DT><TT><B>-v</B></TT>
  <DD>prints the version and patchlevel of your Perl executable.

  <DT><TT><B>-w</B></TT>
  <DD>prints warnings about possible spelling errors and other error-prone
  constructs in the script.

  <DT><TT><B>-x</B></TT> [<FONT SIZE="-1">DIR</FONT>]
  <DD>extracts Perl program from input stream.
  If <FONT SIZE="-1">DIR</FONT> is specified,
  switches to this directory before running the program.

  <DT><TT><B>-0</B></TT><FONT SIZE="-1">VAL</FONT>
  <DD>(that's the number zero.) Designates an initial value for the record
  separator <TT><B>$/</B></TT>. See also <TT><B>-l</B></TT>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="literals"></A>
  <H2>Literals</H2>

  <DL>

  <DT>Numeric:
  <DD><TT><B>123</B></TT>
  <DD><TT><B>1_234</B></TT>
  <DD><TT><B>123.4</B></TT>
  <DD><TT><B>5E-10</B></TT>
  <DD><TT><B>0xff</B></TT> (hex)
  <DD><TT><B>0377</B></TT> (octal)

  <DT>String:
  <DL>

   <DT><TT><B>'abc'</B></TT>
   <DD>literal string, no variable interpolation or escape characters,
   except <TT><B>\'</B></TT> and <TT><B>\\</B></TT>.
   Also: <TT><B>q/abc/</B></TT>.
   Almost any pair of delimiters can be used instead of <TT><B>/</B></TT>...<TT><B>/</B></TT>.

   <DT><TT><B>"abc"</B></TT>
   <DD>Variables are interpolated and escape sequences are processed.
   Also: <TT><B>qq/abc/</B></TT>.
   <BR>Escape sequences:
    <TT><B>\t</B></TT> (Tab),
    <TT><B>\n</B></TT> (Newline),
    <TT><B>\r</B></TT> (Return),
    <TT><B>\f</B></TT> (Formfeed),
    <TT><B>\b</B></TT> (Backspace),
    <TT><B>\a</B></TT> (Alarm),
    <TT><B>\e</B></TT> (Escape),
    <TT><B>\033</B></TT> (octal),
    <TT><B>\x1b</B></TT> (hex),
    <TT><B>\c[</B></TT> (control)
   <BR><TT><B>\l</B></TT> and <TT><B>\u</B></TT> lowercase/uppercase the following character.
   <TT><B>\L</B></TT> and <TT><B>\U</B></TT> lowercase/uppercase until a <TT><B>\E</B></TT>
   is encountered.
   <TT><B>\Q</B></TT> quote regular expression characters until a <TT><B>\E</B></TT>
   is encountered.

   <DT><TT><B>`</B></TT><FONT SIZE="-1">COMMAND</FONT><TT><B>`</B></TT>
   <DD>evaluates to the output of the <FONT SIZE="-1">COMMAND</FONT>.
   Also: <TT><B>qx/</B></TT><FONT SIZE="-1">COMMAND</FONT><TT><B>/</B></TT>.
  </DL>

  <DT>Array:
  <DD><TT><B>(1, 2, 3)</B></TT>. <TT><B>()</B></TT> is an empty array.
  <BR><TT><B>(1..4)</B></TT> is the same as <TT><B>(1,2,3,4)</B></TT>,
  <BR>likewise <TT><B>('a'..'z')</B></TT>.
  <BR><TT><B>qw/foo bar </B></TT>...<TT><B>/</B></TT> is the same as <TT><B>('foo','bar',</B></TT>...<TT><B>)</B></TT>.

  <DT>Array reference:
  <DD><TT><B>[1,2,3]</B></TT>

  <DT>Hash (associative array):
  <DD><TT><B>(</B></TT><FONT SIZE="-1">KEY1</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">VAL1</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">KEY2</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">VAL2</FONT><TT><B>,</B></TT>...<TT><B>)</B></TT>
  <BR>Also
  <TT><B>(</B></TT><FONT SIZE="-1">KEY1</FONT><TT><B>=&gt;</B></TT>
  <FONT SIZE="-1">VAL1</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">KEY2</FONT><TT><B>=&gt;</B></TT>
  <FONT SIZE="-1">VAL2</FONT><TT><B>,</B></TT>...<TT><B>)</B></TT>

  <DT>Hash reference:
  <DD><TT><B>{</B></TT><FONT SIZE="-1">KEY1</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">VAL1</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">KEY2</FONT><TT><B>,</B></TT>
  <FONT SIZE="-1">VAL2</FONT><TT><B>,</B></TT>...<TT><B>}</B></TT>

  <DT>Code reference:
  <DD><B>sub</B> <TT><B>{</B></TT><FONT SIZE="-1">STATEMENTS</FONT><TT><B>}</B></TT>

  <DT>Filehandles:
  <DD>
   <TT><B>&lt;STDIN&gt;</B></TT>,
   <TT><B>&lt;STDOUT&gt;</B></TT>,
   <TT><B>&lt;STDERR&gt;</B></TT>,
   <TT><B>&lt;ARGV&gt;</B></TT>,
   <TT><B>&lt;DATA&gt;</B></TT>.
  <BR>User-specified:
   <FONT SIZE="-1">HANDLE</FONT>,
   <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT>.

  <DT>Globs:
  <DD><TT><B>&lt;</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>&gt;</B></TT>
  evaluates to all filenames according to the pattern.
  Use <TT><B>&lt;${</B></TT><FONT SIZE="-1">VAR</FONT><TT><B>}&gt;</B></TT>
  or <B>glob</B>&nbsp;<TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT>
  to glob from a variable.

  <DT>Here-Is:
  <DD><TT><B>&lt;&lt;</B></TT><FONT SIZE="-1">IDENTIFIER</FONT>
  <BR>Shell-style "here document."

  <DT>Special tokens:
  <DD><TT><B>__FILE__</B></TT>: filename;
  <TT><B>__LINE__</B></TT>: line number;
  <TT><B>__END__</B></TT>: end of program;
  remaining lines can be read using the filehandle <TT><B>DATA</B></TT>.

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="variables"></A>
  <H2>Variables</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR>
  <TD VALIGN=top><TT><B>$var</B></TT></TD>
  <TD VALIGN=top>a simple scalar variable.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$var[28]</B></TT></TD>
  <TD VALIGN=top>29th element of array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$p = \@var</B></TT></TD>
  <TD VALIGN=top>now <TT><B>$p</B></TT> is a reference to array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$$p[28]</B></TT></TD>
  <TD VALIGN=top>29th element of array referenced by <TT><B>$p</B></TT>.
  <BR>Also, <TT><B>$p-&gt;[28]</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$var[-1]</B></TT></TD>
  <TD VALIGN=top>last element of array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$var[$i][$j]</B></TT></TD>
  <TD VALIGN=top><TT><B>$j</B></TT>th element of the <TT><B>$i</B></TT>th element of
  array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$var{'Feb'}</B></TT></TD>
  <TD VALIGN=top>one value from hash (associative array) <TT><B>%var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$p = \%var</B></TT></TD>
  <TD VALIGN=top>now <TT><B>$p</B></TT> is a reference to hash <TT><B>%var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$$p{'Feb'}</B></TT></TD>
  <TD VALIGN=top>a value from hash referenced by <TT><B>$p</B></TT>.
  <BR>Also, <TT><B>$p-&gt;{'Feb'}</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$#var</B></TT></TD>
  <TD VALIGN=top>last index of array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>@var</B></TT></TD>
  <TD VALIGN=top>the entire array;
  in a scalar context, the number of elements in the array.</TD>
  </TR>

  <TR><!-- bobh added -->
  <TD VALIGN=top><TT><B>"@var"</B></TT></TD>
  <TD VALIGN=top>the entire array;
  in a list context, separated by a space.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>@var[3,4,5]</B></TT></TD>
  <TD VALIGN=top>a slice of array <TT><B>@var</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>@var{'a','b'}</B></TT></TD>
  <TD VALIGN=top>a slice of <TT><B>%var</B></TT>;
  same as <TT><B>($var{'a'},$var{'b'})</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>%var</B></TT></TD>
  <TD VALIGN=top>the entire hash;
  in a scalar context, <B>true</B> if the hash has elements.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>$var{'a',1,</B></TT>...<TT><B>}</B></TT></TD>
  <TD VALIGN=top>emulates a multidimensional array.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>('a'</B></TT>...<TT><B>'z')[4,7,9]</B></TT></TD>
  <TD VALIGN=top>a slice of an array literal.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><FONT SIZE="-1">PKG</FONT><TT><B>::</B></TT><FONT SIZE="-1">VAR</FONT></TD>
  <TD VALIGN=top>a variable from a package, e.g.,
  <TT><B>$pkg::var</B></TT>, <TT><B>@pkg::ary</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>\</B></TT><FONT SIZE="-1">OBJECT</FONT></TD>
  <TD VALIGN=top>reference to an object, e.g.,
  <TT><B>\$var</B></TT>, <TT><B>\%hash</B></TT>.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>*</B></TT><FONT SIZE="-1">NAME</FONT></TD>
  <TD VALIGN=top>refers to all objects represented by <FONT SIZE="-1">NAME</FONT>.
  <BR><TT><B>*n1 = *n2</B></TT> makes <TT><B>n1</B></TT> an alias for <TT><B>n2</B></TT>.
  <BR><TT><B>*n1 = $n2</B></TT> makes <TT><B>$n1</B></TT> an alias for <TT><B>$n2</B></TT>.
  </TD>
  </TR>

  </TABLE>

  <P>
  You can always use a <TT><B>{</B></TT><FONT SIZE="-1">BLOCK</FONT><TT><B>}</B></TT>
  returning the right type of reference instead of the variable identifier, e.g.,
  <TT><B>${</B></TT>...<TT><B>}</B></TT>,
  <TT><B>&amp;{</B></TT>...<TT><B>}</B></TT>.
  <TT><B>$$p</B></TT> is just a shorthand for <TT><B>${$p}</B></TT>.
  </P>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <A NAME="operators"></A>
  <H2>Operators</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR>
  <TD VALIGN=top><TT><B>**</B></TT></TD>
  <TD></TD>
  <TD>Exponentiation</TD>
  </TR>

  <TR>
  <TD NOWRAP VALIGN=top><TT><B>+ -&nbsp;</B></TT></TD>
  <TD NOWRAP VALIGN=top><TT><B>* /&nbsp;</B></TT></TD>
  <TD>Addition, subtraction, multiplication, division</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>%</B></TT></TD>
  <TD></TD>
  <TD>Modulo division</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>&amp; |</B></TT></TD>
  <TD VALIGN=top><TT><B>^</B></TT></TD>
  <TD>Bitwise AND, bitwise OR, bitwise exclusive OR</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>&gt;&gt;</B></TT></TD>
  <TD VALIGN=top><TT><B>&lt;&lt;</B></TT></TD>
  <TD>Bitwise shift right, bitwise shift left</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>||</B></TT></TD>
  <TD VALIGN=top><TT><B>&amp;&amp;</B></TT></TD>
  <TD>Logical OR, logical AND</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>.</B></TT></TD>
  <TD></TD>
  <TD>Concatenation of two strings</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>x</B></TT></TD>
  <TD VALIGN=top></TD>
  <TD VALIGN=top>Returns a string or array consisting of the left operand (an array or a string)
  repeated the number of times specified by the right operand</TD>
  </TR>

  <TR>
  <TD COLSPAN=3>
  All of the above operators also have an assignment operator,
  e.g., <TT><B>.=</B></TT></TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>-&gt;</B></TT></TD>
  <TD></TD>
  <TD>Dereference operator</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>\</B></TT></TD>
  <TD></TD>
  <TD>Reference (unary)</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>!</B></TT></TD>
  <TD VALIGN=top><TT><B>~</B></TT></TD>
  <TD>Negation (unary), bitwise complement (unary)</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>++</B></TT></TD>
  <TD VALIGN=top><TT><B>--</B></TT></TD>
  <TD>Auto-increment (magical on strings), auto-decrement</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>==</B></TT></TD>
  <TD VALIGN=top><TT><B>!=</B></TT></TD>
  <TD>Numeric equality, inequality</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>eq</B></TT></TD>
  <TD VALIGN=top><TT><B>ne</B></TT></TD>
  <TD>String equality, inequality</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>&lt;</B></TT></TD>
  <TD VALIGN=top><TT><B>&gt;</B></TT></TD>
  <TD>Numeric less than, greater than</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>lt</B></TT></TD>
  <TD VALIGN=top><TT><B>gt</B></TT></TD>
  <TD>String less than, greater than</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>&lt;=</B></TT></TD>
  <TD VALIGN=top><TT><B>&gt;=</B></TT></TD>
  <TD>Numeric less (greater) than or equal to</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>le</B></TT></TD>
  <TD VALIGN=top><TT><B>ge</B></TT></TD>
  <TD>String less (greater) than or equal to</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>&lt;=&gt;</B></TT></TD>
  <TD VALIGN=top><TT><B>cmp</B></TT></TD>
  <TD>Numeric (string) compare. Returns -1, 0, 1.</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>=~</B></TT></TD>
  <TD VALIGN=top><TT><B>!~</B></TT></TD>
  <TD>Search pattern, substitution, or translation (negated)</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>..</B></TT></TD>
  <TD></TD>
  <TD>Range (scalar context) or enumeration (array context)</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>?:</B></TT></TD>
  <TD></TD>
  <TD>Alternation (if-then-else) operator</TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>,</B></TT></TD>
  <TD></TD>
  <TD>Comma operator, also list element separator.
  You can also use <TT><B>=&gt;</B></TT>.
  </TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>not</B></TT></TD>
  <TD></TD>
  <TD>Low-precedence negation
  </TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>and</B></TT></TD>
  <TD></TD>
  <TD>Low-precedence AND
  </TD>
  </TR>

  <TR>
  <TD VALIGN=top><TT><B>or</B></TT></TD>
  <TD VALIGN=top><TT><B>xor</B></TT></TD>
  <TD>Low-precedence OR, exclusive OR
  </TD>
  </TR>

  </TABLE>

  <P>All Perl functions can be used as list operators, in which case
  they have very high or very low precedence, depending on
  whether you look at the left or the right side of the operator.
  Only the operators <B>not</B>, <B>and</B>, <B>or</B> and <B>xor</B> have lower precedence.</P>

  <P>A "list" is a list of expressions, variables, or lists. An array
  variable or an array slice may always be used instead of a list.</P>

  <P>Parentheses can be added around the parameter lists
  to avoid precedence problems.</P>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="statements"></A>
  <H2>Statements</H2>

  <P>Every statement is an expression, optionally followed by a modifier,
  and terminated by a semicolon.  The semicolon may be omitted if the
  statement is the final one in a <FONT SIZE="-1">BLOCK</FONT>.</P>

  <P>Execution of expressions can depend on other expressions using one of the modifiers
  <B>if</B>, <B>unless</B>, <B>while</B> or <B>until</B>, for example:</P>

  <UL>
  <FONT SIZE="-1">EXPR1</FONT> <B>if</B> <FONT SIZE="-1">EXPR2</FONT> <TT><B>;</B></TT>
  <BR>
  <FONT SIZE="-1">EXPR1</FONT> <B>until</B> <FONT SIZE="-1">EXPR2</FONT> <TT><B>;</B></TT>
  </UL>

  <P>The logical operators <TT><B>||</B></TT>,
  <TT><B>&amp;&amp;</B></TT> or
  <TT><B>?:</B></TT> also allow conditional execution:</P>

  <UL>
  <FONT SIZE="-1">EXPR1</FONT> <TT><B>||</B></TT> <FONT SIZE="-1">EXPR2</FONT> <TT><B>;</B></TT>
  <BR>
  <FONT SIZE="-1">EXPR1</FONT> <TT><B>?</B></TT> <FONT SIZE="-1">EXPR2</FONT> <TT><B>:</B></TT> <FONT SIZE="-1">EXPR3</FONT> <TT><B>;</B></TT>
  </UL>

  <P>Statements can be combined to form a <FONT SIZE="-1">BLOCK</FONT>
  when enclosed in <TT><B>{}</B></TT>. Blocks may be used to control flow:</P>

  <UL>
  <B>if</B> <TT><B>(</B></TT><FONT SIZE="-1">EXPR</FONT><TT><B>)</B></TT> <FONT SIZE="-1">BLOCK</FONT>
  [ [ <B>elsif</B> <TT><B>(</B></TT><FONT SIZE="-1">EXPR</FONT><TT><B>)</B></TT> <FONT SIZE="-1">BLOCK</FONT> ... ]
  <B>else</B> <FONT SIZE="-1">BLOCK</FONT> ]
  <BR>
  <B>unless</B> <TT><B>(</B></TT><FONT SIZE="-1">EXPR</FONT><TT><B>)</B></TT> <FONT SIZE="-1">BLOCK</FONT>
  [ <B>else</B> <FONT SIZE="-1">BLOCK</FONT> ]
  <BR>
  [ <FONT SIZE="-1">LABEL</FONT><TT><B>:</B></TT> ]
  <B>while</B> (<FONT SIZE="-1">EXPR</FONT>) <FONT SIZE="-1">BLOCK</FONT> [ <B>continue</B> <FONT SIZE="-1">BLOCK</FONT> ]
  <BR>
  [ <FONT SIZE="-1">LABEL</FONT><TT><B>:</B></TT> ]
  <B>until</B> (<FONT SIZE="-1">EXPR</FONT>) <FONT SIZE="-1">BLOCK</FONT> [ <B>continue</B> <FONT SIZE="-1">BLOCK</FONT> ]
  <BR>
  [ <FONT SIZE="-1">LABEL</FONT><TT><B>:</B></TT> ]
  <B>for</B> (<FONT SIZE="-1">EXPR</FONT><TT><B>;</B></TT> <FONT SIZE="-1">EXPR</FONT><TT><B>;</B></TT> <FONT SIZE="-1">EXPR</FONT>) <FONT SIZE="-1">BLOCK</FONT>
  <BR>
  [ <FONT SIZE="-1">LABEL</FONT><TT><B>:</B></TT> ]
  <B>foreach</B> <FONT SIZE="-1">VAR&#134;</FONT> (<FONT SIZE="-1">LIST</FONT>) <FONT SIZE="-1">BLOCK</FONT>
  <BR>
  [ <FONT SIZE="-1">LABEL</FONT><TT><B>:</B></TT> ]
  <FONT SIZE="-1">BLOCK</FONT> [ <B>continue</B> <FONT SIZE="-1">BLOCK</FONT> ]
  </UL>

  <P>Program flow can be controlled with:</P>

  <UL>
  <TABLE CELLPADDING=0 CELLSPACING=0>
  <TR><TD NOWRAP VALIGN=top><B>goto</B> <FONT SIZE="-1">LABEL</FONT></TD>
  <TD>Continue execution at the specified label.</TD></TR>
  <TR><TD NOWRAP VALIGN=top><B>last</B> [ <FONT SIZE="-1">LABEL</FONT> ]</TD>
  <TD>Immediately exits the loop in question. Skips continue block.</TD></TR>
  <TR><TD NOWRAP VALIGN=top><B>next</B> [ <FONT SIZE="-1">LABEL</FONT> ]</TD>
  <TD>Starts the next iteration of the loop.</TD></TR>
  <TR><TD NOWRAP VALIGN=top><B>redo</B> [ <FONT SIZE="-1">LABEL</FONT> ]&nbsp;&nbsp;</TD>
  <TD>Restarts the loop block without evaluating the conditional again.</TD></TR>
  </TABLE>
  </UL>

  <P>Special forms are:</P>

  <UL>
  <B>do</B> <FONT SIZE="-1">BLOCK</FONT> <B>while</B> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</B></TT>
  <BR>
  <B>do</B> <FONT SIZE="-1">BLOCK</FONT> <B>until</B> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</B></TT>
  </UL>

  <P>which are guaranteed to perform <FONT SIZE="-1">BLOCK</FONT>
  once before testing <FONT SIZE="-1">EXPR</FONT>, and</P>

  <UL>
  <B>do</B> <FONT SIZE="-1">BLOCK</FONT>
  </UL>

  <P>which effectively turns <FONT SIZE="-1">BLOCK</FONT> into an expression.</P>


  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="subroutines"></A>
  <H2>Subroutines, Packages and Modules</H2>

  <DL>

  <DT><TT><B>&amp;</B></TT><FONT SIZE="-1">SUBROUTINE LIST</FONT>
  <DD>Executes a <FONT SIZE="-1">SUBROUTINE</FONT> declared by a <B>sub</B> declaration, and
  returns the value of the last expression evaluated in <FONT SIZE="-1">SUBROUTINE</FONT>.
  <FONT SIZE="-1">SUBROUTINE</FONT> can be an expression yielding a reference to a code object.
  The <TT><B>&amp;</B></TT> may be omitted if the subroutine has been declared
  before being used.

  <DT><B>bless</B> <FONT SIZE="-1">REF</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">PACKAGE</FONT> ]
  <DD>Turns the object <FONT SIZE="-1">REF</FONT>
  into an object in <FONT SIZE="-1">PACKAGE</FONT>.
  Returns the reference.<A HREF="#xcbless">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>caller</B> [ <FONT SIZE="-1">EXPR</FONT> ]
  <DD>Returns an array (<TT><B>$</B></TT>package,<TT><B>$</B></TT>file,<TT><B>$</B></TT>line,...)
  for a specific subroutine call.
  <TT><B>caller</B></TT> returns this info for the current subroutine,
  <TT><B>caller(1)</B></TT> for the caller of this subroutine, etc.
  Returns <B>false</B> if no caller.<A HREF="#xccaller">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>do</B> <FONT SIZE="-1">SUBROUTINE</FONT> <FONT SIZE="-1">LIST</FONT>
  <DD>Deprecated form of <TT><B>&amp;</B></TT><FONT SIZE="-1">SUBROUTINE</FONT>.<A HREF="#xcdo">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>goto</B> <TT><B>&amp;</B></TT><FONT SIZE="-1">SUBROUTINE</FONT>
  <DD>Substitutes a call to <FONT SIZE="-1">SUBROUTINE</FONT> for the current subroutine.

  <DT><B>import</B> <FONT SIZE="-1">MODULE</FONT> [ [ <FONT SIZE="-1">VERSION</FONT> ] <FONT SIZE="-1">LIST</FONT> ]
  <DD>Imports the named subroutines from <FONT SIZE="-1">MODULE</FONT>.<A HREF="#xcimport">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>no</B> <FONT SIZE="-1">MODULE</FONT> [ <FONT SIZE="-1">LIST</FONT> ]
  <DD>Cancels imported semantics. See <B>use</B>.

  <DT><B>package</B> <FONT SIZE="-1">NAME</FONT>
  <DD>Designates the remainder of the current block as a package.

  <DT><B>require</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>If <FONT SIZE="-1">EXPR</FONT> is numeric, requires Perl to be at least that
  version. Otherwise <FONT SIZE="-1">EXPR</FONT> must be the name of a file
  that is included from the Perl library. Does not
  include more than once, and yields a fatal error if
  the file does not evaluate to a <B>true</B> value.
  If <FONT SIZE="-1">EXPR</FONT> is a bare word, assumes extension <TT><B>.pm</B></TT>
  for the name of the file.

  <DT><B>return</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns from a subroutine with the value specified.

  <DT><B>sub</B> <FONT SIZE="-1">NAME</FONT> <TT><B>{</B></TT> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</B></TT> ... <TT><B>}</B></TT>
  <DD>Designates <FONT SIZE="-1">NAME</FONT> as a subroutine.
  Parameters are passed by reference as array <TT><B>@_</B></TT>.
  Returns the value of the last expression evaluated.

  <DT>[ <B>sub</B> ] <TT><B>BEGIN</B></TT> <TT><B>{</B></TT> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</B></TT> ... <TT><B>}</B></TT>
  <DD>Defines a setup <FONT SIZE="-1">BLOCK</FONT> to be called before execution.

  <DT>[ <B>sub</B> ] <TT><B>END</B></TT> <TT><B>{</B></TT> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</B></TT> ... <TT><B>}</B></TT>
  <DD>Defines a cleanup <FONT SIZE="-1">BLOCK</FONT> to be called upon termination.

  <DT><B>tie</B> <FONT SIZE="-1">VAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PACKAGE</FONT><TT><B>,</B></TT> [ <FONT SIZE="-1">LIST</FONT> ]
  <DD>Ties a variable to a package that will handle it.
  Can be used to bind a dbm or ndbm file to a hash.

  <DT><B>untie</B> <FONT SIZE="-1">VAR</FONT>
  <DD>Breaks the binding between the variable and the package.

  <DT><B>use</B> <FONT SIZE="-1">MODULE</FONT> [ [ <FONT SIZE="-1">VERSION</FONT> ] <FONT SIZE="-1">LIST</FONT> ]
  <DD>Imports semantics from the named module into the current package.

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="object"></A>
  <H2>Object-Oriented Programming</H2>

  <P>Perl rules of object oriented programming:</P>

  <UL>
  <LI>An object is simply a reference that happens to know which class it
  belongs to. Objects are blessed, references are not.
  <LI>A class is simply a package that happens to provide methods to deal
  with object references. If a package fails to provide a method, the base classes as
  listed in <TT><B>@ISA</B></TT> are searched.
  <LI>A method is simply a subroutine that expects an object reference (or a
  package name, for static methods) as the first argument.
  </UL>

  <P>Methods can be applied with:</P>

  <UL>
  <FONT SIZE="-1">METHOD</FONT> <FONT SIZE="-1">OBJREF</FONT> <FONT SIZE="-1">PARAMETERS</FONT>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or<BR>
  <FONT SIZE="-1">OBJREF</FONT><TT><B>-&gt;</B></TT><FONT SIZE="-1">METHOD</FONT> <FONT SIZE="-1">PARAMETERS</FONT>
  </UL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="arithmetic"></A>
  <H2>Arithmetic Functions</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top><B>abs</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns the absolute value of its operand.<A HREF="#xcabs">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>atan2</B> <FONT SIZE="-1">Y</FONT><TT><B>,</B></TT><FONT SIZE="-1">X</FONT></TD>
  <TD VALIGN=top>Returns the arctangent of <FONT SIZE="-1">Y/X</FONT> in the range -pi to pi.<A HREF="#xcatan2">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>cos</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns the cosine of <FONT SIZE="-1">EXPR</FONT> (expressed in radians).<A HREF="#xccos">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>exp</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns <TT><B>e</B></TT> to the power of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcexp">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>int</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns the integer portion of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcint">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>log</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns natural logarithm (base <TT><B>e</B></TT>) of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xclog">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>rand</B> [ <FONT SIZE="-1">EXPR</FONT> ]</TD>
  <TD VALIGN=top>Returns a random fractional number between 0 and the value of <FONT SIZE="-1">EXPR</FONT>.
  If <FONT SIZE="-1">EXPR</FONT> is omitted, returns a value between 0 and 1.<A HREF="#xcrand">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>sin</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns the sine of <FONT SIZE="-1">EXPR</FONT> (expressed in radians).<A HREF="#xcsin">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>sqrt</B> <FONT SIZE="-1">EXPR&#134;</FONT></TD>
  <TD VALIGN=top>Returns the square root of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcsqrt">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top NOWRAP><B>srand</B> [ <FONT SIZE="-1">EXPR</FONT> ] &nbsp;&nbsp;</TD>
  <TD VALIGN=top>Sets the random number seed for the <B>rand</B> operator.<A HREF="#xcsrand">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  <TR><TD VALIGN=top><B>time</B></TD>
  <TD VALIGN=top>Returns the number of seconds since January 1, 1970. Suitable for
  feeding to <B>gmtime</B> and <B>localtime</B>.<A HREF="#xctime">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="conversion"></A>
  <H2>Conversion Functions</H2>

  <DL>

  <DT><B>chr</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the character represented by the decimal value <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcchr">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>gmtime</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Converts a time as returned by the <B>time</B> function to a 9-element array
  (0:&nbsp;<TT><B>$</B></TT>sec,
  1:&nbsp;<TT><B>$</B></TT>min,
  2:&nbsp;<TT><B>$</B></TT>hour,
  3:&nbsp;<TT><B>$</B></TT>mday,
  4:&nbsp;<TT><B>$</B></TT>mon,
  5:&nbsp;<TT><B>$</B></TT>year,
  6:&nbsp;<TT><B>$</B></TT>wday,
  7:&nbsp;<TT><B>$</B></TT>yday,
  8:&nbsp;<TT><B>$</B></TT>isdst)
  with the time analyzed for the Greenwich time zone. <TT><B>$</B></TT>mon has the range 0..11 and
  <TT><B>$</B></TT>wday has the range 0..6.<A HREF="#xcgmtime">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>hex</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the decimal value of <FONT SIZE="-1">EXPR</FONT> interpreted as a hex string.<A HREF="#xchex">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>localtime</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Converts a time as returned by the <B>time</B> function to
  <I>ctime</I>(3) string.
  In array context, returns a 9-element array with the time analyzed for the local time zone.<A HREF="#xclocaltime">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>oct</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the decimal value of <FONT SIZE="-1">EXPR</FONT> interpreted as an octal string.
  If <FONT SIZE="-1">EXPR</FONT> starts off with <TT><B>0x</B></TT>, interprets it as a hex string
  instead.<A HREF="#xcoct">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>ord</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the ASCII value of the first character of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcord">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>vec</B> <FONT SIZE="-1">EXPR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">BITS</FONT>
  <DD>Treats string <FONT SIZE="-1">EXPR</FONT> as a vector of unsigned integers,
  and yields the bit at <FONT SIZE="-1">OFFSET</FONT>.
  <FONT SIZE="-1">BITS</FONT> must be between 1 and 32.
  May be assigned to.<A HREF="#xcvec">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="structure"></A>
  <H2>Structure Conversion</H2>

  <DL>

  <DT><B>pack</B> <FONT SIZE="-1">TEMPLATE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Packs the values into a binary structure using <FONT SIZE="-1">TEMPLATE</FONT>.<A HREF="#xcpack">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>unpack</B> <FONT SIZE="-1">TEMPLATE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">EXPR</FONT>
  <DD>Unpacks the structure <FONT SIZE="-1">EXPR</FONT> into an array,
  using <FONT SIZE="-1">TEMPLATE</FONT>.<A HREF="#xcunpack">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <P><FONT SIZE="-1">TEMPLATE</FONT> is a sequence of characters as follows:</P>

  <UL>
  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD><TT><B>a</B></TT> / <TT><B>A&nbsp;</B></TT></TD>
  <TD>ASCII string, null- / space-padded</TD></TR>

  <TR><TD><TT><B>b</B></TT> / <TT><B>B</B></TT></TD>
  <TD>Bit string in ascending / descending order</TD></TR>

  <TR><TD><TT><B>c</B></TT> / <TT><B>C</B></TT></TD>
  <TD>Native / unsigned char value</TD></TR>

  <TR><TD><TT><B>f</B></TT> / <TT><B>d</B></TT></TD>
  <TD>Single / double float in native format</TD></TR>

  <TR><TD><TT><B>h</B></TT> / <TT><B>H</B></TT></TD>
  <TD>Hex string, low / high nybble first</TD></TR>

  <TR><TD><TT><B>i</B></TT> / <TT><B>I</B></TT></TD>
  <TD>Signed / unsigned integer value</TD></TR>

  <TR><TD><TT><B>l</B></TT> / <TT><B>L</B></TT></TD>
  <TD>Signed / unsigned long value</TD></TR>

  <TR><TD><TT><B>n</B></TT> / <TT><B>N</B></TT></TD>
  <TD>Short / long in network (big endian) byte order</TD></TR>

  <TR><TD><TT><B>s</B></TT> / <TT><B>S</B></TT></TD>
  <TD>Signed / unsigned short value</TD></TR>

  <TR><TD><TT><B>u</B></TT> / <TT><B>P</B></TT></TD>
  <TD>Uuencoded string / pointer to a string</TD></TR>

  <TR><TD><TT><B>v</B></TT> / <TT><B>V</B></TT></TD>
  <TD>Short / long in VAX (little endian) byte order</TD></TR>

  <TR><TD><TT><B>x</B></TT> / <TT><B>@</B></TT></TD>
  <TD>Null byte / null fill until position</TD></TR>

  <TR><TD><TT><B>X</B></TT></TD>
  <TD>Backup a byte</TD></TR>

  </TABLE>
  </UL>

  <P>Each character may be followed by a decimal number that
  will be used as a repeat count; an asterisk (<TT><B>*</B></TT>) specifies all
  remaining arguments. If the format is preceded with <TT><B>%</B></TT><FONT SIZE="-1">N</FONT>,
  <B>unpack</B> returns an <FONT SIZE="-1">N</FONT>-bit checksum instead. Spaces may be
  included in the template for readability purposes.</P>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="string"></A>
  <H2>String Functions</H2>

  <DL>

  <DT><B>chomp</B> <FONT SIZE="-1">LIST&#134;</FONT>
  <DD>Removes line endings from all elements of the list;
  returns the (total) number of characters removed.<A HREF="#xcchomp">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>chop</B> <FONT SIZE="-1">LIST&#134;</FONT>
  <DD>Chops off the last character on all elements of the
  list; returns the last chopped character.<A HREF="#xcchop">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>crypt</B> <FONT SIZE="-1">PLAINTEXT</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SALT</FONT>
  <DD>Encrypts a string.<A HREF="#xccrypt">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>eval</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD><FONT SIZE="-1">EXPR</FONT> is parsed and executed as if it were a Perl program.
  The value returned is the value of the last expression evaluated.
  If there is a syntax error or runtime error,
  an undefined string is returned by <B>eval</B>, and
  <TT><B>$@</B></TT> is set to the error message.
  See also <B>eval</B> in section <A HREF="#miscellaneous">Miscellaneous</A>.<A HREF="#xceval">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>index</B> <FONT SIZE="-1">STR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SUBSTR</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> ]
  <DD>Returns the position of <FONT SIZE="-1">SUBSTR</FONT>
  in <FONT SIZE="-1">STR</FONT> at or after <FONT SIZE="-1">OFFSET</FONT>.
  If the substring is not found, returns <TT><B>-1</B></TT>
  (but see <TT><B>$[</B></TT> in section <A HREF="#specialvariables">Special Variables</A>).<A HREF="#xcindex">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>length</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the length in characters of the value of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xclength">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>lc</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns a lowercase version of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xclc">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>lcfirst</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns <FONT SIZE="-1">EXPR</FONT> with the first character lowercase.<A HREF="#xclcfirst">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>quotemeta</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns <FONT SIZE="-1">EXPR</FONT> with all regular expression metacharacters quoted.<A HREF="#xcquotemeta">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>rindex</B> <FONT SIZE="-1">STR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SUBSTR</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> ]
  <DD>Returns the position of the last <FONT SIZE="-1">SUBSTR</FONT>
  in <FONT SIZE="-1">STR</FONT> at or before <FONT SIZE="-1">OFFSET</FONT>.<A HREF="#xcrindex">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>substr</B> <FONT SIZE="-1">EXPR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">LEN</FONT> ]
  <DD>Extracts a substring of length <FONT SIZE="-1">LEN</FONT> out of <FONT SIZE="-1">EXPR</FONT>
  and returns it. If <FONT SIZE="-1">OFFSET</FONT> is negative, counts from the end of
  the string. May be assigned to.<A HREF="#xcsubstr">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>uc</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns an uppercased version of <FONT SIZE="-1">EXPR</FONT>.<A HREF="#xcuc">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>ucfirst</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Returns <FONT SIZE="-1">EXPR</FONT> with the first character uppercased.<A HREF="#xcucfirst">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="array"></A>
  <H2>Array and List Functions</H2>

  <DL>

  <DT><B>delete</B> <TT><B>$</B></TT><FONT SIZE="-1">HASH</FONT><TT><B>{</B></TT><FONT SIZE="-1">KEY</FONT><TT><B>}</B></TT>
  <DD>Deletes the specified value from the specified hash.
  Returns the deleted value unless <FONT SIZE="-1">HASH</FONT> is <B>tie</B>d
  to a package that does not support this.

  <DT><B>each</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT>
  <DD>Returns a 2-element array consisting of the key and value for the next value
  of the hash. Entries are returned in an apparently random order.
  After all values of the hash have been returned, a null array is
  returned. The next call to <B>each</B> after that will start iterating again.<A HREF="#xceach">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>exists</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Checks if the specified hash key exists in its hash array.<A HREF="#xcexists">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>grep</B> <FONT SIZE="-1">EXPR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <BR><B>grep</B> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">LIST</FONT>
  <DD>Evaluates <FONT SIZE="-1">EXPR</FONT> or <FONT SIZE="-1">BLOCK</FONT> for each element of the <FONT SIZE="-1">LIST</FONT>,
  locally setting <TT><B>$_</B></TT> to refer to the element.
  Modifying <TT><B>$_</B></TT> will modify the
  corresponding element from <FONT SIZE="-1">LIST</FONT>.
  Returns the array of elements from
  <FONT SIZE="-1">LIST</FONT> for which <FONT SIZE="-1">EXPR</FONT> returned <B>true</B>.<A HREF="#xcgrep">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>join</B> <FONT SIZE="-1">EXPR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Joins the separate strings of <FONT SIZE="-1">LIST</FONT> into a single string with fields
  separated by the value of <FONT SIZE="-1">EXPR</FONT>, and returns the string.<A HREF="#xcjoin">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>keys</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT>
  <DD>Returns an array with of all the keys of the named hash.<A HREF="#xckeys">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>map</B> <FONT SIZE="-1">EXPR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <BR><B>map</B> <FONT SIZE="-1">BLOCK</FONT> <FONT SIZE="-1">LIST</FONT>
  <DD>Evaluates <FONT SIZE="-1">EXPR</FONT> or <FONT SIZE="-1">BLOCK</FONT> for each element of the <FONT SIZE="-1">LIST</FONT>,
  locally setting <TT><B>$_</B></TT> to refer to the element.
  Modifying <TT><B>$_</B></TT> will modify the
  corresponding element from <FONT SIZE="-1">LIST</FONT>.
  Returns the list of results.<A HREF="#xcmap">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>pop</B> <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT>
  <DD>Pops off and returns the last value of the array.<A HREF="#xcpop">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>push</B> <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Pushes the values of <FONT SIZE="-1">LIST</FONT> onto the end of the array.<A HREF="#xcpush">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>reverse</B> <FONT SIZE="-1">LIST</FONT>
  <DD>In array context, returns the <FONT SIZE="-1">LIST</FONT> in reverse order.
  In scalar context: returns the first element of <FONT SIZE="-1">LIST</FONT>
  with bytes reversed.<A HREF="#xcreverse">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>scalar</B> <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT>
  <DD>Returns the number of elements in the array.<A HREF="#xcscalar">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>scalar</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT>
  <DD>Returns a <B>true</B> value if the hash has elements defined.<A HREF="#xcscalar">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shift</B> [ <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT> ]
  <DD>Shifts the first value of the array off and returns it, shortening the array
  by 1 and moving everything down. If <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT> is omitted,
  shifts <TT><B>@ARGV</B></TT> in main and <TT><B>@_</B></TT> in subroutines.<A HREF="#xcshift">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>sort</B> [ <FONT SIZE="-1">SUBROUTINE</FONT> ] <FONT SIZE="-1">LIST</FONT>
  <DD>Sorts the <FONT SIZE="-1">LIST</FONT> and returns the sorted array value.
  <FONT SIZE="-1">SUBROUTINE</FONT>, if specified, must return less than zero,
  zero, or greater than zero, depending on how the
  elements of the array (available to the routine as <TT><B>$a</B></TT> and <TT><B>$b</B></TT>)
  are to be ordered. <FONT SIZE="-1">SUBROUTINE</FONT> may be the name of a user-defined
  routine, or a <FONT SIZE="-1">BLOCK</FONT>.<A HREF="#xcsort">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>splice</B> <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">LENGTH</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT> ] ]
  <DD>Removes the elements of <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT> designated by
  <FONT SIZE="-1">OFFSET</FONT> and <FONT SIZE="-1">LENGTH</FONT>,
  and replaces them with <FONT SIZE="-1">LIST</FONT> (if specified).
  Returns the elements removed.<A HREF="#xcsplice">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>split</B> [ <FONT SIZE="-1">PATTERN</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">EXPR&#134;</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">LIMIT</FONT> ] ] ]
  <DD>Splits a string into an array of strings, and returns it.
  If <FONT SIZE="-1">LIMIT</FONT> is specified, splits into at most that number
  of fields. If <FONT SIZE="-1">PATTERN</FONT> is also omitted, splits at the whitespace.
  If not in array context, returns number of fields and splits to <TT><B>@_</B></TT>.
  See also <A HREF="#search">Search and Replace Functions</A>.<A HREF="#xcsplit">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>
  <BR>
  <P>If you need to split a string into fields based on a delimiter sequence of characters, you can do this:

        @array = split(/:/);

        @array will be an array of strings consisting of the values between the delimiters. If there are repeated delimiters - :: in this example - then an
        empty array element will be created. Use /:+/ as the delimiter to match in order to eliminate the empty array elements.
  </P>
  <BR>
  <DT><B>unshift</B> <TT><B>@</B></TT><FONT SIZE="-1">ARRAY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Prepends list to the front of the array, and returns the number of elements in
  the new array.<A HREF="#xcunshift">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>values</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT>
  <DD>Returns a normal array consisting of all the values of the named hash.<A HREF="#xcvalues">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="regular"></A>
  <H2>Regular Expressions</H2>

  <P>Each character matches itself, unless it is one of the special characters
  <TT><B>+ ? . * ^ $ ( ) [ ] { } | \</B></TT>.
  The special meaning of these characters can be escaped using a <TT><B>\</B></TT>.</P>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top><TT><B>.</B></TT></TD>
  <TD VALIGN=top>matches an arbitrary character, but not a newline
  unless it is a single-line match (see <B>m//s</B>).</TD></TR>

  <TR><TD VALIGN=top><TT><B>(</B></TT>...<TT><B>)</B></TT></TD>
  <TD>groups a series of pattern elements to a single element.</TD></TR>

  <TR><TD VALIGN=top><TT><B>^</B></TT></TD>
  <TD VALIGN=top>matches the beginning of the target. In multiline mode
  (see <B>m//m</B>) also matches after every newline character.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$</B></TT></TD>
  <TD>matches the end of the line.
  In multiline mode also matches before every newline character.</TD></TR>

  <TR><TD VALIGN=top><TT><B>[</B></TT> ... <TT><B>]</B></TT></TD>
  <TD>denotes a class of characters to match.
  <TT><B>[^</B></TT> ... <TT><B>]</B></TT> negates the class.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(</B></TT> ... <TT><B>|</B></TT> ... <TT><B>|</B></TT> ... <TT><B>)</B></TT></TD>
  <TD>matches one of the alternatives.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(?#</B></TT> <FONT SIZE="-1">TEXT</FONT> <TT><B>)</B></TT></TD>
  <TD>Comment.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(?:</B></TT> <FONT SIZE="-1">REGEXP</FONT> <TT><B>)</B></TT></TD>
  <TD>Like <TT><B>(</B></TT><FONT SIZE="-1">REGEXP</FONT><TT><B>)</B></TT> but does not make back-references.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(?=</B></TT> <FONT SIZE="-1">REGEXP</FONT> <TT><B>)</B></TT></TD>
  <TD>Zero width positive look-ahead assertion.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(?!</B></TT> <FONT SIZE="-1">REGEXP</FONT> <TT><B>)</B></TT></TD>
  <TD>Zero width negative look-ahead assertion.</TD></TR>

  <TR><TD VALIGN=top><TT><B>(?</B></TT> <FONT SIZE="-1">MODIFIER</FONT> <TT><B>)</B></TT></TD>
  <TD>Embedded pattern-match modifier. <FONT SIZE="-1">MODIFIER</FONT> can be one or more of
  <B>i</B>, <B>m</B>, <B>s</B>, or <B>x</B>.</TD></TR>

  <TR><TD COLSPAN=2><BR>Quantified subpatterns match as many times as possible.
  When followed with a <TT><B>?</B></TT> they match the minimum number of times.
  These are the quantifiers:<BR><BR></TD></TR>

  <TR><TD VALIGN=top><TT><B>+</B></TT></TD>
  <TD>matches the preceding pattern element one or more times.</TD></TR>

  <TR><TD VALIGN=top><TT><B>?</B></TT></TD>
  <TD>matches zero or one times.</TD></TR>

  <TR><TD VALIGN=top><TT><B>*</B></TT></TD>
  <TD>matches zero or more times.</TD></TR>

  <TR><TD VALIGN=top><TT><B>{</B></TT><FONT SIZE="-1">N</FONT><TT><B>,</B></TT><FONT SIZE="-1">M</FONT><TT><B>}</B></TT></TD>
  <TD>denotes the minimum <FONT SIZE="-1">N</FONT> and maximum <FONT SIZE="-1">M</FONT> match count.
  <TT><B>{</B></TT><FONT SIZE="-1">N</FONT><TT><B>}</B></TT> means exactly <FONT SIZE="-1">N</FONT> times;
  <TT><B>{</B></TT><FONT SIZE="-1">N</FONT><TT><B>,</B></TT><TT><B>}</B></TT> means at least <FONT SIZE="-1">N</FONT> times.</TD></TR>

  <TR><TD COLSPAN=2><BR>A <TT><B>\</B></TT> escapes any special meaning
  of the following character if non-alphanumeric, but it turns most alphanumeric characters
  into something special:<BR><BR></TD></TR>

  <TR><TD VALIGN=top><TT><B>\w</B></TT></TD>
  <TD>matches alphanumeric, including <TT><B>_</B></TT>,
  <TT><B>\W</B></TT> matches non-alphanumeric.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\s</B></TT></TD>
  <TD>matches whitespace, <TT><B>\S</B></TT> matches non-whitespace.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\d</B></TT></TD>
  <TD>matches numeric, <TT><B>\D</B></TT> matches non-numeric.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\A</B></TT></TD>
  <TD>matches the beginning of the string, <TT><B>\Z</B></TT> matches the end.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\b</B></TT></TD>
  <TD>matches word boundaries, <TT><B>\B</B></TT> matches non-boundaries.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\G</B></TT></TD>
  <TD>matches where the previous <B>m//g</B> search left off.</TD></TR>

  <TR><TD><TT><B>\n</B></TT>, <TT><B>\r</B></TT>, <TT><B>\f</B></TT>, <TT><B>\t</B></TT></TD>
  <TD>etc. have their usual meaning.</TD></TR>

  <TR><TD><TT><B>\w</B></TT>, <TT><B>\s</B></TT> and <TT><B>\d</B></TT></TD>
  <TD>may be used within character classes,
  <TT><B>\b</B></TT> denotes backspace in this context.</TD></TR>

  <TR><TD COLSPAN=2><BR>Back-references:<BR><BR></TD></TR>

  <TR><TD VALIGN=top><TT><B>\1</B></TT> ... <TT><B>\9</B></TT></TD>
  <TD>refer to matched subexpressions, grouped with <TT><B>()</B></TT>,
  inside the match.</TD></TR>

  <TR><TD VALIGN=top><TT><B>\10</B></TT></TD>
  <TD>and up can also be used if the pattern matches that many subexpressions.</TD></TR>

  </TABLE>

  <P>See also <TT><B>$1</B></TT> ... <TT><B>$9</B></TT>,<TT><B> $+</B></TT>,<TT><B> $&amp;</B></TT>,<TT><B> $`</B></TT>, and<TT><B> $' </B></TT>
  in section <A HREF="#specialvariables">Special Variables</A>.</P>

  <P>With modifier <B>x</B>, whitespace can be used in the patterns for
  readability purposes.</P>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="search"></A>
  <H2>Search and Replace Functions</H2>

  <DL>

  <DT>[ <FONT SIZE="-1">EXPR</FONT> <TT><B>=~</B></TT> ] [ <B>m</B> ] <TT><B>/</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>/</B></TT>
  [ <B>g</B> ] [ <B>i</B> ] [ <B>m</B> ] [ <B>o</B> ] [ <B>v</B> ] [ <B>x</B> ]
  <DD>Searches <FONT SIZE="-1">EXPR</FONT> (default: <TT><B>$_</B></TT>) for a pattern. If you
  prepend an <B>m</B> you can use almost any pair of delimiters
  instead of the slashes. If used in array context,
  an array is returned consisting of the subexpressions
  matched by the parentheses in the pattern, i.e., <TT><B>($1,$2,$3,</B></TT>...<TT><B>)</B></TT>.
  <BR>
  Optional modifiers: <B>g</B> matches as many times as
  possible; <B>i</B> searches in a case-insensitive manner; <B>o</B>
  interpolates variables only once. <B>m</B> treats the string
  as multiple lines; <B>s</B> treats the string as a single line; <B>x</B>
  allows for regular expression extensions.
  <BR>
  If <FONT SIZE="-1">PATTERN</FONT> is empty, the most recent pattern from a
  previous match or replacement is used.
  <BR>
  With <B>g</B> the match can be used as an iterator in scalar
  context.

  <DT><TT><B>?</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>?</B></TT>
  <DD>This is just like the <TT><B>/</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>/</B></TT> search, except that it
  matches only once between calls to the <B>reset</B> operator.

  <DT>[ <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT> <TT><B>=~</B></TT> ] <B>s</B><TT><B>/</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>/</B></TT><FONT SIZE="-1">REPLACEMENT</FONT><TT><B>/</B></TT>
  [ <B>e</B> ] [ <B>g</B> ] [ <B>i</B> ] [ <B>m</B> ] [ <B>o</B> ] [ <B>s</B> ] [ <B>x</B> ]
  <DD>Searches a string for a pattern, and if found, replaces
  that pattern with the replacement text. It returns the
  number of substitutions made, if any; if no substitutions are made, it
  returns <STRONG>false</STRONG>.
  <BR>
  Optional modifiers: <B>g</B> replaces all occurrences of the
  pattern; <B>e</B> evaluates the replacement string as a Perl
  expression; for any other modifiers, see <TT><B>/</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>/</B></TT>
  matching. Almost any delimiter may replace the
  slashes; if single quotes are used, no interpretation is
  done on the strings between the delimiters, otherwise
  the strings are interpolated as if inside double quotes.
  <BR>
  If bracketing delimiters are used, <FONT SIZE="-1">PATTERN</FONT> and
  <FONT SIZE="-1">REPLACEMENT</FONT> may have their own delimiters, e.g.,
  <TT><B>s(foo)[bar]</B></TT>. If <FONT SIZE="-1">PATTERN</FONT> is empty, the most recent pattern
  from a previous match or replacement is used.

  <DT>[ <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT> <TT><B>=~</B></TT> ] <B>tr</B><TT><B>/</B></TT><FONT SIZE="-1">SEARCHLIST</FONT><TT><B>/</B></TT><FONT SIZE="-1">REPLACEMENTLIST</FONT><TT><B>/</B></TT>
  [ <B>c</B> ] [ <B>d</B> ] [ <B>s</B> ]
  <DD>Translates all occurrences of the characters found in
  the search list with the corresponding character in
  the replacement list. It returns the number of characters
  replaced. <B>y</B> may be used instead of <B>tr</B>.
  <BR>
  Optional modifiers: <B>c</B> complements the <FONT SIZE="-1">SEARCHLIST</FONT>;
  <B>d</B> deletes all characters found in <FONT SIZE="-1">SEARCHLIST</FONT> that do
  not have a corresponding character in
  <FONT SIZE="-1">REPLACEMENTLIST</FONT>; <B>s</B> squeezes all
  sequences of characters that are translated into the same target character
  into one occurrence of this character.

  <DT><B>pos</B> <FONT SIZE="-1">SCALAR</FONT>
  <DD>Returns the position where the last <B>m//g</B> search left off
  for <FONT SIZE="-1">SCALAR</FONT>. May be assigned to.

  <DT><B>study</B> [ <TT><B>$</B></TT><FONT SIZE="-1">VAR&#134;</FONT> ]
  <DD>Study the scalar variable <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT> in anticipation of
  performing many pattern matches on its contents
  before the variable is next modified.

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="filetest"></A>
  <H2>File Test Operators</H2>

  These unary operators takes one argument, either a filename
  or a filehandle, and test the associated file to see if something
  is true about it. If the argument is omitted, they test <TT><B>$_</B></TT>
  (except for <TT><B>-t</B></TT>, which tests <TT><B>STDIN</B></TT>). If the special argument <TT><B>_</B></TT>
  (underscore) is passed, they use the information from the preceding test or <B>stat</B> call.
  <P>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top NOWRAP><TT><B>-r -w -x&nbsp;</B></TT></TD>
  <TD VALIGN=top>File is readable/writable/executable by effective uid/gid.</TD></TR>

  <TR><TD VALIGN=top NOWRAP><TT><B>-R -W -X</B></TT></TD>
  <TD VALIGN=top>File is readable/writable/executable by real uid/gid.</TD></TR>

  <TR><TD VALIGN=top NOWRAP><TT><B>-o -O</B></TT></TD>
  <TD VALIGN=top>File is owned by effective/real uid.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-e -z</B></TT></TD>
  <TD VALIGN=top>File exists/has zero size.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-s</B></TT></TD>
  <TD VALIGN=top>File exists and has non-zero size. Returns the size.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-f -d</B></TT></TD>
  <TD VALIGN=top>File is a plain file/a directory.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-l -S -p</B></TT></TD>
  <TD VALIGN=top>File is a symbolic link/a socket/a named pipe (FIFO).</TD></TR>

  <TR><TD VALIGN=top><TT><B>-b -c</B></TT></TD>
  <TD VALIGN=top>File is a block/character special file.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-u -g -k</B></TT></TD>
  <TD VALIGN=top>File has setuid/setgid/sticky bit set.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-t</B></TT></TD>
  <TD VALIGN=top>Tests if filehandle (<TT><B>STDIN</B></TT> by default) is opened to a tty.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-T -B</B></TT></TD>
  <TD VALIGN=top>File is a text/non-text (binary) file.
  <TT><B>-T</B></TT> and <TT><B>-B</B></TT> return <B>true</B> on a null file,
  or a file at EOF when testing a filehandle.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-M -A -C</B></TT></TD>
  <TD VALIGN=top>File modification / access / inode-change time.
  Measured in days. Value returned reflects the file age at
  the time the script started. See also <TT><B>$^T</B></TT> in the section
  <A HREF="#specialvariables">Special Variables</A>.</TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="fileoperations"></A>
  <H2>File Operations</H2>

  Functions operating on a list of files return the number of files successfully
  operated upon.

  <DL>

  <DT><B>chmod</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Changes the permissions of a list of files.
  The first element of the list must be the numerical mode.<A HREF="#xcchmod">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>chown</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Changes the owner and group of a list of files.
  The first two elements of the list must be the numerical uid and gid.<A HREF="#xcchown">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>truncate</B> <FONT SIZE="-1">FILE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT>
  <DD>Truncates <FONT SIZE="-1">FILE</FONT> to <FONT SIZE="-1">SIZE</FONT>.
  <FONT SIZE="-1">FILE</FONT> may be a filename or a filehandle.<A HREF="#xctruncate">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>link</B> <FONT SIZE="-1">OLDFILE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NEWFILE</FONT>
  <DD>Creates a new filename linked to the old filename.<A HREF="#xclink">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>lstat</B> <FONT SIZE="-1">FILE</FONT>
  <DD>Like <B>stat</B>, but does not traverse a final symbolic link.<A HREF="#xclstat">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>mkdir</B> <FONT SIZE="-1">DIR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">MODE</FONT>
  <DD>Creates a directory with given permissions.<A HREF="#xcmkdir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>
  Sets <TT><B>$!</B></TT> on failure.

  <DT><B>readlink</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns the value of a symbolic link.<A HREF="#xcreadlink">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>rename</B> <FONT SIZE="-1">OLDNAME</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NEWNAME</FONT>
  <DD>Changes the name of a file.<A HREF="#xcrename">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>rmdir</B> <FONT SIZE="-1">FILENAME&#134;</FONT>
  <DD>Deletes the directory if it is empty.
  Sets <TT><B>$!</B></TT> on failure.<A HREF="#xcrmdir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>stat</B> <FONT SIZE="-1">FILE</FONT>
  <DD>Returns a 13-element array
  (0:&nbsp;<TT><B>$</B></TT>dev,
  1:&nbsp;<TT><B>$</B></TT>ino,
  2:&nbsp;<TT><B>$</B></TT>mode,
  3:&nbsp;<TT><B>$</B></TT>nlink,
  4:&nbsp;<TT><B>$</B></TT>uid,
  5:&nbsp;<TT><B>$</B></TT>gid,
  6:&nbsp;<TT><B>$</B></TT>rdev,
  7:&nbsp;<TT><B>$</B></TT>size,
  8:&nbsp;<TT><B>$</B></TT>atime,
  9:&nbsp;<TT><B>$</B></TT>mtime,
  10:&nbsp;<TT><B>$</B></TT>ctime,
  11:&nbsp;<TT><B>$</B></TT>blksize,
  12:&nbsp;<TT><B>$</B></TT>blocks).
  <FONT SIZE="-1">FILE</FONT> can be a filehandle, an expression evaluating to a filename,
  or <TT><B>_</B></TT> to refer to the last file test operation or <B>stat</B> call.
  Returns a null list if the <B>stat</B> fails.<A HREF="#xcstat">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>symlink</B> <FONT SIZE="-1">OLDFILE</FONT>, <FONT SIZE="-1">NEWFILE</FONT>
  <DD>Creates a new filename symbolically linked to the old filename.<A HREF="#xcsymlink">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>unlink</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Deletes a list of files.<A HREF="#xcunlink">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>utime</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Changes the access and modification times.
  The first two elements of the list must be the numerical access and modification times.<A HREF="#xcutime">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="input"></A>
  <H2>Input / Output</H2>

  In input/output operations, <FONT SIZE="-1">FILEHANDLE</FONT> may be a
  filehandle as opened by the <B>open</B> operator, a predefined filehandle
  (e.g., <TT><B>STDOUT</B></TT>) or a scalar variable that evaluates to the name of a
  filehandle to be used.<A HREF="#xcopen">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DL>

  <DT><TT><B>&lt;</B></TT><FONT SIZE="-1">FILEHANDLE</FONT><TT><B>&gt;</B></TT>
  <DD>In scalar context, reads a single line from the file opened on <FONT SIZE="-1">FILEHANDLE</FONT>.
  In array context, reads the whole file.

  <DT><TT><B>&lt;</B></TT> <TT><B>&gt;</B></TT>
  <DD>Reads from the input stream formed by the files specified in
  <TT><B>@ARGV</B></TT>, or standard input if no arguments were supplied.

  <DT><B>binmode</B> <FONT SIZE="-1">FILEHANDLE</FONT>
  <DD>Arranges for the file opened on <FONT SIZE="-1">FILEHANDLE</FONT> to be read
  or written in <I>binary</I> mode as opposed to <I>text</I> mode (null operation on UNIX).<A HREF="#xcbinmode">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>close</B> <FONT SIZE="-1">FILEHANDLE</FONT>
  <DD>Closes the file or pipe associated with the filehandle.<A HREF="#xcclose">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>dbmclose</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT>
  <DD>Deprecated, use <B>untie</B> instead.<A HREF="#xcdbmclose">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>dbmopen</B> <TT><B>%</B></TT><FONT SIZE="-1">HASH</FONT><TT><B>,</B></TT> <FONT SIZE="-1">DBMNAME</FONT><TT><B>,</B></TT> <FONT SIZE="-1">MODE</FONT>
  <DD>Deprecated, use <B>tie</B> instead.<A HREF="#xcdbmopen">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>eof</B> <FONT SIZE="-1">FILEHANDLE</FONT>
  <DD>Returns <B>true</B> if the next read will return end of file, or
  if the file is not open.

  <DT><B>eof</B>
  <DD>Returns the EOF status for the last file read.

  <DT><B>eof</B><TT><B>()</B></TT>
  <DD>Indicates EOF on the pseudo file formed of the files
  listed on the command line.<A HREF="#xceof">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>fcntl</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FUNCTION</FONT><TT><B>,</B></TT> <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT>
  <DD>Implements the <I>fcntl</I>(2) function. This function has
  non-standard return values.<A HREF="#xcfcntl">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>fileno</B> <FONT SIZE="-1">FILEHANDLE</FONT>
  <DD>Returns the file descriptor for a given (open) file.<A HREF="#xcfileno">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>flock</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OPERATION</FONT>
  <DD>Calls <I>flock</I>(2) on the file.
  <FONT SIZE="-1">OPERATION</FONT> formed by
  adding 1 (shared),
  2 (exclusive), 4 (non-blocking), or 8 (unlock).<A HREF="#xcflock">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getc</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ]
  <DD>Yields the next character from the file, or an empty
  string on end of file. If <FONT SIZE="-1">FILEHANDLE</FONT> is omitted, reads
  from <TT><B>STDIN</B></TT>.<A HREF="#xcgetc">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>ioctl</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FUNCTION</FONT><TT><B>,</B></TT> <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT>
  <DD>Performs <I>ioctl</I>(2) on the file. This function has non-standard
  return values.<A HREF="#xcioctl">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>open</B> <FONT SIZE="-1">FILEHANDLE</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">FILENAME</FONT> ]
  <DD>Opens a file and associates it with <FONT SIZE="-1">FILEHANDLE</FONT>. If
  <FONT SIZE="-1">FILENAME</FONT> is omitted, the scalar variable of the same
  name as the <FONT SIZE="-1">FILEHANDLE</FONT> must contain the filename.<A HREF="#xcopen">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>
  <BR>
  The following filename conventions apply when
  opening a file.
  <BR>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD><TT><B>"</B></TT><FONT SIZE="-1">FILE</FONT><TT><B>"</B></TT></TD>
  <TD>open <FONT SIZE="-1">FILE</FONT> for input.
  Also <TT><B>"&lt;</B></TT><FONT SIZE="-1">FILE</FONT><TT><B>"</B></TT>.</TD></TR>

  <TR><TD><TT><B>"&gt;</B></TT><FONT SIZE="-1">FILE</FONT><TT><B>"</B></TT></TD>
  <TD>open <FONT SIZE="-1">FILE</FONT> for output, creating it if necessary.</TD></TR>

  <TR><TD><TT><B>"&gt;&gt;</B></TT><FONT SIZE="-1">FILE</FONT><TT><B>"</B></TT></TD>
  <TD>open <FONT SIZE="-1">FILE</FONT> in append mode.</TD></TR>

  <TR><TD><TT><B>"+&gt;</B></TT><FONT SIZE="-1">FILE</FONT><TT><B>"</B></TT></TD>
  <TD>open <FONT SIZE="-1">FILE</FONT> with read/write access.</TD></TR>

  <TR><TD><TT><B>"|</B></TT><FONT SIZE="-1">CMD</FONT><TT><B>"</B></TT></TD>
  <TD>opens a pipe to command <FONT SIZE="-1">CMD</FONT>;
  forks if <FONT SIZE="-1">CMD</FONT> is <TT><B>-</B></TT>.</TD></TR>

  <TR><TD><TT><B>"</B></TT><FONT SIZE="-1">CMD</FONT><TT><B>|"</B></TT></TD>
  <TD>opens a pipe from command <FONT SIZE="-1">CMD</FONT>;
  forks if <FONT SIZE="-1">CMD</FONT> is <TT><B>-</B></TT>.</TD></TR>

  </TABLE>

  <FONT SIZE="-1">FILE</FONT> may be <TT><B>&amp;</B></TT><FONT SIZE="-1">FILEHND</FONT>
  in which case the new filehandle is connected to the (previously opened)
  filehandle <FONT SIZE="-1">FILEHND</FONT>.
  If it is <TT><B>&amp;=</B></TT><FONT SIZE="-1">N</FONT>, <FONT SIZE="-1">FILE</FONT> will be connected to the given file descriptor.
  <B>open</B> returns <B>undef</B> upon failure, <B>true</B> otherwise.

  <DT><B>pipe</B> <FONT SIZE="-1">READHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">WRITEHANDLE</FONT><TT><B>)</B></TT>
  <DD>Returns a pair of connected pipes.<A HREF="#xcpipe">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>print</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ] [ <FONT SIZE="-1">LIST&#134;</FONT> ]
  <DD>Equivalent to <B>print</B> <FONT SIZE="-1">FILEHANDLE</FONT> <B>sprintf</B> <FONT SIZE="-1">LIST</FONT>.<A HREF="#xcprint">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>printf</B>[<TT><B>(</B></TT>[<FONT SIZE="-1">FILEHANDLE</FONT>] <FONT SIZE="-1">LIST&#134;</FONT><TT><B>)</B></TT>*]
  <DD>Equivalent to <B>print</B> <FONT SIZE="-1">FILEHANDLE</FONT>
  <B>sprintf</B><TT><B>(</B></TT><FONT SIZE="-1">LIST</FONT><TT><B>)</B></TT>.<A HREF="#xcprintf">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>read</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LENGTH</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> ]
  <DD>Reads <FONT SIZE="-1">LENGTH</FONT> binary bytes from the file into the
  variable at <FONT SIZE="-1">OFFSET</FONT>. Returns number of bytes actually read.<A HREF="#xcread">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>seek</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">POSITION</FONT><TT><B>,</B></TT> <FONT SIZE="-1">WHENCE</FONT>
  <DD>Arbitarily positions the file.
  Returns <B>true</B> if successful.<A HREF="#xcseek">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>select</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ]
  <DD>Returns the currently selected filehandle. Sets the
  current default filehandle for output operations if
  <FONT SIZE="-1">FILEHANDLE</FONT> is supplied.<A HREF="#xcselect">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>select</B> <FONT SIZE="-1">RBITS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">WBITS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NBITS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">TIMEOUT</FONT>
  <DD>Performs a <I>select</I>(2) system call with the same
  parameters.

  <DT><B>sprintf</B> <FONT SIZE="-1">FORMAT</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Returns a string formatted by (almost all of) the
  usual <I>printf</I>(3) conventions.<A HREF="#xcsprintf">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>sysread</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LENGTH</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> ]
  <DD>Reads <FONT SIZE="-1">LENGTH</FONT> bytes into
  <TT><B>$</B></TT><FONT SIZE="-1">VAR</FONT> at <FONT SIZE="-1">OFFSET</FONT>.<A HREF="#xcsysread">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>syswrite</B> <FONT SIZE="-1">FILEHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SCALAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LENGTH</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">OFFSET</FONT> ]
  <DD>Writes <FONT SIZE="-1">LENGTH</FONT> bytes from <FONT SIZE="-1">SCALAR</FONT> at <FONT SIZE="-1">OFFSET</FONT>.<A HREF="#xcsyswrite">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>tell</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ]
  <DD>Returns the current file position for the file.
  If <FONT SIZE="-1">FILENAME</FONT> is omitted, assumes the file last read.<A HREF="#xctell">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>write</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ]
  <DD>Writes a formatted record to the specified file, using the format associated
  with that file.<A HREF="#xcwrite">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="formats"></A>
  <H2>Formats</H2>

  <DL>

  <DT><B>formline</B> <FONT SIZE="-1">PICTURE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LIST</FONT>
  <DD>Formats <FONT SIZE="-1">LIST</FONT> according to <FONT SIZE="-1">PICTURE</FONT>
  and accumulates the result into <TT><B>$^A</B></TT>.<A HREF="#xcformline">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>write</B> [ <FONT SIZE="-1">FILEHANDLE</FONT> ]
  <DD>Writes a formatted record to the specified file, using the format associated
  with that file.<A HREF="#xcwrite">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <P>Formats are defined as follows:</P>

  <UL>
  <B>format</B> [<FONT SIZE="-1">NAME</FONT>] <TT><B>=</B></TT><BR>
  <FONT SIZE="-1">FORMLIST</FONT><BR>
  <TT><B>.</B></TT>
  </UL>

  <P><FONT SIZE="-1">FORMLIST</FONT> pictures the lines, and contains the arguments which will
  give values to the fields in the lines. <FONT SIZE="-1">NAME</FONT> defaults to
  <TT><B>STDOUT</TT></B> if omitted.</P>

  <P>Picture fields are:</P>

  <UL>
  <TABLE CELLSPACING=0 CELLPADDING=0>
  <TR>
  <TD><TT><B>@&lt;&lt;&lt;</B></TT>...</TD>
  <TD>left adjusted field, repeat the <TT><B>&lt;</B></TT> to denote the desired width</TD>
  </TR>

  <TR>
  <TD><TT><B>@&gt;&gt;&gt;</B></TT>...</TD>
  <TD>right adjusted field</TD>
  </TR>

  <TR>
  <TD><TT><B>@|||</B></TT>...</TD>
  <TD>centered field</TD>
  </TR>

  <TR>
  <TD><TT><B>@#.##</B></TT>...&nbsp;&nbsp;&nbsp;</TD>
  <TD>numeric format with implied decimal point</TD>
  </TR>

  <TR>
  <TD><TT><B>@*</B></TT></TD>
  <TD>a multi-line field</TD>
  </TR>
  </TABLE>
  </UL>

  Use <TT><B>^</B></TT> instead of <TT><B>@</B></TT> for multiline block filling.<BR>
  Use <TT><B>~</B></TT> at the beginning of a line to suppress unwanted empty lines.<BR>
  Use <TT><B>~~</B></TT> at the beginning of a line to have this format line repeated until
  all fields are exhausted.<BR>
  Use <TT><B>$-</B></TT> to zero to force a page break on the next <B>write</B>.<BR>
  See also <TT><B>$^</B></TT>, <TT><B>$~</B></TT>, <TT><B>$^A</B></TT>, <TT><B>$^F</B></TT>,
  <TT><B>$-</B></TT> and <TT><B>$=</B></TT> in section
  <A HREF="#specialvariables">Special Variables</A>.

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="directory"></A>
  <H2>Directory Reading Routines</H2>

  <DL>

  <DT><B>closedir</B> <FONT SIZE="-1">DIRHANDLE</FONT>
  <DD>Closes a directory opened by <B>opendir</B>.<A HREF="#xcclosedir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>opendir</B> <FONT SIZE="-1">DIRHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">DIRNAME</FONT>
  <DD>Opens a directory on the handle specified.<A HREF="#xcopendir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>readdir</B> <FONT SIZE="-1">DIRHANDLE</FONT>
  <DD>Returns the next entry (or an array of entries) from the directory.<A HREF="#xcreaddir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>rewinddir</B> <FONT SIZE="-1">DIRHANDLE</FONT>
  <DD>Positions the directory to the beginning.<A HREF="#xcrewinddir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>seekdir</B> <FONT SIZE="-1">DIRHANDLE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">POS</FONT>
  <DD>Sets position for <B>readdir</B> on the directory.<A HREF="#xcseekdir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>telldir</B> <FONT SIZE="-1">DIRHANDLE</FONT>
  <DD>Returns the position in the directory.

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="systeminteraction"></A>
  <H2>System Interaction</H2>

  <DL>

  <DT><B>alarm</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Schedules a <TT><B>SIGALRM</B></TT> to be delivered
  after <FONT SIZE="-1">EXPR</FONT> seconds.<A HREF="#xalarm">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>chdir</B> [ <FONT SIZE="-1">EXPR</FONT> ]
  <DD>Changes the working directory.
  Uses <TT><B>$ENV{"HOME"}</TT></B> or <TT><B>$ENV{"LOGNAME"}</TT></B> if <FONT SIZE="-1">EXPR</FONT> is omitted.<A HREF="#xcchdir">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>chroot</B> <FONT SIZE="-1">FILENAME&#134;</FONT>
  <DD>Changes the root directory for the process and its children.<A HREF="#xcchroot">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>die</B> [ <FONT SIZE="-1">LIST</FONT> ]
  <DD>Prints the value of <FONT SIZE="-1">LIST</FONT> to <TT><B>STDERR</B></TT>
  and exits with the current value of <TT><B>$!</B></TT> (errno).
  If <TT><B>$!</B></TT> is 0, exits with the value of <TT><B>($? &gt;&gt; 8)</B></TT>.
  If <TT><B>($? &gt;&gt; 8)</B></TT> is 0, exits with 255.
  <FONT SIZE="-1">LIST</FONT> defaults to "<TT><B>Died</B></TT>".<A HREF="#xcdie">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>exec</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Executes the system command in <FONT SIZE="-1">LIST</FONT>; does not return.<A HREF="#xcexec">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>exit</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Exits immediately with the value of <FONT SIZE="-1">EXPR</FONT>,
  which defaults to <TT><B>0</TT></B> (zero).
  Calls <TT><B>END</TT></B> routines and object destructors before exiting.<A HREF="#xcexit">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>fork</B>
  <DD>Does a <I>fork</I>(2) system call.
  Returns the process ID of the child to the parent process and zero to the child process.<A HREF="#xcfork">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getlogin</B>
  <DD>Returns the current login name as known by the system.<A HREF="#xcgetlogin">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getpgrp</B> [ <FONT SIZE="-1">PID</FONT> ]
  <DD>Returns the process group for process <FONT SIZE="-1">PID</FONT>
  (0, or omitted, means the current process).<A HREF="#xcgetpgrp">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getppid</B>
  <DD>Returns the process ID of the parent process.<A HREF="#xcgetppid">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getpriority</B> <FONT SIZE="-1">WHICH</FONT><TT><B>,</B></TT> <FONT SIZE="-1">WHO</FONT>
  <DD>Returns the current priority for a process, process group, or user.<A HREF="#xcgetpriority">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>glob</B> <FONT SIZE="-1">PAT</FONT>
  <DD>Returns a list of filenames that match the shell pattern <FONT SIZE="-1">PAT</FONT>.<A HREF="#xcglob">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>kill</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Sends a signal to a list of processes.
  The first element of the list must be the signal to send
  (either numeric, or its name as a string).<A HREF="#xckill">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>setpgrp</B> <FONT SIZE="-1">PID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PGRP</FONT>
  <DD>Sets the process group for the <FONT SIZE="-1">PID</FONT> (0 means the current process).<A HREF="#xcsetpgrp">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>setpriority</B> <FONT SIZE="-1">WHICH</FONT><TT><B>,</B></TT> <FONT SIZE="-1">WHO</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PRIORITY</FONT>
  <DD>Sets the current priority for a process, process group, or a user.<A HREF="#xcsetpriority">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>sleep</B> [ <FONT SIZE="-1">EXPR</FONT> ]
  <DD>Causes the program to sleep for <FONT SIZE="-1">EXPR</FONT> seconds,
  or forever if no <FONT SIZE="-1">EXPR</FONT>.
  Returns the number of seconds actually slept.<A HREF="#xcsleep">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>syscall</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Calls the system call specified in the first element of the list, passing the
  rest of the list as arguments to the call.<A HREF="#xcsyscall">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>system</B> <FONT SIZE="-1">LIST</FONT>
  <DD>Does exactly the same thing as <B>exec</B> <FONT SIZE="-1">LIST</FONT>
  except that a fork is performed first,
  and the parent process waits for the child process to complete.<A HREF="#xcsystem">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>times</B>
  <DD>Returns a 4-element array
  (0:&nbsp;<TT><B>$</B></TT>user,
  1:&nbsp;<TT><B>$</B></TT>system,
  2:&nbsp;<TT><B>$</B></TT>cursor,
  3:&nbsp;<TT><B>$</B></TT>csystem)
  giving the user and system times, in seconds, for this process
  and the children of this process.<A HREF="#xctimes">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>umask</B> [ <FONT SIZE="-1">EXPR</FONT> ]
  <DD>Sets the umask for the process and returns the old one.
  If <FONT SIZE="-1">EXPR</FONT> is omitted, returns current umask value.<A HREF="#xcumask">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>wait</B>
  <DD>Waits for a child process to terminate and returns the process ID of the
  deceased process (-1 if none). The status is returned in <TT><B>$?</B></TT>.<A HREF="#xcwait">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>waitpid</B> <FONT SIZE="-1">PID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Performs the same function as the corresponding system call.<A HREF="#xcwaitpid">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>warn</B> [ <FONT SIZE="-1">LIST</FONT> ]
  <DD>Prints the message on <TT><B>STDERR</B></TT> like <B>die</B>, but doesn't exit.
  <FONT SIZE="-1">LIST</FONT> defaults to "<TT><B>Warning: something's wrong</TT></B>".<A HREF="#xcwarn">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="networking"></A>
  <H2>Networking</H2>

  <DL>

  <DT><B>accept</B> <FONT SIZE="-1">NEWSOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">GENERICSOCKET</FONT>
  <DD>Accepts a new socket.<A HREF="#xaccept">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>bind</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NAME</FONT>
  <DD>Binds the <FONT SIZE="-1">NAME</FONT> to the <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcbind">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>connect</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NAME</FONT>
  <DD>Connects the <FONT SIZE="-1">NAME</FONT> to the <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcconnect">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getpeername</B> <FONT SIZE="-1">SOCKET</FONT>
  <DD>Returns the socket address of the other end of the <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcgetpeername">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getsockname</B> <FONT SIZE="-1">SOCKET</FONT>
  <DD>Returns the name of the <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcgetsockname">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>getsockopt</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LEVEL</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OPTNAME</FONT>
  <DD>Returns the socket options.<A HREF="#xcgetsockopt">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>listen</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">QUEUESIZE</FONT>
  <DD>Starts listening on the specified <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xclisten">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>recv</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SCALAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LENGTH</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Receives a message on <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcrecv">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>send</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">MSG</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT> [ <TT><B>,</B></TT> <FONT SIZE="-1">TO</FONT> ]
  <DD>Sends a message on the <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcsend">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>setsockopt</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">LEVEL</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OPTNAME</FONT><TT><B>,</B></TT> <FONT SIZE="-1">OPTVAL</FONT>
  <DD>Sets the requested socket option.<A HREF="#xcsetsockopt">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shutdown</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">HOW</FONT>
  <DD>Shuts down a <FONT SIZE="-1">SOCKET</FONT>.<A HREF="#xcshutdown">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>socket</B> <FONT SIZE="-1">SOCKET</FONT><TT><B>,</B></TT> <FONT SIZE="-1">DOMAIN</FONT><TT><B>,</B></TT> <FONT SIZE="-1">TYPE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PROTOCOL</FONT>
  <DD>Creates a <FONT SIZE="-1">SOCKET</FONT> in <FONT SIZE="-1">DOMAIN</FONT> with <FONT SIZE="-1">TYPE</FONT> and <FONT SIZE="-1">PROTOCOL</FONT>.<A HREF="#xcsocket">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>socketpair</B> <FONT SIZE="-1">SOCKET1</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SOCKET2</FONT><TT><B>,</B></TT> <FONT SIZE="-1">DOMAIN</FONT><TT><B>,</B></TT> <FONT SIZE="-1">TYPE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PROTOCOL</FONT>
  <DD>Works the same as <B>socket</B>, but creates a pair of bidirectional sockets.<A HREF="#xcsocketpair">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="systemv"></A>
  <H2>System V IPC</H2>

  <P>You need to<TT><B> require "sys/ipc.ph" </TT></B>before you can use the
  symbolic names of the operations.</P>

  <DL>

  <DT><B>msgctl</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">CMD</FONT><TT><B>,</B></TT> <FONT SIZE="-1">ARGS</FONT>
  <DD>Calls <I>msgctl</I>(2). If <FONT SIZE="-1">CMD</FONT> is <TT><B>&amp;IPC_STAT</TT></B> then <FONT SIZE="-1">ARGS</FONT> must
  be a variable.<A HREF="#xcmsgctl">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>msgget</B> <FONT SIZE="-1">KEY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Creates a message queue for <FONT SIZE="-1">KEY</FONT>.
  Returns the message queue identifier.<A HREF="#xcmsgget">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>msgsnd</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">MSG</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Sends <FONT SIZE="-1">MSG</FONT> to queue <FONT SIZE="-1">ID</FONT>.<A HREF="#xcmsgsnd">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>msgrcv</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <TT><B>$</TT></B><FONT SIZE="-1">VAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">TYPE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Receives a message from queue <FONT SIZE="-1">ID</FONT> into <FONT SIZE="-1">VAR</FONT>.<A HREF="#xcmsgrcv">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>semctl</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SEMNUM</FONT><TT><B>,</B></TT> <FONT SIZE="-1">CMD</FONT><TT><B>,</B></TT> <FONT SIZE="-1">ARG</FONT>
  <DD>Calls <I>semctl</I>(2).
  If <FONT SIZE="-1">CMD</FONT> is <TT><B>&amp;IPC_STAT</TT></B> of <TT><B>&amp;GETALL</TT></B>
  then <FONT SIZE="-1">ARG</FONT> must be a variable.<A HREF="#xcsemctl">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>semget</B> <FONT SIZE="-1">KEY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">NSEMS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Creates a set of semaphores for <FONT SIZE="-1">KEY</FONT>.
  Returns the message semaphore identifier.<A HREF="#xcsemget">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>semop</B> <FONT SIZE="-1">KEY</FONT><TT><B>,</B></TT> ...
  <DD>Performs semaphore operations.<A HREF="#xcsemop">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shmctl</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">CMD</FONT><TT><B>,</B></TT> <FONT SIZE="-1">ARG</FONT>
  <DD>Calls <I>shmctl</I>(2).
  If <FONT SIZE="-1">CMD</FONT> is <TT><B>&amp;IPC_STAT</TT></B>
  then <FONT SIZE="-1">ARG</FONT> must be a variable.<A HREF="#xcshmctl">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shmget</B> <FONT SIZE="-1">KEY</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT><TT><B>,</B></TT> <FONT SIZE="-1">FLAGS</FONT>
  <DD>Creates shared memory.
  Returns the shared memory segment identifier.<A HREF="#xcshmget">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shmread</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <TT><B>$</TT></B><FONT SIZE="-1">VAR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">POS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT>
  <DD>Reads at most <FONT SIZE="-1">SIZE</FONT> bytes of the contents of shared
  memory segment <FONT SIZE="-1">ID</FONT> starting at offset <FONT SIZE="-1">POS</FONT> into <FONT SIZE="-1">VAR</FONT>.<A HREF="#xcshmread">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>shmwrite</B> <FONT SIZE="-1">ID</FONT><TT><B>,</B></TT> <FONT SIZE="-1">STRING</FONT><TT><B>,</B></TT> <FONT SIZE="-1">POS</FONT><TT><B>,</B></TT> <FONT SIZE="-1">SIZE</FONT>
  <DD>Writes at most <FONT SIZE="-1">SIZE</FONT> bytes of <FONT SIZE="-1">STRING</FONT> into the contents of
  shared memory segment <FONT SIZE="-1">ID</FONT> at offset <FONT SIZE="-1">POS</FONT>.<A HREF="#xcshmwrite">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="miscellaneous"></A>
  <H2>Miscellaneous</H2>

  <DL>

  <DT><B>defined</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Tests whether the lvalue <FONT SIZE="-1">EXPR</FONT> has an actual value.<A HREF="#xcdefined">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>do</B> <FONT SIZE="-1">FILENAME</FONT>
  <DD>Executes <FONT SIZE="-1">FILENAME</FONT> as a Perl script.
  See also <B>require</B> in the section
  <A HREF="#subroutines">Subroutines, Packages and Modules</A>.<A HREF="#xcdo">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>dump</B> [ <FONT SIZE="-1">LABEL</FONT> ]
  <DD>Immediate core dump.
  When reincarnated, starts at <FONT SIZE="-1">LABEL</FONT>.<A HREF="#xcdump">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>eval</B> <TT><B>{</TT></B> <FONT SIZE="-1">EXPR</FONT> <TT><B>;</TT></B> ... <TT><B>}</TT></B>
  <DD>Executes the code between <TT><B>{</TT></B> and <TT><B>}</TT></B>.
  Traps runtime errors as described
  with <B>eval</B><TT><B>(</TT></B><FONT SIZE="-1">EXPR</FONT><TT><B>)</TT></B>, in the section <A HREF="#string">String Functions</A>.<A HREF="#xceval">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>local</B> <FONT SIZE="-1">VARIABLE</FONT>
  <DT><B>local</B> <TT><B>(</TT></B> <FONT SIZE="-1">LIST</FONT> <TT><B>)</TT></B>
  <DD>Creates a scope for the listed variables local to the enclosing block,
  subroutine or <B>eval</B>.<A HREF="#xclocal">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>my</B> <FONT SIZE="-1">VARIABLE</FONT>
  <DT><B>my</B> <TT><B>(</TT></B> <FONT SIZE="-1">LIST</FONT> <TT><B>)</TT></B>
  <DD>Creates a scope for the listed variables lexically local to the enclosing block,
  subroutine or <B>eval</B>.<A HREF="#xcmy">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>ref</B> <FONT SIZE="-1">EXPR&#134;</FONT>
  <DD>Returns a <B>true</B> value if <FONT SIZE="-1">EXPR</FONT> is a reference.
  Returns the package name if <FONT SIZE="-1">EXPR</FONT> has been blessed into a package.<A HREF="#xcbless">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>reset</B> [ <FONT SIZE="-1">EXPR</FONT> ]
  <DD>Resets <TT><B>??</B></TT> searches so that they work again.
  <FONT SIZE="-1">EXPR</FONT> is a list of single letters. All variables and arrays
  beginning with one of those letters are reset
  to their pristine state. Only affects the current package.<A HREF="#xcreset">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>scalar</B> <FONT SIZE="-1">EXPR</FONT>
  <DD>Forces evaluation of <FONT SIZE="-1">EXPR</FONT> in scalar context.<A HREF="#xcscalar">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>undef</B> [ <FONT SIZE="-1">LVALUE</FONT> ]
  <DD>Undefines the <FONT SIZE="-1">LVALUE</FONT>. Always returns the undefined value.<A HREF="#xcundef">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  <DT><B>wantarray</B>
  <DD>Returns <B>true</B> if the current context expects an array value.<A HREF="#xcwantarray">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>

  </DL>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="information"></A>
  <H2>Information from System Files</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>passwd</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>passwd,
  <TT><B>$</B></TT>uid, <TT><B>$</B></TT>gid, <TT><B>$</B></TT>quota,
  <TT><B>$</B></TT>comment, <TT><B>$</B></TT>gcos, <TT><B>$</B></TT>dir,
  <TT><B>$</B></TT>shell<TT><B>)</TT></B>.</TD>
  </TR>

  <TR>
  <TD><B>endpwent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendpwent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getpwend</B></TD>
  <TD>Gets next user information.<A HREF="#xcgetpwend">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>
  </TD></TR>

  <TR>
  <TD><B>getpwnam</B> <FONT SIZE="-1">NAME</FONT></TD>
  <TD>Gets information by name.<A HREF="#xcgetpwnam">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A>
  </TD></TR>

  <TR>
  <TD><B>getpwuid</B> <FONT SIZE="-1">UID</FONT></TD>
  <TD>Gets information by user ID.<A HREF="#xcgetpwuid">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>setpwent</B></TD>
  <TD>Resets lookup processing.<A HREF="#xcsetpwent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>group</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>passwd,
  <TT><B>$</B></TT>gid, <TT><B>$</B></TT>members<TT><B>)</TT></B>.</TD>
  </TR>

  <TR>
  <TD><B>endgrent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendgrent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getgrgid</B> <FONT SIZE="-1">GID</FONT></TD>
  <TD>Gets information by group ID.<A HREF="#xcgetgrgid">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getgrnam</B> <FONT SIZE="-1">NAME</FONT></TD>
  <TD>Gets information by name.<A HREF="#xcgetgrnam">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getgrent</B></TD>
  <TD>Gets next information.<A HREF="#xcgetgrent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>setgrent</B></TD>
  <TD>Resets lookup processing.<A HREF="#xcsetgrent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>hosts</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>aliases,
  <TT><B>$</B></TT>addrtype, <TT><B>$</B></TT>length, <TT><B>@</B></TT>addrs<TT><B>)</TT></B>.
  </TR>

  <TR>
  <TD><B>endhostent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendhostent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>gethostbyaddr</B> <FONT SIZE="-1">ADDR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">ADDRTYPE</FONT></TD>
  <TD>Gets information by IP address.<A HREF="#xcgethostbyaddr">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>gethostbyname</B> <FONT SIZE="-1">NAME</FONT></TD>
  <TD>Gets information by hostname.<A HREF="#xcgethostbyname">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>gethostent</B></TD>
  <TD>Gets next host information.<A HREF="#xcgethostent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>sethostent</B> <FONT SIZE="-1">STAYOPEN</FONT></TD>
  <TD>Resets lookup processing.<A HREF="#xcsethostent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>networks</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>aliases,
  <TT><B>$</B></TT>addrtype, <TT><B>$</B></TT>net<TT><B>)</TT></B>.
  </TR>

  <TR>
  <TD><B>endnetent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendnetent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getnetbyaddr</B> <FONT SIZE="-1">ADDR</FONT><TT><B>,</B></TT> <FONT SIZE="-1">TYPE</FONT></TD>
  <TD>Gets information by address and type.<A HREF="#xcgetnetbyaddr">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getnetbyname</B> <FONT SIZE="-1">NAME</FONT></TD>
  <TD>Gets information by network name.<A HREF="#xcgetnetbyname">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getnetent</B></TD>
  <TD>Gets next network information.<A HREF="#xcgetnetent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>setnetent</B> <FONT SIZE="-1">STAYOPEN</FONT></TD>
  <TD>Resets lookup processing.<A HREF="#xcsetnetent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>services</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>aliases,
  <TT><B>$</B></TT>port, <TT><B>$</B></TT>proto<TT><B>)</TT></B>.
  </TR>

  <TR>
  <TD><B>endservent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendservent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getservbyname</B> <FONT SIZE="-1">NAME</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PROTO</FONT></TD>
  <TD>Gets information by service name.<A HREF="#xcgetservbyname">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getservbyport</B> <FONT SIZE="-1">PORT</FONT><TT><B>,</B></TT> <FONT SIZE="-1">PROTO</FONT></TD>
  <TD>Gets information by service port.<A HREF="#xcgetservbyport">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getservent</B></TD>
  <TD>Gets next service information.<A HREF="#xcgetservent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>setservent</B> <FONT SIZE="-1">STAYOPEN</FONT></TD>
  <TD>Resets lookup processing.<A HREF="#xcsetservent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>

  <TR>
  <TD COLSPAN=2><LI><FONT SIZE="+1"><B>protocols</B></FONT></TD>
  </TR>

  <TR>
  <TD COLSPAN=2>Returns <TT><B>($</B></TT>name, <TT><B>$</B></TT>aliases,
  <TT><B>$</B></TT>proto<TT><B>)</TT></B>.</TD>
  </TR>

  <TR>
  <TD><B>endprotoent</B></TD>
  <TD>Ends lookup processing.<A HREF="#xcendprotoent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getprotobyname</B> <FONT SIZE="-1">NAME</FONT></TD>
  <TD>Gets information by protocol name.<A HREF="#xcgetprotobyname">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getprotobynumber</B> <FONT SIZE="-1">NUMBER</FONT></TD>
  <TD>Gets information by protocol number.<A HREF="#xcgetprotobynumber">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>getprotoent</B></TD>
  <TD>Gets next protocol information.<A HREF="#xcgetprotoent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  <TR>
  <TD><B>setprotoent</B> <FONT SIZE="-1">STAYOPEN</FONT></TD>
  <TD>Resets lookup processing.<A HREF="#xcsetprotoent">&nbsp;&nbsp;<FONT SIZE="-1">More</FONT></A></TD>
  </TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="specialvariables"></A>
  <H2>Special Variables</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top COLSPAN=2>The following variables are global and should be
  localized in subroutines:</TD></TR>

  <TR><TD VALIGN=top><TT><B>$_</B></TT></TD>
  <TD VALIGN=top>The default input and pattern-searching space.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$.</B></TT></TD>
  <TD VALIGN=top>The current input line number of the last filehandle that was read.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$/</B></TT></TD>
  <TD VALIGN=top>The input record separator, newline by default. May be multicharacter.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$,</B></TT></TD>
  <TD VALIGN=top>The output field separator for the print operator.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$"</B></TT></TD>
  <TD VALIGN=top>The separator that joins elements of arrays interpolated in strings.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$\</B></TT></TD>
  <TD VALIGN=top>The output record separator for the print operator.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$#</B></TT></TD>
  <TD VALIGN=top>The output format for printed numbers. Deprecated.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$*</B></TT></TD>
  <TD VALIGN=top>Set to 1 to do multiline matching within strings.
  Deprecated, see the <B>m</B> and <B>s</B> modifiers in section
  <A HREF="#search">Search and Replace Functions</A>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$?</B></TT></TD>
  <TD VALIGN=top>The status returned by the last <TT><B>`</B></TT>...<TT><B>`</B></TT> command,
  pipe <B>close</B> or <B>system</B> operator.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$]</B></TT></TD>
  <TD VALIGN=top>The perl version number, e.g., <TT><B>5.001</TT></B>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$[</B></TT></TD>
  <TD VALIGN=top>The index of the first element in an array, and of the first character
  in a substring. Default is 0. Deprecated.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$;</B></TT></TD>
  <TD VALIGN=top>The subscript separator for multidimensional array emulation.
  Default is "<TT><B>\034</B></TT>".</TD></TR>

  <TR><TD VALIGN=top><TT><B>$!</B></TT></TD>
  <TD VALIGN=top>If used in a numeric context, yields the current value of <B>errno</B>.
  If used in a string context, yields the corresponding error string.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$@</B></TT></TD>
  <TD VALIGN=top>The Perl error message from the last <B>eval</B> or <B>do</B> <FONT SIZE="-1">EXPR</FONT>
  command.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$:</B></TT></TD>
  <TD VALIGN=top>The set of characters after which a string may be broken to
  fill continuation fields (starting with <TT><B>^</B></TT>) in a format.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$0</B></TT></TD>
  <TD VALIGN=top>The name of the file containing the Perl script being executed.
  May be assigned to.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$$</B></TT></TD>
  <TD VALIGN=top>The process ID of the currently executing Perl program.
  Altered (in the child process) by <B>fork</B>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$&lt;</B></TT></TD>
  <TD VALIGN=top>The real user ID of this process.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$&gt;</B></TT></TD>
  <TD VALIGN=top>The effective user ID of this process.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$(</B></TT></TD>
  <TD VALIGN=top>The real group ID of this process.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$)</B></TT></TD>
  <TD VALIGN=top>The effective group ID of this process.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^A</B></TT></TD>
  <TD VALIGN=top>The accumulator for <B>formline</B> and <B>write</B> operations.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^D</B></TT></TD>
  <TD VALIGN=top>The debug flags as passed to perl using <TT><B>-D</B></TT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^F</B></TT></TD>
  <TD VALIGN=top>The highest system file descriptor, ordinarily 2.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^I</B></TT></TD>
  <TD VALIGN=top>In-place edit extension as passed to Perl using <TT><B>-i</B></TT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^L</B></TT></TD>
  <TD VALIGN=top>Formfeed character used in formats.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^P</B></TT></TD>
  <TD VALIGN=top>Internal debugging flag.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^T</B></TT></TD>
  <TD VALIGN=top>The time (as delivered by <B>time</B>) when the program started.
  This value is used by the file test operators <TT><B>-M</B></TT>,
  <TT><B>-A</B></TT> and <TT><B>-C</B></TT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^W</B></TT></TD>
  <TD VALIGN=top>The value if the <TT><B>-w</B></TT> option as passed to Perl.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^X</B></TT></TD>
  <TD VALIGN=top>The name by which the currently executing program was invoked.</TD></TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>
  <TR><TD VALIGN=top COLSPAN=2>The following variables are context dependent
  and need not be localized:</TD></TR>

  <TR><TD VALIGN=top><TT><B>$%</B></TT></TD>
  <TD VALIGN=top>The current page number of the currently selected output channel.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$=</B></TT></TD>
  <TD VALIGN=top>The page length of the current output channel. Default is 60 lines.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$-</B></TT></TD>
  <TD VALIGN=top>The number of lines remaining on the page.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$~</B></TT></TD>
  <TD VALIGN=top>The name of the current report format.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$^</B></TT></TD>
  <TD VALIGN=top>The name of the current top-of-page format.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$|</B></TT></TD>
  <TD VALIGN=top>If set to nonzero, forces a flush after every write or print on the
  currently selected output channel. Default is 0.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$ARGV</B></TT></TD>
  <TD VALIGN=top>The name of the current file when reading from <TT><B>&lt;&gt;</B></TT>.</TD></TR>

  <TR><TD COLSPAN=2>&nbsp;</TD></TR>
  <TR><TD VALIGN=top COLSPAN=2>The following variables are always local to the
  current block:</TD></TR>

  <TR><TD VALIGN=top><TT><B>$&amp;</B></TT></TD>
  <TD VALIGN=top>The string matched by the last successful pattern match.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$`</B></TT></TD>
  <TD VALIGN=top>The string preceding what was matched by the last successful match.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$'</B></TT></TD>
  <TD VALIGN=top>The string following what was matched by the last successful match.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$+</B></TT></TD>
  <TD VALIGN=top>The last bracket matched by the last search pattern.</TD></TR>

  <TR><TD VALIGN=top><TT><B>$1</B></TT>...<TT><B>$9</B></TT>...&nbsp;&nbsp;</TD>
  <TD VALIGN=top>Contain the subpatterns from the corresponding sets of parentheses in the
  last pattern successfully matched. <TT><B>$10</B></TT>... and up are only available if the
  match contained that many subpatterns.</TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="specialarrays"></A>
  <H2>Special Arrays</H2>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top><TT><B>@ARGV</B></TT></TD>
  <TD VALIGN=top>Contains the command-line arguments for the script (not including the
  command name).</TD></TR>

  <TR><TD VALIGN=top><TT><B>@EXPORT</B></TT></TD>
  <TD VALIGN=top>Names the methods a package exports by default.</TD></TR>

  <TR><TD VALIGN=top><TT><B>@EXPORT_OK&nbsp;</B></TT></TD>
  <TD VALIGN=top>Names the methods a package can export upon explicit request.</TD></TR>

  <TR><TD VALIGN=top><TT><B>@INC</B></TT></TD>
  <TD VALIGN=top>Contains the list of places to look for Perl scripts to be evaluated by
  the <B>do</B> <FONT SIZE="-1">FILENAME</FONT> and <B>require</B> commands.</TD></TR>

  <TR><TD VALIGN=top><TT><B>@ISA</B></TT></TD>
  <TD VALIGN=top>List of base classes of a package.</TD></TR>

  <TR><TD VALIGN=top><TT><B>@_</B></TT></TD>
  <TD VALIGN=top>Parameter array for subroutines. Also used by <B>split</B>
  if not in array context.</TD></TR>

  <TR><TD VALIGN=top><TT><B>%ENV</B></TT></TD>
  <TD VALIGN=top>Contains the current environment.</TD></TR>

  <TR><TD VALIGN=top><TT><B>%INC</B></TT></TD>
  <TD VALIGN=top>List of files that have been included with <B>require</B> or <B>do</B>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>%OVERLOAD</B></TT></TD>
  <TD VALIGN=top>Can be used to overload operators in a package.</TD></TR>

  <TR><TD VALIGN=top><TT><B>%SIG</B></TT></TD>
  <TD VALIGN=top>Used to set signal handlers for various signals.</TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="environment"></A>
  <H2>Environment Variables</H2>

  <P>Perl uses the following environment variables.</P>

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top><TT><B>HOME</B></TT></TD>
  <TD VALIGN=top>Used if <B>chdir</B> has no argument.</TD></TR>

  <TR><TD VALIGN=top><TT><B>LOGDIR</B></TT></TD>
  <TD VALIGN=top>Used if <B>chdir</B> has no argument and <TT><B>HOME</TT></B> is not set.</TD></TR>

  <TR><TD VALIGN=top><TT><B>PATH</B></TT></TD>
  <TD VALIGN=top>Used in executing subprocesses, and in finding the Perl script if <TT><B>-S</TT></B>
  is used.</TD></TR>

  <TR><TD VALIGN=top><TT><B>PERL5LIB&nbsp;</B></TT></TD>
  <TD VALIGN=top>A colon-separated list of directories to look in for Perl library files
  before looking in the standard library and the current directory.</TD></TR>

  <TR><TD VALIGN=top><TT><B>PERL5DB</B></TT></TD>
  <TD VALIGN=top>The command to get the debugger code.
  <BR>Defaults to <TT><B>BEGIN { require 'perl5db.pl' }</TT></B>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>PERLLIB</B></TT></TD>
  <TD VALIGN=top>Used instead of <TT><B>PERL5LIB</TT></B> if the latter is not defined.</TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <A NAME="debugger"></A>
  <H2>The Perl Debugger</H2>

  The Perl symbolic debugger is invoked with <TT><B>perl -d</B></TT>.

  <TABLE CELLSPACING=0 CELLPADDING=0>

  <TR><TD VALIGN=top><TT><B>h</B></TT></TD>
  <TD VALIGN=top>Prints out a help message.</TD></TR>

  <TR><TD VALIGN=top><TT><B>T</B></TT></TD>
  <TD VALIGN=top>Prints a stack trace.</TD></TR>

  <TR><TD VALIGN=top><TT><B>s</B></TT></TD>
  <TD VALIGN=top>Single steps.</TD></TR>

  <TR><TD VALIGN=top><TT><B>n</B></TT></TD>
  <TD VALIGN=top>Single steps around subroutine call.</TD></TR>

  <TR><TD VALIGN=top><FONT SIZE="-1">RETURN key</FONT></TD>
  <TD VALIGN=top>Repeats last <TT><B>s</B></TT> or <TT><B>n</B></TT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>r</B></TT></TD>
  <TD VALIGN=top>Returns form the current subroutine.</TD></TR>

  <TR><TD VALIGN=top><TT><B>c</B></TT> [ <FONT SIZE="-1">LINE</FONT> ]</TD>
  <TD VALIGN=top>Continues (until <FONT SIZE="-1">LINE</FONT>,
  or another breakpoint, or exit).</TD></TR>

  <TR><TD VALIGN=top><TT><B>p</B></TT> <FONT SIZE="-1">EXPR</FONT></TD>
  <TD VALIGN=top>Prints <FONT SIZE="-1">EXPR</FONT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>l</B></TT> [ <FONT SIZE="-1">RANGE</FONT> ]</TD>
  <TD VALIGN=top>Lists a range of lines.
  <FONT SIZE="-1">RANGE</FONT> may be a number, start-end,
  start+amount, or a subroutine name. If <FONT SIZE="-1">RANGE</FONT> is omitted,
  lists next window.</TD></TR>

  <TR><TD VALIGN=top><TT><B>w</B></TT></TD>
  <TD VALIGN=top>Lists window around current line.</TD></TR>

  <TR><TD VALIGN=top><TT><B>-</B></TT></TD>
  <TD VALIGN=top>Lists previous window.</TD></TR>

  <TR><TD VALIGN=top><TT><B>f</B></TT> <FONT SIZE="-1">FILE</FONT></TD>
  <TD VALIGN=top>Switches to <FONT SIZE="-1">FILE</FONT> and starts listing it.</TD></TR>

  <TR><TD VALIGN=top><TT><B>l</B></TT> <FONT SIZE="-1">SUB</FONT></TD>
  <TD VALIGN=top>Lists the named subroutine.</TD></TR>

  <TR><TD VALIGN=top><TT><B>S</B></TT></TD>
  <TD VALIGN=top>List the names of all subroutines.</TD></TR>

  <TR><TD VALIGN=top><TT><B>/</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>/</B></TT></TD>
  <TD VALIGN=top>Searches forward for <FONT SIZE="-1">PATTERN</FONT>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>?</B></TT><FONT SIZE="-1">PATTERN</FONT><TT><B>?</B></TT></TD>
  <TD VALIGN=top>Searches backward for <FONT SIZE="-1">PATTERN</FONT>.</TD></TR>

  <TR><TD VALIGN=top NOWRAP><TT><B>b</B></TT> [ <FONT SIZE="-1">LINE</FONT> [ <FONT SIZE="-1">CONDITION</FONT> ] ]&nbsp;&nbsp;</TD>
  <TD VALIGN=top>Sets breakpoint at <FONT SIZE="-1">LINE</FONT>; default is the current line.</TD></TR>

  <TR><TD VALIGN=top><TT><B>b</B></TT> <FONT SIZE="-1">SUB</FONT> [ <FONT SIZE="-1">CONDITION</FONT> ]</TD>
  <TD VALIGN=top>Sets breakpoint at the subroutine.</TD></TR>

  <TR><TD VALIGN=top><TT><B>d</B></TT> [ <FONT SIZE="-1">LINE</FONT> ]</TD>
  <TD VALIGN=top>Deletes breakpoint at the given line.</TD></TR>

  <TR><TD VALIGN=top><TT><B>D</B></TT></TD>
  <TD VALIGN=top>Deletes all breakpoints.</TD></TR>

  <TR><TD VALIGN=top><TT><B>L</B></TT></TD>
  <TD VALIGN=top>Lists lines that have breakpoints or actions.</TD></TR>

  <TR><TD VALIGN=top><TT><B>a</B></TT> <FONT SIZE="-1">LINE COMMAND</FONT></TD>
  <TD VALIGN=top>Sets an action for line.</TD></TR>

  <TR><TD VALIGN=top><TT><B>A</B></TT></TD>
  <TD VALIGN=top>Deletes all line actions.</TD></TR>

  <TR><TD VALIGN=top><TT><B>&lt;</B></TT> <FONT SIZE="-1">COMMAND</FONT></TD>
  <TD VALIGN=top>Sets an action to be executed before every debugger prompt.</TD></TR>

  <TR><TD VALIGN=top><TT><B>&gt;</B></TT> <FONT SIZE="-1">COMMAND</FONT></TD>
  <TD VALIGN=top>Sets an action to be executed before every
  <TT><B>s</B></TT>, <TT><B>c</B></TT> or <TT><B>n</B></TT> command.</TD></TR>

  <TR><TD VALIGN=top NOWRAP><TT><B>V</B></TT> [ <FONT SIZE="-1">PACKAGE</FONT> [ <FONT SIZE="-1">VARS</FONT> ] ]&nbsp;&nbsp;</TD>
  <TD VALIGN=top>Lists all variables in a package. Default package is <TT><B>main</TT></B>.</TD></TR>

  <TR><TD VALIGN=top><TT><B>X</B></TT> [ <FONT SIZE="-1">VARS</FONT> ]</TD>
  <TD VALIGN=top>Like <TT><B>V</B></TT>, but assumes current package.</TD></TR>

  <TR><TD VALIGN=top><TT><B>!</B></TT> [ [<TT><B>-</TT></B>]<FONT SIZE="-1">NUMBER</FONT> ]</TD>
  <TD VALIGN=top>Re-executes a command. Default is the previous command.</TD></TR>

  <TR><TD VALIGN=top><TT><B>H</B></TT> [ -<FONT SIZE="-1">NUMBER</FONT> ]</TD>
  <TD VALIGN=top>Displays the last <TT><B>-</TT></B><FONT SIZE="-1">NUMBER</FONT>
  commands of more than one letter.</TD></TR>

  <TR><TD VALIGN=top><TT><B>t</B></TT></TD>
  <TD VALIGN=top>Toggles trace mode.</TD></TR>

  <TR><TD VALIGN=top><TT><B>=</B></TT> [ <FONT SIZE="-1">ALIAS VALUE</FONT> ]</TD>
  <TD VALIGN=top>Sets alias, or lists current aliases.</TD></TR>

  <TR><TD VALIGN=top><TT><B>q</B></TT></TD>
  <TD VALIGN=top>Quits. You may also use your <FONT SIZE="-1">EOF key</FONT> character.</TD></TR>

  <TR><TD VALIGN=top><FONT SIZE="-1">COMMAND</FONT></TD>
  <TD VALIGN=top>Executes <FONT SIZE="-1">COMMAND</FONT> as a Perl statement.</TD></TR>

  </TABLE>

  <H4 ALIGN=center>Back to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A></H4>

  <!-- ----------------------------------------------------------------------------- -->

  <HR NOSHADE SIZE=4>

  <HR SIZE=1>

  <CENTER>

  <HR SIZE=1>

  <ADDRESS>
  Text copyright &copy; 1996 Johan Vromans<BR>
  HTML copyright &copy; 1996-1997 Rex Swain<BR>
  Email <A HREF="mailto:rhswain@acm.org">rhswain@acm.org</A>,
  Web <A HREF="http://www.pcnet.com/~rhswain/">http://www.pcnet.com/~rhswain</A><BR>
  Permission granted to distribute unmodified copies<BR>
  Reports of errors or omissions appreciated
  </ADDRESS>
  </CENTER>

  <BR>
  <BR>
  <BR>
  <BR>


  <A NAME="xc"></A>
  <HEAD><TITLE>Perl 5 by Example, Appendix C</TITLE></HEAD><A NAME="Appendix C - Function List"><H1>XC - Function List</H1><TABLE BORDER=0 WIDTH=100% CELLPADDING=5 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=aquamarine SIZE=4><B> Chapter Index</B></FONT></TD></TR><TR><TD BGCOLOR=aquamarine><BR><UL><LI><A HREF="#Functions by Category">Functions by Category</A><LI><A HREF="#Functions by Name">Functions by Name</A></UL></TD></TR></TABLE><P></A><P>
  Quite a few of Perl's function mirror those available to C programmers under the UNIX system and are at least moderately complicated to use. Please look in the UNIX documentation for additional information if you're interested in the socket, shared memory, or semaphore functions.<P>
  <H2><A NAME="Functions by Category">Functions by Category</A></H2>
  <P>
  <B><UL><LI>Array:</B> chomp, join, keys, map, pop, push, reverse, shift, sort, splice, split, unshift, values<P>
  <LI><B>Database:</B> dbmclose, dbmopen<P>
  <LI><B>Directory:</B> chdir, closedir, mkdir, opendir, readdir, rewinddir, rmdir, seekdir, telldir<P>
  <LI><B>File:</B> binmode, chdir, chmod, chown, chroot, close, eof, fnctl, fileno, flock, getc, glob, ioctl, link, lstat, open, print, printf, read, readdir, readlink, rename, rmdir, seek, select, stat, symlink, sysopen, sysread, syswrite, tell, truncate, umask, unlink, utime, write<P>
  <LI><B>Group:</B> endgrent, getgrent, getgrgid, getgrname, getpgrp, setgrent, setpgrp<P>
  <LI><B>Hash:</B> delete, each, exists, keys, values<P>
  <LI><B>Host:</B> endhostent, gethostbyaddr, gethostbyname, sethostent<P>
  <LI><B>Input:</B> getc, read, sysread<P>
  <LI><B>Inter-process Communication:</B> msgctl, msgget, msgrcv, msgsnd, pipe, semctl, semget, semop, shmctl, shmget, shmread, shmwrite<P>
  <LI><B>Math:</B> abs, atan2, cos, exp, hex, int, log, oct, rand, sin, sqrt, srand<P>
  <LI><B>Message Queues:</B> msgctl, msgget, msgrcv, msgsnd<P>
  <LI><B>Miscellaneous:</B> bless, defined, do, eval, formline, import, ref, scalar, syscall, tie, tied, undef, untie, wantarray<P>
  <LI><B>Network:</B> endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent<P>
  <LI><B>Output:</B> die, print, printf, syswrite, warn, write<P>
  <LI><B>Password:</B> endpwent, getpwent, getpwname, getpwuid, setpwent<P>
  <LI><B>Process:</B> alarm, die, dump, exec, exit, fork, getlogin, getpgrp, getppid, getpriority, kill, setpriority, sleep, system, times, umask, wait, waitpid<P>
  <LI><B>Protocol:</B> endprotent, getprotobyname, getprotobynumber, getprotoent, getservbyname, getservbyport, getservent, setprotoent<P>
  <LI><B>Regular Expression:</B> <TT>grep</TT>, <TT>pos</TT>, <TT>quotemeta</TT>, <TT>reset</TT>, <TT>split</TT>, <TT>study</TT><P>
  <LI><B>Scope:</B> caller, local, my<P>
  <LI><B>Service:</B> endservent, getservbyname, getservbyport, getservent, setservent<P>
  <LI><B>Socket:</B> accept, bind, connect, gethostbyaddr, gethostbyname, gethostent, getpeername, getservbyname, getservbyport, getservent, getsockname, getsockopt, listen, recv, select, send, setsockopt, shutdown, socket, socketpair<P>
  <LI><B>String:</B> chop, chr, crypt, hex, index, join, lc, lcfirst, length, oct, Ord, pack, q, qq, quotemeta, qw, qx, reverse, rindex, split, sprintf, substr, uc, ucfirst, unpack, vec<P>
  <LI><B>Time:</B> gmtime, localtime, time<P>
  <LI><B>UNIX:</B> chmod, chown, chroot, dump, endgrent, endhostent, endnetent, endprotent, endpwent, endservent, fnctl, fork, getgrent, getgrgid, getgrname, gethostent, getlogin, getnetent, getpgrp, getppid, getpriority, getprotobyname, getprotobynumber, getprotoent, getpwent, getpwname, getpwuid, getservbyname, getservbyport, getservent, ioctl, link, lstat, readlink, select, setgrent, sethostent, setnetent, setpgrp, setpriority, setprotoent, setpwent, setservent, sleep, syscall, times, umask, wait, waitpid</UL><P>
  <H2><A NAME="Functions by Name">Functions by Name</A></H2>
  <P>
  </TABLE>

  <A NAME="xcabs"></A>
  <H3><A NAME="abs( [EXPR] )">abs( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math</TD></TR>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	scalar, the absolute value of <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified. </TD></TR>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Calculates an absolute value. For example, <TT>abs(-10)</TT> is 10. </TD></TR>
  </TABLE>
  <A NAME="xaccept"></A>
  <H3><A NAME="accept ( NEWSOCKET, GENERICSOCKET )">accept ( NEWSOCKET, GENERICSOCKET )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the packed address of the client or false if a problem occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Accepts a socket connection from clients waiting for a connection. The <TT>GENERICSOCKET</TT> parameter must have already been opened using the <TT>socket()</TT> function. You can find more information about <TT>accept()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xalarm"></A>
  <H3><A NAME="alarm ( NUM_OF_SECONDS )">alarm ( NUM_OF_SECONDS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of seconds remaining before the previous alarm was due to go off.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sends a SIGALARM to your script after <TT>NUM_OF_SECONDS</TT>. A call with <TT>NUM_OF_SECONDS</TT> equal to zero cancels the current alarm. You can find more information about <TT>alarm()</TT> in section 3 of the UNIX manual pages. It is possible for Perl to trap such signals and call specific signal handling subroutines. See Chapter 13, "<A HREF="ch13.htm">Handling Errors and Signals</A>." <P>
  <FONT COLOR=Blue SIZE=2><PRE>alarm(10);</PRE></FONT>
  </TABLE>
  <A NAME="xcatan2"></A>
  <H3><A NAME="atan2 ( [EXPR] )">atan2 ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the arc tangent of <TT>EXPR</TT> or of $_ if no expression is specified..<P>
  <TR><TD VALIGN=top>Definition:</TD><TD> 	Calculates an arc tangent.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$arcTangent = atan2(60,2);</PRE></FONT>
  </TABLE>
  <A NAME="xcbind"></A>
  <H3><A NAME="bind ( SOCKET, NAME )">bind ( SOCKET, NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the socket handle or false if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Binds a network address to the socket handle. You can find more information about <TT>bind()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xcbinmode"></A>
  <H3><A NAME="binmode ( FILEHANDLE )">binmode ( FILEHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or undefined if not<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	On systems which distinguish between text and binary files (like Windows 95 and Windows NT) this function forces binary mode treatment of <TT>FILEHANDLE</TT>. In systems which do make the distinction, text files have the end of line characters-carriage return ('\r') and linefeed('\n')-automatically translated into the UNIX end-of-line character ('\n') when reading from the file and when when writing to the file. Binary mode files do not have this automatic transformation. See "<A HREF="ch09.htm#Example: Binary Files">Example: Binary Files</A>"  in Chapter 9, "<A HREF="ch09.htm">Using Files</A>," for more information.<P>
  <FONT COLOR=Blue SIZE=2><PRE>open(FILE, "file.dat");
  binmode(FILE);</PRE></FONT>
  </TABLE>
  <A NAME="xcbless"></A>
  <H3><A NAME="bless (REFERENCE, [CLASSNAME] )">bless (REFERENCE, [CLASSNAME] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Object<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a reference to the blessed object.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Changes the type of the referenced variable to <TT>CLASSNAME</TT>. It is used to assign a class name the referenced variable, thus changing the string returned by the <TT>ref()</TT> function. If <TT>CLASSNAME</TT> is not specified, the name of the current package is used. See Chapter 8, "<A HREF="ch08.htm">References</A>," for more information.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$temp = { }
  bless $temp, 'ATMPCLASS';
  print("bless() \$temp is now has type ", 
  ref($temp), "\n");</PRE></FONT>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  Always specify the <TT>CLASSNAME</TT> parameter if the blessing function might be inherited.</TD></TR></TABLE><P>
  </B></TABLE>
  <A NAME="xccaller"></A>
  <H3><A NAME="caller ( [EXPR] )">caller ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Scope<P>
  Return Value in Scalar Context:	SCALAR, true if the current code has been called as a subroutine (this includes code which is included using a <TT>require()</TT> or an <TT>eval() call)</TT>. Otherwise, false.<P>
  Return Value in Array Context:	ARRAY, contains details of the calling context comprising the package name, file name, and line of the call.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This function is used to test the current scope of a subroutine call.<P>
  <FONT COLOR=Blue SIZE=2><PRE>sub testcaller {
      ($package, $file, $line) = caller;
      print("caller() Package=$package 
  File=$file Line=$line\n");
  }
  testcaller();</PRE></FONT>
  </TABLE>
  <A NAME="xcchdir"></A>
  <H3><A NAME="chdir ( [DIRNAME] )">chdir ( [DIRNAME] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false otherwise<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Changes the current directory to the directory specified. If no argument is given changes to the home directory of the current user.<P>
  <FONT COLOR=Blue SIZE=2><PRE>chdir("/") ? 
      print("It worked.\n") : 
      print("It didn't work.\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcchmod"></A>
  <H3><A NAME="chmod (MODE, LIST )">chmod (MODE, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of files changed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	<TT>MODE</TT> is an octal number representing file permissions which are applied to all the files in <TT>LIST</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>chmod(0744, "test1.txt", "test2.txt");</PRE></FONT>
  </TABLE>
  <A NAME="xcchomp"></A>
  <H3><A NAME="chomp ( [STRING | LIST] )">chomp ( [STRING | LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of characters removed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This is an safer alternative than the <TT>chop()</TT> function for removing characters at the end of strings. <TT>Chomp()</TT> only removes characters that correspond to the value of <TT>$/</TT> (the input line separator). It can be given a list of strings upon which to perform this operation. When given no arguments the chomp operation is performed on <TT>$_</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$temp = "AAAAA!\n";
  print("chomp(\$temp) returned ", chomp($temp), ".\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcchop"></A>
  <H3><A NAME="chop ( [STRING | LIST] )">chop ( [STRING | LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the last character that was removed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This function removes the last character of <TT>STRING</TT> or the last character of each element in <TT>LIST</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$tmp = "1234";
  print("chop(\$tmp) returned ", chop($tmp), "\n");</PRE></FONT>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  Use <TT>chomp()</TT> (with <TT>$/</TT> set to "\n") rather than <TT>chop()</TT> if you are not sure that the string has a trailing newline.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcchown"></A>
  <H3><A NAME="chown ( NUMERICAL_UID, NUMERICAL_GID, LIST )">chown ( NUMERICAL_UID, NUMERICAL_GID, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of files successfully changed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Changes the ownership of the files in <TT>LIST</TT> to the user ID and the group ID specified as parameters<P>
  <FONT COLOR=Blue SIZE=2><PRE>chown(1, 1, "test1.txt");</PRE></FONT>
  </TABLE>
  <A NAME="xcchr"></A>
  <H3><A NAME="chr ( NUMBER )">chr ( NUMBER )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the character represented by <TT>NUMBER</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the ASCII character represented by <TT>NUMBER</TT>. For example, <TT>chr(69)</TT> is the letter E.<P>
  </TABLE>
  <A NAME="xcchroot"></A>
  <H3><A NAME="chroot ( DIR_NAME )">chroot ( DIR_NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Changes the root directory of the current process to <TT>DIR_NAME</TT>. Which means that a filename like <TT>/john.dat</TT> might really refer to <TT>/root/users/~jmiller/john.dat</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>chroot("/usr/~waters");</PRE></FONT>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  Your process must have superuser rights in order to successfully use this function. It is used to make processes safer by only allowing them access to the subdirectory tree relevant to their purpose.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcclose"></A>
  <H3><A NAME="close ( FILEHANDLE )">close ( FILEHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the file was closed correctly, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the file opened with <TT>FILEHANDLE</TT>. This operation flushes all buffered output. If the file handle refers to a pipe the Perl program waits until the process being piped to has finished.<P>
  <FONT COLOR=Blue SIZE=2><PRE>open(FILE, "test1.txt");
  # some file activity
  close(FILE);</PRE></FONT>
  </TABLE>
  <A NAME="xcclosedir"></A>
  <H3><A NAME="closedir ( DIRHANDLE )">closedir ( DIRHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory, Files<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the directory was closed correctly, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the directory opened by <TT>opendir()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>opendir(DIR, ".");
  # some directory activity
  closedir(DIR);</PRE></FONT>
  </TABLE>
  <A NAME="xcconnect"></A>
  <H3><A NAME="connect ( SOCKET, NAME )">connect ( SOCKET, NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the connection was successful, otherwise false.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Attempts to connect to a remote socket. <TT>NAME</TT> must be a packed address of the correct type for the socket.<P>
  </TABLE>
  <A NAME="xccos"></A>
  <H3><A NAME="cos ( [EXPR] )">cos ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the cosine of <TT>EXPR</TT> or else <TT>$_</TT> is used if no expression is specified..<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Calculates a cosine.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$temp = cos(60);</PRE></FONT>
  </TABLE>
  <A NAME="xccrypt"></A>
  <H3><A NAME="crypt ( TEXT, SALT )">crypt ( TEXT, SALT )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, an encrypted string.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Encrypts <TT>TEXT</TT> using a key (either <TT>SALT</TT> or the first two letters of <TT>TEXT</TT>).<P>
  <FONT COLOR=Blue SIZE=2><PRE>$encyptedString = crypt("Password","TR");</PRE></FONT>
  </TABLE>
  <A NAME="xcdbmclose"></A>
  <H3><A NAME="dbmclose ( HASH )">dbmclose ( HASH )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Database<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the close was successfull, false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Undoes the linking of <TT>HASH</TT> to a dbm file.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  This function has been superseded by the <TT>untie()</TT> function.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcdbmopen"></A>
  <H3><A NAME="dbmopen ( HASH, DATABASE_NAME, MODE )">dbmopen ( HASH, DATABASE_NAME, MODE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Database<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Links <TT>HASH</TT> to <TT>DATABASE_NAME</TT>. If the database does not exist a new one with the specified <TT>MODE</TT> will be created.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  This function has been superseded by the <TT>tie()</TT> function.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcdefined"></A>
  <H3><A NAME="defined ( EXPR )">defined ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if <TT>EXPR</TT> has a real value, false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	There is a subtle distinction between an undefined null value and a defined null value. Some functions return undefined null to indicate errors, while others return a defined null to indicate a particular result (use a comparison with the null string to test for this rather than using <TT>defined()</TT>).<P>
  <FONT COLOR=Blue SIZE=2><PRE>@iexist = (1,2,3);
  print("exists.\n") if defined(@iexist);
  print("does not exist.\n") unless defined(@iexist);</PRE></FONT>
  </TABLE>
  <A NAME="xcdelete"></A>
  <H3><A NAME="delete ( EXPR )">delete ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Hash<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the deleted value or the undefined value if nothing was deleted.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Deletes an entry from an associative array. <TT>EXPR</TT> is the key for the entry to delete.<P>
  <FONT COLOR=Blue SIZE=2><PRE>%Hash = ('Jan' =&gt 'One', 'Feb' =&gt 'Two', 
    'Mar' =&gt 'Three');
  delete($Hash{'Jan'});</PRE></FONT>
  </TABLE>
  <A NAME="xcdie"></A>
  <H3><A NAME="die ( [LIST] )">die ( [LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Terminates execution of the Perl script, printing <TT>LIST</TT> to STDERR. The exit value is the current value of <TT>$!</TT> which may have been set by a previous function. If $! has a value of zero, <TT>$?</TT> will be returned instead. If <TT>$?</TT> is zero, it exits with an exit value of 255. If <TT>LIST</TT> does not end in a newline, the text similar to "at test.pl at line 10" will be appended to the end.<P>
  <FONT COLOR=Blue SIZE=2><PRE>die("Something fatal has happened and 
    the script must die!");</PRE></FONT>
  </TABLE>
  <A NAME="xcdo"></A>
  <H3><A NAME="do ( SCRIPTNAME )">do ( SCRIPTNAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Executes the contents of a file as a Perl script. It is usually used to include subroutines however it has been mostly superseded by <TT>use()</TT> and <TT>require()</TT>.<P>
  </TABLE>
  <A NAME="xcdump"></A>
  <H3><A NAME="dump ( [LABEL] )">dump ( [LABEL] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Causes the program to create a binary image or core dump. You can reload the image using undump program. When reloaded, the program begins execution from the optional label specified. So it is possible to set up a program which initializes data structures to <TT>dump()</TT> after the initialization so that execution is faster when reloading the dumped image.<P>
  </TABLE>
  <A NAME="xceach"></A>
  <H3><A NAME="each ( HASH )">each ( HASH )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Hash<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, an entry (the key-value pair) in <TT>HASH</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Allows iteration over the entries in an associative array. Each time it is evaluated, another key-value pair is returned. When all the entries have been returned, it returns an empty array.<P>
  <FONT COLOR=Blue SIZE=2><PRE>%NumberWord = ('1' =&gt 'One', '2' =&gt 'Two', 
    '3' =&gt 'Three');
  while (($key, $value) = each(%NumberWord)) {
      print("$key: $value\n");
  }</PRE></FONT>
  </TABLE>
  <A NAME="xcendgrent"></A>
  <H3><A NAME="endgrent ( )">endgrent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the <TT>/etc/group</TT> file used by <TT>getgrent()</TT> and other group related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pw, $gid, @members) = getgrent();
  endgrent();</PRE></FONT>
  </TABLE>
  <A NAME="xcendhostent"></A>
  <H3><A NAME="endhostent ( )">endhostent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Host, Sockets, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the TCP socket used by <TT>gethostbyname()</TT> and host related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$host = gethostbyname("lynch");
  endhostent();</PRE></FONT>
  </TABLE>
  <A NAME="xcendnetent"></A>
  <H3><A NAME="endnetent ( )">endnetent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Network, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the <TT>/etc/networks</TT> file used by <TT>getnetent()</TT> and network related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $aliases, $addrtype, $net) = getnetent();
  endnetent();</PRE></FONT>
  </TABLE>
  <A NAME="xcendprotoent"></A>
  <H3><A NAME="endprotoent ( )">endprotoent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocol, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the <TT>/etc/protocols</TT> file used by <TT>getprotoent()</TT> and protocol related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $protocol) = getprotoent();
  endprotoent();</PRE></FONT>
  </TABLE>
  <A NAME="xcendpwent"></A>
  <H3><A NAME="endpwent ( )">endpwent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Password, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the <TT>/etc/passwd file</TT> used by getpwent() and password related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pass, $uid, $gid, $quota, $name, 
      $gcos, $logindir, $shell) = getpwent();
  endpwent();</PRE></FONT>
  </TABLE>
  <A NAME="xcendservent"></A>
  <H3><A NAME="endservent ( )">endservent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Server, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Closes the <TT>/etc/servers</TT> file used by <TT>getservent()</TT> and related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $aliases, $port, $protocol) = getservent();
  endservent();</PRE></FONT>
  </TABLE>
  <A NAME="xceof"></A>
  <H3><A NAME="eof ( [FILEHANDLE] )">eof ( [FILEHANDLE] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the next read on <TT>FILEHANDLE</TT> will be at the end of file, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Tests for the end of a file. This is done by reading the next character and then undoing this operation (so is only suitable on files where this can be done safely). If no argument is supplied the file tested is the last file which was read. If the empty list is supplied then a pseudo file is created of the files listed on the command line. This lets you test for the end of the last file on the command line.<P>
  <FONT COLOR=Blue SIZE=2><PRE>open(FILE, "test1.txt");
  # some file activity
  print("eof() returned ", 
    eof(FILE) ? "TRUE" : "FALSE", "\n");
  close(FILE);</PRE></FONT>
  </TABLE>
  <A NAME="xceval"></A>
  <H3><A NAME="eval ( [EXPR | BLOCK] )">eval ( [EXPR | BLOCK] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	The undefined value if a syntax error, a runtime error, or a <TT>die()</TT> function occurs. Otherwise, the return value is the value of <TT>EXPR</TT> or the last statement in <TT>BLOCK</TT>. The return value can be any type.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Treats the expression like a Perl program and executes it. As the context of this execution is the same as that of the script itself, variable definitions and subroutine definitions persist. Syntax errors, runtime errors, and execution of the <TT>die()</TT> function are trapped and an undefined result is returned. If such an error does occur <TT>$@</TT> is set. <TT>$@</TT> will be equal to a defined null string if no errors are found. If no expression is supplied, <TT>$_</TT> is the default argument. If the block syntax is used then the expressions in the block are evaluated only once within the script (which may be more efficient for certain situations).<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  <TT>eval()</TT> traps possible error conditions which would otherwise crash a program and so can be used to test if certain features are available which would cause runtime errors if used when not available. See Chapter 13, "<A HREF="ch13.htm">Handling Errors and Signals</A>," for more information.</TD></TR></TABLE><P>
  <FONT COLOR=Blue SIZE=2><PRE>$answer = 3;
  eval("$answer = ;");
  if ($@ eq "") {
      print("eval() returned success.\n");
  }
  else {
      print("eval() error: $@");
  }</PRE></FONT>
  </TABLE>
  <A NAME="xcexec"></A>
  <H3><A NAME="exec ( LIST )">exec ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This function passes control from the script to an external system command. <B>There is no return from this call.</B> Note that <TT>system()</TT> calls external commands and does return.<P>
  <FONT COLOR=Blue SIZE=2><PRE>exec("cat /etc/motd");</PRE></FONT>
  </TABLE>
  <A NAME="xcexists"></A>
  <H3><A NAME="exists ( EXPR )">exists ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Hash<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if <TT>EXPR</TT> is an entry in a hash, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Tests whether a given key value exists in an associative array.<P>
  <FONT COLOR=Blue SIZE=2><PRE>%test = ( 'One' =&gt '1', 'Two' =&gt '2');
  if (exists($test{'One'})) {
      print("exists() returned success.\n");
  }
  else {
      print("exists() returned an error.\n");
  }</PRE></FONT>
  </TABLE>
  <A NAME="xcexit"></A>
  <H3><A NAME="exit ( [EXPR] )">exit ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Evaluates <TT>EXPR</TT> and exits the program with that value as the exit code. The default value for the exit code is 0 if no argument is supplied. If an <TT>END</TT> block has been defined, it will be called. Also, object destructors may be called for the process truly ends.<P>
  <FONT COLOR=Blue SIZE=2><PRE>exit(16);</PRE></FONT>
  </TABLE>
  <A NAME="xcexp"></A>
  <H3><A NAME="exp ( [EXPR] )">exp ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the natural log base (e) to the power of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the natural log base (e) to the power of <TT>EXPR</TT>. If no parameter is specified, <TT>$_</TT> is used.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print "exp() e**1 is ", exp(1), "\n";</PRE></FONT>
  </TABLE>
  <A NAME="xcfcntl"></A>
  <H3><A NAME="fcntl ( FILEHANDLE, FUNCTION, PACKED_FLAGS )">fcntl ( FILEHANDLE, FUNCTION, PACKED_FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	In Perl 5 use the fntcl module. In Perl 4 there should be some mechanism for linking the perl functions to the system functions which is usually executed when Perl is installed. See the perlfunc man page for more information.<P>
  </TABLE>
  <A NAME="xcfileno"></A>
  <H3><A NAME="fileno ( FILEHANDLE )">fileno ( FILEHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the file descriptor for <TT>FILEHANDLE</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the file descriptor given a file handle. File descriptors are useful when using bitmaps for the <TT>select()</TT> function.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("fileno() ", fileno(FILE), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcflock"></A>
  <H3><A NAME="flock ( FILEHANDLE, OPERATION_FLAGS )">flock ( FILEHANDLE, OPERATION_FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Lets you access file locks. You can place an exclusive lock, place a shared lock, or remove locks. You can find more information about <TT>flock()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xcfork"></A>
  <H3><A NAME="fork ( )">fork ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the pid of the child process or undef is unsuccessful.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Starts a child process. Both child and parent processes start executing the line of code immediately following the <TT>fork()</TT> call. You can find more information about <TT>fork()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xcformline"></A>
  <H3><A NAME="formline ( PICTURE, LIST )">formline ( PICTURE, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This internal function is used by the format mechanism. It allows direct manipulation of the format process by adding values to the format accumulator (<TT>$^A</TT>). For more information about formats, see Chapter 11, "<A HREF="ch11.htm">Creating Reports</A>."<P>
  </TABLE>
  <A NAME="xcgetc"></A>
  <H3><A NAME="getc ( [FILEHANDLE] )">getc ( [FILEHANDLE] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Input<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the inputted character. Null if at end of file.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the next character <TT>FILEHANDLE</TT> or STDIN if no filehandle is specified.<P>
  <FONT COLOR=Blue SIZE=2><PRE>open(FILE, "/etc/motd");
  print "getc() ", getc(FILE), "\n";
  close(FILE);</PRE></FONT>
  </TABLE>
  <A NAME="xcgetgrent"></A>
  <H3><A NAME="getgrent ( )">getgrent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  Return Value in Scalar Context :	Returns the next group name. Or the undefined value if no more groups or an error occured.<P>
  Return Value in Array Context :	($name, $passwd, $gid, $members) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns information about groups taken from the <TT>/etc/group</TT> system file. If called repeatedly, it will iterate through the entries in the <TT>/etc/group</TT> file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pw, $gid, @members) = getgrent();
  print("getgrent() Examines 
    /etc/group [$name,$gid] file.\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetgrgid"></A>
  <H3><A NAME="getgrgid ( GID )">getgrgid ( GID )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  Return Value in Scalar Context:	The next group name that belongs to <TT>GID</TT>.<P>
  Return Value in Array Context:	($name, $passwd, $gid, $members) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns information about groups taken from the <TT>/etc/group</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($grname, $grpw, $gid, @members) = getgrgid(0);
  print("getgrgid() Returns group 
    name given GID [$grname]\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetgrname"></A>
  <H3><A NAME="getgrname ( NAME )">getgrname ( NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  Return Value in Scalar Context:	The next group id that belongs to <TT>NAME</TT>.<P>
  Return Value in Array Context:	($name, $passwd, $gid, $members) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns information about groups taken from the <TT>/etc/group</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($grname, $grpw, $gid, @members) = getgrnam("root");
  print("getgrnam() Returns group 
    GID given name [$gid]\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgethostbyaddr"></A>
  <H3><A NAME="gethostbyaddr ( ADDRESS, AF_INIT )">gethostbyaddr ( ADDRESS, AF_INIT )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Host, Socket<P>
  Return Value in Scalar Context:	Name of host addressed by <TT>ADDRESS</TT>. Or undefined if the host could not be found.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$addrtype</TT>, <TT>$length</TT>, <TT>@addrs</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/hosts</TT> system file or checks a Domain Name Server for a server with <TT>ADDRESS</TT>. The value for AF_INIT is always 2.<P>
  <FONT COLOR=Blue SIZE=2><PRE>use Socket;
  $addr = pack('C4', (140,203,7,103));
  ($name, $alias, $addrtype, $length, @addrs) = 
  gethostbyaddr($addr, AF_INET);
  print("gethostbyaddr() [$alias].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgethostbyname"></A>
  <H3><A NAME="gethostbyname ( NAME, [PROTOCOL] )">gethostbyname ( NAME, [PROTOCOL] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Host, Socket<P>
  Return Value in Scalar Context:	Address of the host called <TT>NAME</TT>. Or undefined if the host could not be found.<P>
  Return Value in Array Context:	($name, $aliases, $addrtype, $length, @addrs) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/hosts</TT> system file or checks a Domain Name Server for a server called <TT>NAME</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $addrtype, $length, @addrs) = 
     gethostbyname("lynch");
  print("gethostbyname() [$alias].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgethostent"></A>
  <H3><A NAME="gethostent ( )">gethostent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Host, UNIX<P>
  Return Value in Scalar Context:	Name of the next host in <TT>/etc/hosts</TT>. or the undefined value.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$addrtype</TT>, <TT>$length</TT>, <TT>@addrs</TT>) Or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/hosts</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $addrtype, $length, @addrs) = 
     gethostent();
  print("gethostent() [$alias].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetlogin"></A>
  <H3><A NAME="getlogin ( )">getlogin ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the name of the current login.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the current login name from the <TT>/etc/utmp</TT> system file. Use <TT>getpwuid()</TT>for more information on the login because the information stored in <TT>/etc/utmp</TT> is limited.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print ("getlogin() ", getlogin(), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetnetbyaddr"></A>
  <H3><A NAME="getnetbyaddr ( ADDRESS, ADDR_TYPE )">getnetbyaddr ( ADDRESS, ADDR_TYPE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Network<P>
  Return Value in Scalar Context:	The network name that has an address of <TT>ADDRESS</TT> or undefined.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$addrtype</TT>, <TT>$net</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks for the network information in the <TT>/etc/networks</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($addrtype) = (getnetent())[2];
  ($name, $alias, $addrtype, $net) = 
    getnetbyaddr($net, $addrtype);
  print("getnetbyaddr() Reads /etc/networks 
    [$name]\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetnetbyname"></A>
  <H3><A NAME="getnetbyname ( NAME )">getnetbyname ( NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Network<P>
  Return Value in Scalar Context:	The network address of <TT>NAME</TT> or undefined.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$addrtype</TT>, <TT>$net</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks for the network information in the <TT>/etc/networks</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $addrtype, $net) = 
    getnetbyname("localnet");
  print("getnetbyname() Reads /etc/networks 
    [$name]\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetnetent"></A>
  <H3><A NAME="getnetent ( )">getnetent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Network<P>
  Return Value in Scalar Context:	The next network name in <TT>/etc/networks</TT> or undefined.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$addrtype</TT>, <TT>$net</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, it iterates over the information in the <TT>/etc/networks</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $addrtype, $net) = 
    getnetent();
  print("getnetent() Reads /etc/networks [$name, 
    $addrtype]\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetpeername"></A>
  <H3><A NAME="getpeername ( SOCKET )">getpeername ( SOCKET )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Sockets<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the address of the remote side of a socket connection represented by <TT>SOCKET</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the packed address of the remote side of a socket. The address can then be used with the unpack() function to retrieve the protocol family, port and ip address values.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$sockaddr = 'S n a4 x8';
  $packedRemoteAddr = getpeername(S);
  ($family, $port, $remoteAddr) = 
     unpack($sockaddr,$packedRemoteAddr);</PRE></FONT>
  <FONT COLOR=Blue SIZE=2><PRE></PRE></FONT>
  </TABLE>
  <A NAME="xcgetpgrp"></A>
  <H3><A NAME="getpgrp ( PID )">getpgrp ( PID )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Groups, Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the current process group for <TT>PID</TT>. If <TT>PID</TT> is not specified or 0 is used, the current group of the current process is returned.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Finds the current process group for a given pid.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("getpgrp() ", getpgrp(0), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetppid"></A>
  <H3><A NAME="getppid ( )">getppid ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the pid of the parent process.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Finds the pid of the parent process.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("getppid() ", getppid(), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetpriority"></A>
  <H3><A NAME="getpriority ( WHICH, WHO )">getpriority ( WHICH, WHO )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the current priority associated with the parameters.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the current priority of <TT>WHO</TT> (the pid, group pid, uid, or 0 for the current process). The <TT>WHICH</TT> parameter can one of <TT>PRIO_PROCESS</TT> (0), <TT>PRIO_PGGRP</TT> (1), <TT>PRIO_USER</TT> (2).<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("getpriority() ", getpriority(0, 0), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetprotobyname"></A>
  <H3><A NAME="getprotobyname ( NAME )">getprotobyname ( NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocols, UNIX<P>
  Return Value in Scalar Context:	The protocol number assigned to <TT>NAME</TT>.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$proto</TT>) or an empty list. <TT>$proto</TT> is the protocol number.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/protocols</TT> system file for the protocol called <TT>NAME</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $proto) = getprotobyname("IP");
  print("getprotobyname() 
  /etc/proto [$name, $alias, $proto].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetprotobynumber"></A>
  <H3><A NAME="getprotobynumber ( NUMBER )">getprotobynumber ( NUMBER )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocols, UNIX<P>
  Return Value in Scalar Context:	The protocol name associated with <TT>NUMBER</TT>.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$proto</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/protocols</TT> system file for <TT>NUMBER</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $proto) = getprotobynumber(0);
  print("getprotobynumber() 
  /etc/protocols [$name, $alias, $proto].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetprotoent"></A>
  <H3><A NAME="getprotoent ( )">getprotoent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocols, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY. (<TT>$name</TT>, <TT>$aliases</TT>, <TT>$proto</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, it iterates over the <TT>/etc/protocols</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $alias, $proto) = getprotoent();
  print("getprotoent() 
  Closes /etc/protocols [$name, $alias, $proto].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetpwent"></A>
  <H3><A NAME="getpwent ( )">getpwent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Password, UNIX<P>
  Return Value in Scalar Context:	The username.<P>
  Return Value in Array Context:	ARRAY. (<TT>$name</TT>, <TT>$passwd</TT>, <TT>$uid</TT>, <TT>$gid</TT>, <TT>$quota</TT>, <TT>$comment</TT>, <TT>$gcos</TT>, <TT>$dir</TT>, <TT>$shell</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, it iterates over the <TT>/etc/passwd</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pass, $uid, $gid, 
  $quota, $name, $gcos, $dir, $shell) = getpwent();
  print("getpwent() /etc/passwd [$dir, 
  $shell].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetpwnam"></A>
  <H3><A NAME="getpwnam ( NAME )">getpwnam ( NAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Password, UNIX<P>
  Return Value in Scalar Context:	The userid of <TT>NAME</TT>.<P>
  Return Value in Array Context:	($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/passwd</TT> system file for <TT>NAME</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pass, $uid, $gid, 
  $quota, $name, 
      $gcos, $dir, $shell) = getpwnam("root");
  print("getpwnam() /etc/passwd [$dir, 
  $shell].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetpwuid"></A>
  <H3><A NAME="getpwuid ( UID )">getpwuid ( UID )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Password, UNIX<P>
  Return Value in Scalar Context:	The username of <TT>UID</TT>.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$passwd</TT>, <TT>$uid</TT>, <TT>$gid</TT>, <TT>$quota</TT>, <TT>$comment</TT>, <TT>$gcos</TT>, <TT>$dir</TT>, <TT>$shell</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks in the <TT>/etc/passwd</TT> system file for <TT>UID</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $pass, $uid, $gid, 
  $quota, $name, 
      $gcos, $dir, $shell) = getpwuid(0);
  print("getpwuid() /etc/passwd [$dir, 
  $shell].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetservbyname"></A>
  <H3><A NAME="getservbyname ( NAME, PROTOCOL )">getservbyname ( NAME, PROTOCOL )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocol, Service, Socket, UNIX<P>
  Return Value in Scalar Context:	The port number.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$port</TT>, <TT>$proto</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets services by name. Looks in the <TT>/etc/services</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $aliases, $port, 
  $protol) = getservbyname("tcpmux", "tcp");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetservbyport"></A>
  <H3><A NAME="getservbyport ( PORT_NUMBER, PROTOCOL )">getservbyport ( PORT_NUMBER, PROTOCOL )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocol, Service, Socket, UNIX<P>
  Return Value in Scalar Context:	The service name.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$port</TT>, <TT>$proto</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets services by port.Looks in the <TT>/etc/services</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $aliases, $port, 
  $proto) = getservbyport(512, "tcp");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetservent"></A>
  <H3><A NAME="getservent ( )">getservent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocol, Service, Socket, UNIX<P>
  Return Value in Scalar Context:	The next service name.<P>
  Return Value in Array Context:	(<TT>$name</TT>, <TT>$aliases</TT>, <TT>$port</TT>, <TT>$proto</TT>) or an empty list.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, iterates over the <TT>/etc/services</TT> system file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($name, $aliases, $port, 
  $proto) = getservent();
  print("getservent() /etc/servers 
  [$name].\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcgetsockname"></A>
  <H3><A NAME="getsockname ( SOCKET)">getsockname ( SOCKET)</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Sockets<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the packed address of the local end of the socket.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Finds out the address of your script's socket.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$packedAddr = 
  getsockname(S);
  ($family, $port, $localAddr) = unpack('S n a4 x8', 
  $packedAddr);</PRE></FONT>
  </TABLE>
  <A NAME="xcgetsockopt"></A>
  <H3><A NAME="getsockopt ( SOCKET, LEVEL, OPTNAME )">getsockopt ( SOCKET, LEVEL, OPTNAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Sockets<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the socket option requested or the undefined value.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the value of a specified socket option.<P>
  </TABLE>
  <A NAME="xcglob"></A>
  <H3><A NAME="glob ( EXPR )">glob ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, the list of files represented by <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Looks for file name that match <TT>EXPR</TT>. You can use wildcards in <TT>EXPR</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@files = 
  glob("*.txt");</PRE></FONT>
  </TABLE>
  <A NAME="xcgmtime"></A>
  <H3><A NAME="gmtime ( [EXPR] )">gmtime ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Time<P>
  Return Value in Scalar Context:	A string like 'Sat Jul 13 07:34:46 1986' describing <TT>EXPR</TT>.<P>
  Return Value in Array Context:	(<TT>$sec</TT>, <TT>$min</TT>, <TT>$hour</TT>, <TT>$mday</TT>, <TT>$mon</TT>, <TT>$year</TT>, <TT>$wday</TT>, <TT>$ydat</TT>, <TT>$isdst</TT>)<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Breaks <TT>EXPR</TT> (a number of seconds since 1<SUP>st</SUP> Jan 1970) into a 9-element list. If no argument is used the current time is used. If your system supports POSIX timezones, the time returned is localized for the Greenwich Mean Time timezone. Note that $mon ranges from 0..11, $wday ranges from 0..6, and $year does not handle centuries.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($sec, $min, $hour, $mday, 
  $mon, $year, $wday, $ydat, $isdst) = gmtime();
  print "gmtime() 19$year-$mon-$mday\n";</PRE></FONT>
  </TABLE>
  <A NAME="xcgrep"></A>
  <H3><A NAME="grep ( BLOCK | EXPR, LIST )">grep ( BLOCK | EXPR, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Regular Expressions<P>
  Return Value in Scalar Context:	The number of times that <TT>BLOCK</TT> or <TT>EXPR</TT> evaluated to true.<P>
  Return Value in Array Context:	A list of the elements of <TT>LIST</TT> that cause <TT>BLOCK</TT> or <TT>EXPR</TT> to evaluate as true.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Evaluates the expression or block for each of the elements in <TT>LIST</TT>. Think of this function as having an internal <TT>foreach</TT> loop. Each element in <TT>LIST</TT> is assigned to <TT>$_</TT> and then the block or expression is evaluated. The most common use for this is with a pattern match operation as the expression, and a list of strings to be processed. You may be tempted to use <TT>grep()</TT> as an easy way to interate over an array as shown in the second example below, <I>don't do this</I>. Use the <TT>map()</TT> function instead.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Look for all elements that 
  begin with the letter T.
  @a = ('One', 'Two', 'Three', 'Four', 'Five');
  print("grep(), ", grep(/^T/, @a), "\n");

  # Print all elements in a list.
  @a = ('One', 'Two', 'Three', 'Four', 'Five');
  grep( print("$_\n"), @a);</PRE></FONT>
  </TABLE>
  <A NAME="xchex"></A>
  <H3><A NAME="hex ( EXPR )">hex ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the decimal value of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Converts <TT>EXPR</TT> from hexadecimal to decimal. For example, <TT>hex('FF0')</TT> will return <TT>'4080'</TT>. You can use the string returned as a number because Perl will automatically convert strings to numbers in numeric contexts.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("hex() ", hex("ff"), 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcimport"></A>
  <H3><A NAME="import ( )">import ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This is the only user-defined function in this list. If a module has an <TT>import()</TT> function then the <TT>use()</TT> function will call it as the module is being loaded. You can use the <TT>import()</TT> function to initialize variables, open files, or do any other setup work.<P>
  </TABLE>
  <A NAME="xcindex"></A>
  <H3><A NAME="index ( STRING, SUBSTRING, [POSITION] )">index ( STRING, SUBSTRING, [POSITION] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the position of the first occurrence of <TT>SUBSTRING</TT> in <TT>STRING</TT> at or after <TT>POSITION</TT> or -1 if not found.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, you can iterate over all the occurrences of <TT>SUBSTRING</TT> in <TT>STRING</TT>. The returned value is an offset from <TT>$[</TT> (which is normally zero). If <TT>$[</TT> is altered it will change the way <TT>index()</TT> works as it will start its search from $[ if no position argument is supplied, and it will return <TT>$[ - 1</TT> when there is no match found.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$answer1 = 
  index("abcdefghijiklmdef:-)", "def");
  $answer2 = index("abcdefghijiklmdef", "def", $answer1 + 
  3);
  print("index() def is at $answer1 and next at 
  $answer2\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcint"></A>
  <H3><A NAME="int ( [EXPR] )">int ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the integer portion of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Chops of any fractional part of <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified.For example, <TT>int(21.45)</TT> would return <TT>21</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("int() ", 
  int(345.678), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcioctl"></A>
  <H3><A NAME="ioctl ( FILEHANDLE, FUNCTION, SCALAR )">ioctl ( FILEHANDLE, FUNCTION, SCALAR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful; false if not and the undefined value in some cases.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Controls Input/Output operations, mainly used for terminals. It calls the UNIX <TT>ioctl()</TT> function with the specified parameters. Returns undefined if the operating system returns -1. Returns string "0 but true" if the operating system returns 0. Otherwise returns the value returned by the operating system. You can find more information about <TT>ioctl()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xcjoin"></A>
  <H3><A NAME="join ( EXPR, LIST )">join ( EXPR, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a string with each element of <TT>LIST</TT> alternating with <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Concatenates all of the elements of <TT>LIST</TT> together with <TT>EXPR</TT> as the glue. For example, <TT>join('!', ('QQ', 'AA'))</TT> will return <TT>'QQ!AA'</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@listone = (0, 1, 2, 3);
  print("join() ", join("-",@listone), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xckeys"></A>
  <H3><A NAME="keys ( HASH )">keys ( HASH )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, Hash <P>
  Return Value in Scalar Context:	The number of keys and, therefore, the number of entries in <TT>HASH</TT>.<P>
  Return Value in Array Context:	All of the keys to <TT>HASH</TT> in no particular order.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets a list of all keys in <TT>HASH</TT>. The returned list is ordered by the internal storage requirements, so it is often useful to use the <TT>sort()</TT> function before processing. For example, <TT>sort(keys(%hash))</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>%hash = ('One' =&gt 1, 'Two' 
  =&gt 2, 'Three' =&gt 3, 'Four' =&gt 4);
  print("keys() ", join("-", keys(%hash)), 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xckill"></A>
  <H3><A NAME="kill ( SIGNAL, LIST )">kill ( SIGNAL, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of processes successfully signaled.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sends <TT>SIGNAL</TT> to the processes identified by <TT>LIST</TT>. If <TT>SIGNAL</TT> is negative then process groups are killed instead.<P>
  </TABLE>
  <A NAME="xclc"></A>
  <H3><A NAME="lc ( EXPR )">lc ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a copy of <TT>EXPR</TT> with all letters in lowercase.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a copy of <TT>EXPR</TT> with all letters in lowercase.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("lc() ", lc("ABCDef"), 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclcfirst"></A>
  <H3><A NAME="lcfirst ( EXPR )">lcfirst ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a copy of <TT>EXPR</TT> with the first letter in lowercase.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a copy of <TT>EXPR</TT> with the first letter in lowercase.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("lcfirst() ", 
  lcfirst("ABCDef"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclength"></A>
  <H3><A NAME="length ( [EXPR] )">length ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of characters in <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Determines the numbers of characters in <TT>EXPR</TT>. If no expression is supplied $_ is used.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("length() ", 
  length("01234"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclink"></A>
  <H3><A NAME="link ( OLD_FILE, NEW_FILE )">link ( OLD_FILE, NEW_FILE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a hard link called <TT>NEW_FILE</TT> linking to the filename called <TT>OLD_FILE</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("The result from 
  link() is ", link("/usr/local", "/tmp/link"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclisten"></A>
  <H3><A NAME="listen ( SOCKET, QUEUESIZE )">listen ( SOCKET, QUEUESIZE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true of successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Listens for connections on a socket. <TT>QUEUESIZE</TT> specifies how many processes can wait for connections.<P>
  </TABLE>
  <A NAME="xclocal"></A>
  <H3><A NAME="local ( LIST )">local ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Scope<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Makes all the variables in <TT>LIST</TT> to be local to the current block. The <TT>my()</TT> function is better than local() because it also creates new copies of the variables for each recursive call of a subroutine. Don't use <TT>local()</TT> inside loops. Variables marked using <TT>local()</TT> can be seen by functions called from inside the current block.<P>
  <FONT COLOR=Blue SIZE=2><PRE>local($numTires) = 
  10;</PRE></FONT>
  </TABLE>
  <A NAME="xclocaltime"></A>
  <H3><A NAME="localtime ( [EXPR] )">localtime ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Time<P>
  Return Value in Scalar Context:	A string like 'Sat Jul 13 07:34:46 1986' describing <TT>EXPR</TT>.<P>
  Return Value in Array Context:	(<TT>$sec</TT>, <TT>$min</TT>, <TT>$hour</TT>, <TT>$mday</TT>, <TT>$mon</TT>, <TT>$year</TT>, <TT>$wday</TT>, <TT>$ydat</TT>, <TT>$isdst</TT>)<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Breaks <TT>EXPR</TT> (a number of seconds since 1<SUP>st</SUP> Jan 1970) into a 9-element list. If no argument is used the current time is used. If your system supports POSIX timezones, the time returned is localized for the current timezone. Note that <TT>$mon</TT> ranges from 0..11, <TT>$wday</TT> ranges from 0..6, and <TT>$year</TT> does not handle centuries. If no expression is specified, the current time is used.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($sec, $min, $hour, $mday, 
  $mon, $year, $wday, $ydat, $isdst) = localtime();
  print("localtime() 19$year-$mon-$mday\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclog"></A>
  <H3><A NAME="log ( [EXPR] )">log ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the logarithm (using the natural logarithm base e) of <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Determines the logarithm (using the natural logarithm base e) of the expression.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("log() ", log(2.5), 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xclstat"></A>
  <H3><A NAME="lstat ( FILEHANDLE | EXPR )">lstat ( FILEHANDLE | EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, (<TT>$device</TT>, <TT>$inode</TT>, <TT>$mode</TT>, <TT>$nlink</TT>, <TT>$uid</TT>, <TT>$gid</TT>, <TT>$rdev</TT>, <TT>$size</TT>, <TT>$atime</TT>, <TT>$mtime</TT>, <TT>$ctime</TT>, <TT>$blksize</TT>, <TT>$blocks</TT>) or an empty list if an error occurs.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the file statstics of a symbolic link rather that the file pointed to the link. If the parameters do not refer to a symbolic link, the file statistics are still returned. Note that, like the filetest operators, <TT>lstat()</TT> can take the special underscore filehandle (_) which means that the test is carried out on the same filehandle as the last filetest, <TT>stat()</TT> or <TT>lstat()</TT> call.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($device, $inode, $mode, 
  $nlink, $uid, $gid, $rdev, $size, 
      $atime, $mtime, $ctime, $blksize, $blocks) = 
  lstat("/tmp/link");
  print("lstat() $device, $inode, $ctime \n");</PRE></FONT>
  </TABLE>
  <A NAME="xcmap"></A>
  <H3><A NAME="map ( BLOCK | EXPR, LIST )">map ( BLOCK | EXPR, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, a list of the results of evaluating <TT>BLOCK</TT>or <TT>EXPR</TT> which each element of <TT>LIST</TT> being assigned to <TT>$_</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Evaluates the specified expression (or block) for each element of <TT>LIST</TT>. This is done by assigning each element to $_ and evaluting the expression (or block) in an array context. Therefore, the returned array may have more elements than <TT>LIST</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Increment each element by 
  one.
  @array = (0..3);
  @result = map($_ + 1, @array);
  print("Before map: @array\n");
  print("After  map: @result\n");

  # Print all elements in a list.
  @array = ('One', 'Two', 'Three', 'Four', 'Five');
  map( print("$_\n"), @array);</PRE></FONT>
  </TABLE>
  <A NAME="xcmkdir"></A>
  <H3><A NAME="mkdir ( FILENAME, [MODE] )">mkdir ( FILENAME, [MODE] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a directory call <TT>DIRNAME</TT>, with the mode specified by <TT>MODE</TT>. The mode is specifed using an octal number and is ignored under Windows 95 or Windows NT. If the directory can't be created, <TT>$!</TT> is set to the operating system error.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("mkdir() ", 
  mkdir("testdir", 0777), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcmsgctl"></A>
  <H3><A NAME="msgctl ( ID, COMMAND, ARG )">msgctl ( ID, COMMAND, ARG )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communications, Message Queues<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful; false if not and the undefined value in some cases.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Controls message queue operations. It calls the UNIX <TT>msgctl()</TT> function with the specified parameters. Returns undefined if the operating system returns -1. Returns string "0 but true" if the operating system returns 0. Otherwise returns the value returned by the operating system. You can find more information about <TT>msggctl()</TT> in section 2 of the UNIX manual pages.<P>
  </TABLE>
  <A NAME="xcmsgget"></A>
  <H3><A NAME="msgget ( KEY, FLAGS )">msgget ( KEY, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication, Message Queue<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the message queue id or the undefined value if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Determines the message queue id.<P>
  </TABLE>
  <A NAME="xcmsgrcv"></A>
  <H3><A NAME="msgrcv ( QUEUE_ID, BUFFER, BUFFER_SIZE, TYPE, FLAGS )">msgrcv ( QUEUE_ID, BUFFER, BUFFER_SIZE, TYPE, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication, Message Queue<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets a message from <TT>QUEUE_ID</TT>. The message is placed into <TT>BUFFER</TT>.<P>
  </TABLE>
  <A NAME="xcmsgsnd"></A>
  <H3><A NAME="msgsnd ( QUEUE_ID, BUFFER, FLAGS )">msgsnd ( QUEUE_ID, BUFFER, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication, Message Queue<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Send a message to <TT>QUEUE_ID</TT>. The message to be sent should be in <TT>BUFFER</TT>.<P>
  </TABLE>
  <A NAME="xcmy"></A>
  <H3><A NAME="my ( LIST )">my ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Scope<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Declares each of the variables listed to be local to the lexical unit (block or file). See Chapter 5, "<A HREF="ch05.htm">Functions</A>," for more information.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Define the function foo 
  with four local variables.
  sub foo {
      my($numTires) = shift;
      my(@params) = @_;
      my($tireType, $tirePressure);
  }</PRE></FONT>
  </TABLE>
  <A NAME="xcoct"></A>
  <H3><A NAME="oct ( [EXPR] )">oct ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the decimal value of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Converts <TT>EXPR</TT> from octal to decimal. For example, <TT>oct('0760')</TT> will return <TT>'496'</TT>. You can use the string returned as a number because Perl will automatically convert strings to numbers in numeric contexts.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("oct() ", oct("88"), 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcopen"></A>
  <H3><A NAME="open ( FILEHANDLE | EXPR | FILENAME )">open ( FILEHANDLE | EXPR | FILENAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the file is opened, false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Opens a file using the specified file handle. The file handle may be an expression, the resulting value is used as the handle. If no filename is specified a variable with the same name as the file handle used (this should be a scalar variable with a string value referring to the file name). The special file name '-' refers to <TT>STDIN</TT> and '&gt-' refers to <TT>STDOUT</TT>.<P>
  The file name string may be prefixed with the following values to indicate the mode:<P>
  <TABLE BORDER=1 CELLPADDING=10>
  <TR><TH ALIGN=left>Prefix Value </TH><TH ALIGN=left>Description</TH></TR>
  <TR><TD>&lt</TD><TD>read access, this is the default</TD></TR>
  <TR><TD>&gt</TD><TD>write access</TD></TR>
  <TR><TD>+&gt</TD><TD>create a file with read/write access</TD></TR>
  <TR><TD>+&lt</TD><TD>read/write access to an existing file</TD></TR>
  <TR><TD>&gt&gt</TD><TD>append to a file</TD></TR>
  <TR><TD>" CMD |"</TD><TD>Execute CMD as an operating system command and pipe the resulting output back to your Perl script as <TT>FILEHANDLE</TT>.</TD></TR>
  <TR><TD>"| CMD"</TD><TD>Pipe output to <TT>FILEHANDLE</TT> into <TT>CMD</TT>.</TD></TR></TABLE><P>
  <FONT COLOR=Blue SIZE=2><PRE>$FILE = "foo.dat"
  open(FILE) or die("Unable to open $FILE because: $!");</PRE></FONT>
  </TABLE>
  <A NAME="xcopendir"></A>
  <H3><A NAME="opendir ( DIRHANDLE, EXPR | DIRNAME )">opendir ( DIRHANDLE, EXPR | DIRNAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the directory is opened, false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Opens a connection between the directory handle and the directory name. If you use an expression for the second parameter, it is expected to evaluate to a directory name.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$dir = "/tmp"
  opendir(DIR, $dir) or 
    die("Unable to open $dir because $!");</PRE></FONT>
  </TABLE>
  <A NAME="xcord"></A>
  <H3><A NAME="ord ( [EXPR] )">ord ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the numeric value of the first character of <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the numeric ascii code of the first character in the expression. For example, <TT>ord('A')</TT> returns a value of 65.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("ord() ", ord('G'), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcpack"></A>
  <H3><A NAME="pack ( TEMPLATE, LIST )">pack ( TEMPLATE, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a packed version of the data in <TT>LIST</TT> using <TT>TEMPLATE</TT> to determine how it is coded.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Converts <TT>LIST</TT> into a data structure-possibly packed with binary information. You can find additional information by looking at the perfunc man page, the perlfunc.htm file in your docs directory, or by checking the web for the <A HREF="ftp://ftp.metronet.com/pub/perl/doc/manual/html/perlfunc/pack.html">perlfunc</A> page. You can use any of the following specifiers in the template string.<P>
  <TABLE BORDER=1 CELLPADDING=10><TR><TH ALIGN=left>Format<BR>Specifier </TH><TH ALIGN=left>Description</TH></TR>
  <TR><TD>@</TD><TD>Null fill to absolute position. </TD></TR>
  <TR><TD>A</TD><TD>Ascii string with spaces to pad. </TD></TR>
  <TR><TD>a</TD><TD>Ascii string with nulls to pad. </TD></TR>
  <TR><TD>b</TD><TD>Bit string (ascending bit order). </TD></TR>
  <TR><TD>B</TD><TD>Bit string (descending bit order). </TD></TR>
  <TR><TD>c</TD><TD>Signed char value.</TD></TR>
  <TR><TD>C</TD><TD>Unsigned char value.</TD></TR>
  <TR><TD>d</TD><TD>Double-precision float in the native format.</TD></TR>
  <TR><TD>f</TD><TD>Single-precision float in the native format.</TD></TR>
  <TR><TD>h</TD><TD>Hex string (low nybble first).</TD></TR>
  <TR><TD>H</TD><TD>Hex string (high nybble first).</TD></TR>
  <TR><TD>i</TD><TD>Signed integer value.</TD></TR>
  <TR><TD>I</TD><TD>Unsigned integer value.</TD></TR>
  <TR><TD>l</TD><TD>Signed long integer value.</TD></TR>
  <TR><TD>L</TD><TD>Unsigned long integer value.</TD></TR>
  <TR><TD>n</TD><TD>Short integer "network" order.</TD></TR>
  <TR><TD>N</TD><TD>Long integer "network" order.</TD></TR>
  <TR><TD>p</TD><TD>Pointer to a null-terminated string.</TD></TR>
  <TR><TD>P</TD><TD>Pointer to a structure (fixed-length string).</TD></TR>
  <TR><TD>s</TD><TD>Signed short integer value.</TD></TR>
  <TR><TD>S</TD><TD>Unsigned short integer value.</TD></TR>
  <TR><TD>u</TD><TD>UUencoded string.</TD></TR>
  <TR><TD>v</TD><TD>Short integer "VAX" (little-endian) order.</TD></TR>
  <TR><TD>V</TD><TD>Long integer "VAX" (little-endian) order.</TD></TR>
  <TR><TD>x</TD><TD>Null byte.</TD></TR>
  <TR><TD>X</TD><TD>Back up a byte.</TD></TR></TABLE><P>
  A concise form of template can be used by appending a number after any letter to repeat that format specifier. For example, a5 indicates that five letters are expected. b32 indicates that 32 bits are expected. h8 indicates that 8 nybbles ( or 4 bytes) are expected. P10 indicates that the structure is 10 bytes long. Using a * in place of a number means to repeat the format specifier as necessary to use up all list values. Note that some packed structures may not be portable across machines (in particulat network and floating point formats). It should be possible to unpack the data using the same format specification with an <TT>unpack()</TT> call.<P>
  <FONT COLOR=Blue SIZE=2><PRE>Use Socket;
  @address = (140, 203, 7, 103)
  $addr = pack('C4', @address);
  print("@address is packed as: $addr\n");</PRE></FONT>
  </TABLE>
  <H3><A NAME="pipe ( READHANDLE, WRITEHANDLE )">pipe ( READHANDLE, WRITEHANDLE )</A></H3>
  <A NAME="xcpipe"></A>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Opens a pair of connected pipes.<P>
  </TABLE>
  <A NAME="xcpop"></A>
  <H3><A NAME="pop ( ARRAY_VARIABLE )">pop ( ARRAY_VARIABLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the last element in the specified array.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Removes the last element from the specified array. Note that the array will be shortened by one.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@a = (1, 2, 3, 4);
  print("pop() ", pop(@a), "leaves ",@a, 
  "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcpos"></A>
  <H3><A NAME="pos ( [SCALAR] )">pos ( [SCALAR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Regular Expression<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the position of the last matched substring of the last <TT>m//g</TT> operation.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Used to find the offset or position of the last matched substring. If <TT>SCALAR</TT> is specified, it will return of the offset of the last match on that scalar variable. You can also assign a value to this function (for example, <TT>pos($foo) = 20;</TT>) in order to change the starting point of the next match operation.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$name = "alpha1 alpha2 alpha3 alpha4";
  $name =~ m/alpha/g;
  print("pos() ", pos($name), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcprint"></A>
  <H3><A NAME="print [FILEHANDLE] ( [LIST] )">print [FILEHANDLE] ( [LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Output<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Prints <TT>LIST</TT> to the file represented by <TT>FILEHANDLE</TT>. If no file handle is specified <TT>STDOUT</TT> will be used. This default file handle may be altered using the <TT>select()</TT> operator. If no list argument is specified <TT>$_</TT> is printed.<P>
  <FONT COLOR=Blue SIZE=2><PRE># This example may look funny, but it works. Go ahead and
  # try it!
  #
      print(" returns ", print("print()"), 
  " on success.\n");
  #
  # The inside print() function is evaluated first, 
  # then the
  # outer print() function is evaluated.</PRE></FONT>
  </TABLE>
  <A NAME="xcprintf"></A>
  <H3><A NAME="printf [FILEHANDLE] ( FORMAT, LIST )">printf [FILEHANDLE] ( FORMAT, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Output<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false otherwise.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Uses format specifiers to print <TT>LIST</TT> in specific ways. If no file handle is specified, <TT>STDOUT</TT> is used. For more information, see "<A HREF="ch09.htm#Example: Printing Revisited">Example: Printing Revisited</A>,"  in Chapter 9, "<A HREF="ch09.htm">Using Files</A>." <P>
  <FONT COLOR=Blue SIZE=2><PRE>printf("printf() An integer printed with leading zeroes %05d.\n", 9);</PRE></FONT>
  </TABLE>
  <A NAME="xcpush"></A>
  <H3><A NAME="push ( ARRAY, LIST )">push ( ARRAY, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of elements in the new array.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Appends the elements in <TT>LIST</TT> to the end of the specified array.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Find out how any elements are in @array. 
  # This works because
  # you are essentially appending an empty array.
  @array = ('A'..'R');
  print("There are ", push(@array), "elements.\n");

  @array = ( 1, 2 );
  print("There are ", push(@array, (3, 4, 5)), 
  "elements.\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcq"></A>
  <H3><A NAME="q ( LIST )">q ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a single-quoted string.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	<TT>q()</TT> can be used instead of single quotes. This is not really a function, more like an operator, but you'll probably look here if you see it in another programmer's program without remembering what it is. You can actually use any set of delimiters, not just the parentheses.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print(q(This is a single quoted string 
    without interpolation), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcqq"></A>
  <H3><A NAME="qq ( LIST )">qq ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a double-quoted string.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	q<TT>q()</TT> can be used instead of double quotes. This is not really a function, more like an operator, but you'll probably look here if you see it in another programmer's program without remembering what it is. You can actually use any set of delimiters, not just the parentheses.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print(qq(This is a double quoted string 
    with interpolation\n));</PRE></FONT>
  </TABLE>
  <A NAME="xcquotemeta"></A>
  <H3><A NAME="quotemeta ( EXPR )">quotemeta ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Regular Expression, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a string with all meta-characters escaped.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Escapes all meta-characters in <TT>EXPR</TT>. For example, <TT>quotemeta("AB*..C")</TT> returns <TT>"'AB\*\.\.C"</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print quotemeta("AB*\n[.]*");</PRE></FONT>
  </TABLE>
  <A NAME="xcqw"></A>
  <H3><A NAME="qw ( LIST )">qw ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, a list consisting of the element of <TT>LIST</TT> evaluated as if they were single-quoted.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	<TT>qw()</TT> is a quick way to specify a lot of little single-quoted words. For example, <TT>qw(foo, bar, baz)</TT> is equivalent to <TT>'foo', 'bar', 'baz'</TT>. Some programmers feel that using <TT>qw</TT> make Perl scripts easier to read. This is not really a function, more like an operator, but you'll probably look here if you see it in another programmer's program without remembering what it is. You can actually use any set of delimiters, not just the parentheses.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@array = qw(This is a list of words without interpolation);</PRE></FONT>
  </TABLE>
  <A NAME="xcqx"></A>
  <H3><A NAME="qx ( LIST )">qx ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the return value from the executed system command.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	<TT>qx()</TT> is a alternative to using back-quotes to execute system commands. For example, <TT>qx(ls -l)</TT> will execute the UNIX <TT>ls</TT> command using the <TT>-l</TT> command-line option. This is not really a function, more like an operator, but you'll probably look here if you see it in another programmer's program without remembering what it is. You can actually use any set of delimiters, not just the parentheses.<P>
  <FONT COLOR=Blue SIZE=2><PRE># summarize disk usage for the /tmp directory
  # and store the output of the command into the
  # @output array.
  #
  @output = qx(du -s /tmp);</PRE></FONT>
  </TABLE>
  <A NAME="xcrand"></A>
  <H3><A NAME="rand ( [EXPR] )">rand ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a random number between 0 and <TT>EXPR</TT> or between 0 and 1 is no expression is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Generates a random numbers. The value of <TT>EXPR</TT> should be positive (use the <TT>abs()</TT> function if needed). As the function calls a pseudo random generator, it generates the same sequence of numbers unless the initial seed value is altered with <TT>srand()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE># print a random number between 0 and 10.
  print("rand(), ", rand(10), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcread"></A>
  <H3><A NAME="read ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )">read ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Input<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of bytes read or the undefined value.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Reads, or attempts to read, <TT>LENGTH</TT> number of bytes from the file associated with <TT>FILEHANDLE</TT> into <TT>BUFFER</TT>. If an offset is specified, Perl will start reading the file from that point. For example, an offset of 100 will cause Perl to bypass the first 100 bytes of the file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>sub readFile {
     my($buffer) = "";

     open(FILE, "/etc/services") or
       die("Error reading file, stopped");
     read(FILE, $buffer, 10);
     print("read() $buffer\n");
     close(CLOSE)
  }</PRE></FONT>
  </TABLE>
  <A NAME="xcreaddir"></A>
  <H3><A NAME="readdir ( DIRHANDLE )">readdir ( DIRHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory, Files<P>
  Return Value in Scalar Context:	The name of the next file in the directory connected to <TT>DIRHANDLE</TT>.<P>
  Return Value in Array Context:	A list containing all of the files in the directory connected to <TT>DIRHANDLE</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Reads directory entries.<P>
  <FONT COLOR=Blue SIZE=2><PRE>opendir(DIR, "/tmp");
  @file = readdir(DIR);
  print("readdir() @files\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcreadlink"></A>
  <H3><A NAME="readlink ( [EXPR] )">readlink ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the value of the symbolic link represented by <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified. The undefined value is return if an error arises.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the value of a symbolic link. System errors are returned <TT>$!</TT>.<P>
  </TABLE>
  <A NAME="xcrecv"></A>
  <H3><A NAME="recv ( SOCKET, BUFFER, LENGTH, FLAGS )">recv ( SOCKET, BUFFER, LENGTH, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Sockets<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the address of the sender or the undefined value.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Places information from a socket into a buffer.<P>
  </TABLE>
  <A NAME="xcref"></A>
  <H3><A NAME="ref ( EXPR )">ref ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the data type of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the data type of a variable. For example, 'ARRAY', 'CODE', 'GLOB', 'HASH', 'REF', or 'SCALAR' might be returned. If a variable was blessed with the <TT>bless()</TT> function, then the new data type will be returned. The new data type will normally be a class name.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$foobar = { };
  bless($foobar, 'ATMPCLASS');
  print("ref() \$foobar is now in class ", ref($foobar), 
  "\n";</PRE></FONT>
  </TABLE>
  <A NAME="xcrename"></A>
  <H3><A NAME="rename ( OLDNAME, NEWNAME )">rename ( OLDNAME, NEWNAME )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful, false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Changes the name of a file. You can use this function change the directory location of a file as long as you don't cross file-system boundaries.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("rename() returned ", 
    rename("/tmp/test", "/tmp/test2"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcreset"></A>
  <H3><A NAME="reset ( [EXPR] )">reset ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Regular Expression<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, always returns true<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	This a way of resetting variables in the current package (especially pattern match variables). The expression is interpreted as list of single characters. All variables starting with those characters are reset. Hyphens may be used to specify ranges of variables to reset. If called without any argument it simply resets all search matches. Variables that have been declared using the <TT>my()</TT> function will not be reset.<P>
  <FONT COLOR=Blue SIZE=2><PRE>reset('R');
  reset('d-f');
  reset();</PRE></FONT>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=tomato SIZE=4><B> Caution</B></FONT></TD></TR><TR><TD BGCOLOR=tomato>
  Using <TT>reset()</TT> can reset system variables you may not want to alter-like the ARGV and ENV variables.</TD></TR></TABLE>
  </TABLE>
  <A NAME="xcreverse"></A>
  <H3><A NAME="reverse ( LIST )">reverse ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  Return Value in Scalar Context:	A string with characters of the first element of <TT>LIST</TT> reversed.<P>
  Return Value in Array Context:	The elements of <TT>LIST</TT> in reverse order.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Reverses the order of a string or list. No sorting is done, the list or string is simply reversed.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@array = (1, 2, 3);
  print("reverse() ", reverse(@array), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcrewinddir"></A>
  <H3><A NAME="rewinddir ( DIRHANDLE )">rewinddir ( DIRHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Lets you start reading directory entries all over again.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Open the current directory
  opendir(DIR, ".");

  # Print all of the directory entries.
  print("1<SUP>st</SUP> Time: ");
  map( print("$_ ") , readdir(DIR));
  print("\n");

  # Print message verifying that there are
  # no more directory entries to read.
  print("The last file has already been read!\n\n")
   unless readdir(DIR);

  # Go back to the beginning.
  rewinddir(DIR);

  # Print all of the directory entries again.
  print("2<SUP>nd</SUP> Time: ");
  map( print("$_ ") , readdir(DIR));
  print("\n");

  closedir(DIR);</PRE></FONT>
  </TABLE>
  <A NAME="xcrindex"></A>
  <H3><A NAME="rindex ( STRING, SUBSTRING, [POSITION] )">rindex ( STRING, SUBSTRING, [POSITION] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the position of the last occurrence of <TT>SUBSTRING</TT> in <TT>STRING</TT> at or before <TT>POSITION</TT> or -1 if not found.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	When called repeatedly, you can iterate over all the occurrences of <TT>SUBSTRING</TT> in <TT>STRING</TT>. The returned value is an offset from <TT>$[</TT> (which is normally zero). If <TT>$[</TT> is altered it will change the way <TT>index()</TT> works as it will start its search from $[ if no position argument is supplied, and it will return <TT>$[ - 1</TT> when there is no match found.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$answer1 = rindex("abcdefghijiklmdef", "def");

  # use the first position found as the offset to the
  # next search.
  # note that the length of the target string is 
  # subtracted from
  # the offset to save time.
  $answer2 = rindex("abcdefghijiklmdef", "def", 
    $answer1 - 3);

  print("rindex() \"def\" is at $answer1 and next 
    at $answer2\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcrmdir"></A>
  <H3><A NAME="rmdir ( [DIRNAME] )">rmdir ( [DIRNAME] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not. <TT>$!</TT> is set if the directory could not be deleted.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Tries to delete the specified directory. The directory must be empty of all files, symbolic links, and sub-directories.<P>
  </TABLE>
  <A NAME="xcscalar"></A>
  <H3><A NAME="scalar ( EXPR )">scalar ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the value of <TT>EXPR</TT> in a scalar context.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Forces the argument to interpreted in a scalar context, rather than as a list. For example, <TT>scalar(@array)</TT> will return the number of elements in <TT>@array</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$numElements = scalar(@array);</PRE></FONT>
  </TABLE>
  <A NAME="xcseek"></A>
  <H3><A NAME="seek ( FILEHANDLE, POSITION, WHENCE )">seek ( FILEHANDLE, POSITION, WHENCE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Moves to a specified position in a file. You can move relative to the beginning of the file (<TT>WHENCE</TT> = 0), the current position (<TT>WHENCE</TT> = 1), or the end of the file (<TT>WHENCE</TT> = 2). This function is mainly used with fixed length records to randomly access specific records of the file.<P>
  </TABLE>
  <A NAME="xcseekdir"></A>
  <H3><A NAME="seekdir ( DIRHANDLE, POS )">seekdir ( DIRHANDLE, POS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Allows the position in a directory to be reset to a position saved with <TT>telldir()</TT>. This is useful when processing directories with <TT>readdir()</TT>.<P>
  </TABLE>
  <H3><A NAME="select ( [FILEHANDLE] )">select ( [FILEHANDLE] )</A></H3>
  <A NAME="xcselect"></A>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the currently selected filehandle.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD> 	Changes the default file handle used for the <TT>print()</TT> and <TT>write()</TT> functions. By default, <TT>STDOUT</TT> is selected, but this function can select any other file handle to be the default instead. The return value is the currently selected file handle (before any change) so it is useful to assign this to a variable in order to be able to restore the original handle as the default at a later stage.<P>
  <FONT COLOR=Blue SIZE=2><PRE>open(FILE,"&gtt.out");
      $oldHandle = select(FILE);
          print("This is sent to /tmp/t.out.\n");
      select($oldHandle);
  print("This is sent to STDOUT.\n");

  # Here is an advanced example which selects an alternate 
  # file handle and restores it in one step. The secret is 
  # the
  # use of parentheses to create a list out of the return 
  # values
  # of the statements evaluated by the comma operator.
  open(FILE, "&gtt.out");
      select((select(FILE), 
             print("This is sent to t.out.\n"))[0]);
  print("This is sent to STDOUT.\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcselect"></A>
  <H3><A NAME="select ( RBITS, WBITS, EBITS, TIMEOUT )">select ( RBITS, WBITS, EBITS, TIMEOUT )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Socket, UNIX<P>
  Return Value in Scalar Context:	The number of ready descriptors that were found-usually referred to as <TT>$nfound</TT>.<P>
  Return Value in Array Context:	($nfound, $timeleft) - The number of ready descriptors and the amount of time left before a timeout happends.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Examines file descriptors to see if they are ready or if they have exception conditions pending.<P>
  </TABLE>
  <A NAME="xcsemctl"></A>
  <H3><A NAME="semctl ( ID, SEMNUM, CMD, ARG )">semctl ( ID, SEMNUM, CMD, ARG )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful; false if not and the undefined value in some cases.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Controls operations on semaphores.<P>
  </TABLE>
  <A NAME="xcsemget"></A>
  <H3><A NAME="semget ( KEY, NSEMS, FLAGS )">semget ( KEY, NSEMS, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a semaphore id or undefined if an error occurs.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Finds the semaphore associated with <TT>KEY</TT>.<P>
  </TABLE>
  <A NAME="xcsemop"></A>
  <H3><A NAME="semop ( KEY, OPSTRING )">semop ( KEY, OPSTRING )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Performs semaphore operations like signaling and waiting.<P>
  </TABLE>
  <A NAME="xcsend"></A>
  <H3><A NAME="send ( SOCKET, BUFFER, FLAGS, [TO] )">send ( SOCKET, BUFFER, FLAGS, [TO] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of characters sent or the undefined value if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sends the information in a buffer to a socket. If the socket is not connected, you can specify a destination using the <TT>TO</TT> parameter.<P>
  </TABLE>
  <A NAME="xcsetgrent"></A>
  <H3><A NAME="setgrent ( )">setgrent ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Rewinds the <TT>/etc/group</TT> file to the start of the file for subsequent accesses using <TT>getgrent()</TT>.<P>
  </TABLE>
  <A NAME="xcsethostent"></A>
  <H3><A NAME="sethostent ( STAYOPEN )">sethostent ( STAYOPEN )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Host, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Determines if name server queries use UDP datagrams (<TT>STAYOPEN</TT> = 0) or if the socket connection to the name server should stay open (<TT>STAYOPEN</TT> = 1). This affects functions like <TT>gethostbyname()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>sethostent(1);</PRE></FONT>
  </TABLE>
  <A NAME="xcsetnetent"></A>
  <H3><A NAME="setnetent ( STAYOPEN )">setnetent ( STAYOPEN )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Network, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Rewinds the <TT>/etc/networks</TT> file used by <TT>getnetent()</TT> and other network related functions. If <TT>STAYOPEN</TT> has a value of 1 then the file is kept open between calls to <TT>getnetbyname()</TT> and <TT>getnetbyaddr()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>setnetent(1);</PRE></FONT>
  </TABLE>
  <A NAME="xcsetpgrp"></A>
  <H3><A NAME="setpgrp (PID, PGRP)">setpgrp (PID, PGRP)</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Group, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sets the current process group for the specified process. If <TT>PID</TT> is zero, the current process group for the current process is set.<P>
  </TABLE>
  <A NAME="xcsetpriority"></A>
  <H3><A NAME="setpriority ( WHICH, WHO, PRIORITY )">setpriority ( WHICH, WHO, PRIORITY )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sets the current priority of <TT>WHO</TT> (the pid, group pid, uid, or 0 for the current process, group or user). The <TT>WHICH</TT> parameter can one of <TT>PRIO_PROCESS</TT> (0), <TT>PRIO_PGGRP</TT> (1), <TT>PRIO_USER</TT> (2). The priority is a number representing the level of priority (normally in the range 120 to 20) where the lower the priority the more favorable the scheduling of the process by the operating system.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("setpriority() ", setpriority(0, 0, -20), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcsetprotoent"></A>
  <H3><A NAME="setprotoent ( STAYOPEN )">setprotoent ( STAYOPEN )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Protocol<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Rewinds the <TT>/etc/protocols</TT> file used by <TT>getprotoent()</TT> and other protocol related functions. If <TT>STAYOPEN</TT> has a value of 1 then the file is kept open between calls to <TT>getprotobyname()</TT> and <TT>getprotobynumber()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>setprotoent(1);</PRE></FONT>
  </TABLE>
  <A NAME="xcsetpwent"></A>
  <H3><A NAME="setpwent">setpwent</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Password, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Rewinds the <TT>/etc/passwd</TT> file used by <TT>getpwent()</TT> and other password related functions.<P>
  <FONT COLOR=Blue SIZE=2><PRE>setpwent();</PRE></FONT>
  </TABLE>
  <A NAME="xcsetservent"></A>
  <H3><A NAME="setservent ( STAYOPEN )">setservent ( STAYOPEN )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Services, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Rewinds the <TT>/etc/services</TT> file used by <TT>getservent()</TT> and other service related functions. If <TT>STAYOPEN</TT> has a value of 1 then the file is kept open between calls to <TT>getservbyname()</TT> and <TT>getservbyport()</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>setservent(1);</PRE></FONT>
  </TABLE>
  <A NAME="xcsetsockopt"></A>
  <H3><A NAME="setsockopt ( SOCKET, LEVEL, OPTNAME, OPTVAL )">setsockopt ( SOCKET, LEVEL, OPTNAME, OPTVAL )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sets socket options.<P>
  </TABLE>
  <A NAME="xcshift"></A>
  <H3><A NAME="shift ( [ARRAY] )">shift ( [ARRAY] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the first element of <TT>ARRAY</TT> or the undefined value if the specified array is empty. If no array is specified, <TT>@ARGV</TT> will be used in the mail program and <TT>@_</TT> will be used in functions.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Takes the first element from the specified array and returns that, reducing the array by one element.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@array = (1..5);
  while ($element = shift(@array)) {
      print("$element - ");
  }
  print("\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcshmctl"></A>
  <H3><A NAME="shmctl ( ID, CMD, ARG )">shmctl ( ID, CMD, ARG )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful; false if not and the undefined value in some cases.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Controls shared memory.<P>
  </TABLE>
  <A NAME="xcshmget"></A>
  <H3><A NAME="shmget ( KEY, SIZE, FLAGS )">shmget ( KEY, SIZE, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the id of a shared memory segment or the undefined value if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Finds the id of a shared memory segment.<P>
  </TABLE>
  <A NAME="xcshmread"></A>
  <H3><A NAME="shmread ( ID, BUFFER, POS, SIZE )">shmread ( ID, BUFFER, POS, SIZE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Reads information from a shared memory segment.<P>
  </TABLE>
  <A NAME="xcshmwrite"></A>
  <H3><A NAME="shmwrite ( ID, BUFFER, POS, SIZE )">shmwrite ( ID, BUFFER, POS, SIZE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Inter-process Communication, Shared Memory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Writes information from a shared memory segment.<P>
  </TABLE>
  <A NAME="xcshutdown"></A>
  <H3><A NAME="shutdown ( SOCKET, HOW )">shutdown ( SOCKET, HOW )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Shuts down the connection to a socket. If <TT>HOW</TT> = 0, all incoming information will be ignored. If <TT>HOW </TT>= 1, all outgoing information will stopped. If <TT>HOW</TT> = 2, then both sending and receiving is disallowed.<P>
  </TABLE>
  <A NAME="xcsin"></A>
  <H3><A NAME="sin ( [EXPR] )">sin ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the sine of <TT>EXPR</TT> in radians or the sine of <TT>$_</TT> if no expression was specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Calculates the sine of the expression in radians.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$temp = sin(4);</PRE></FONT>
  </TABLE>
  <A NAME="xcsleep"></A>
  <H3><A NAME="sleep ( [NUM_SECONDS_TO_SLEEP] )">sleep ( [NUM_SECONDS_TO_SLEEP] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of seconds spent sleeping.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Causes the current process to sleep for the number of seconds specified (if none specified it sleeps forever, but may be woken up by a <TT>SIGALRM</TT> signal if this has been programmed).<P>
  <FONT COLOR=Blue SIZE=2><PRE>sleep(5);</PRE></FONT>
  </TABLE>
  <A NAME="xcsocket"></A>
  <H3><A NAME="socket ( SOCKET, DOMAIN, TYPE, PROTOCOL )">socket ( SOCKET, DOMAIN, TYPE, PROTOCOL )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Opens a specific type of socket.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  When using <TT>socket()</TT>, make sure that you have the statement <TT>use Socket;</TT> at the top of your file so that the proper definitions get imported.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcsocketpair"></A>
  <H3><A NAME="socketpair ( SOCKET1, SOCKET2, DOMAIN, TYPE, PROTOCOL )">socketpair ( SOCKET1, SOCKET2, DOMAIN, TYPE, PROTOCOL )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Socket<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates an unnamed pair of the specified type of sockets in the specified domain.<P>
  </TABLE>
  <A NAME="xcsort"></A>
  <H3><A NAME="sort ( [SUBNAME | BLOCK], LIST )">sort ( [SUBNAME | BLOCK], LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, a copy of <TT>LIST</TT> in sorted order.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sorts the specified list. Since a <I>copy</I> of the original list of sorted, you must assigned the returned array to a variable in order to save the sorted order. The sort method can be specified with the optional function or block parameter. A function may be specified which takes two arguments (passed as the variables <TT>$a</TT> and <TT>$b</TT>) and returns true if the first is less that or equal to the second by any sort criteria used. Similarly a code block can be specified (effectively an anonymous function) to perform this function. The default sort order is based on the standard string comparison order. You can look at the web page <B>http://www.perl.com/perl/everything_to_know/sort.html</B> for an extensive discussion of sorting techniques.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@array = ("z", "w", "r", "i", "b", "a");
  print("sort() ", sort(@array), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcsplice"></A>
  <H3><A NAME="splice ( ARRAY, OFFSET, [LENGTH], [LIST] )">splice ( ARRAY, OFFSET, [LENGTH], [LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, a list of the elements removed from <TT>ARRAY</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Removes the specified elements (<TT>LENGTH</TT> elements starting at <TT>OFFSET</TT>) from the specified array, replacing them with the elements in <TT>LIST</TT> if needed. If no length is specified all the items from offset to the end of the array are removed.<P>
  <FONT COLOR=Blue SIZE=2><PRE># Replace the first three elements with capitalized 
  # versions.
  @array        = ("a", "e", "i", "o", "u");
  @removedItems = 
     splice(@array, 0 , 3, ("A", "E", "I"));</PRE></FONT>
  </TABLE>
  <A NAME="xcsplit"></A>
  <H3><A NAME="split ( [/PATTERN/], [EXPR], [LIMIT] )">split ( [/PATTERN/], [EXPR], [LIMIT] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, Regular Expression<P>
  Return Value in Scalar Context:	Not recommended, but it returns the number of fields found and stored the fields in the <TT>@_</TT> array.<P>
  Return Value in Array Context:	A list of fields found in <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Splits a string expression into fields based on the delimiter specified by <TT>PATTERN</TT>. If no pattern is specified whitespace is the default. An optional limit restricts the number of elements returned. A negative limit the same effect as no limit. This function is often used in conjunction with <TT>join()</TT> to create small text databases.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@fields = split(/:/, "1:2:3:4:5");</PRE></FONT>
  </TABLE>
  <A NAME="xcsprintf"></A>
  <H3><A NAME="sprintf ( FORMAT, LIST )">sprintf ( FORMAT, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a formatted text string.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Uses format specifiers to format the elements of <TT>LIST</TT> in specific ways.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$text = sprintf("%0d \n", 9);</PRE></FONT>
  </TABLE>
  <A NAME="xcsqrt"></A>
  <H3><A NAME="sqrt ( [EXPR] )">sqrt ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the square root of <TT>EXPR</TT> or <TT>$_</TT> if no expression is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Calculates square roots.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$result = sqrt(4);</PRE></FONT>
  </TABLE>
  <A NAME="xcsrand"></A>
  <H3><A NAME="srand ( [EXPR] )">srand ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Math<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sets the seed used by the pseudo random number generation algorithm when generating random numbers via <TT>rand()</TT>. In order to randomize the possible sequences the seed should be set to a different value each time the script is called. When no expression is supplied the default behavior is to use the current system time. This is not a secure method of randomizing for scripts which need to be secure as it is possible to predict what sequence the script will return.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightpink SIZE=4><B> Tip</B></FONT></TD></TR><TR><TD BGCOLOR=lightpink>
  It is possible to generate exactly the same data repeatedly (without having to save the entire sequence) simply by stetting and saving the seed. Restoring the seed and calling <TT>rand()</TT> will then produce the same sequence again. <P>
  <PRE>srand(26);
  print("Here's a random number:        ", 
      rand(), ".\n");
  srand(26);
  print("Here's the same random number: ", 
      rand(), ".\n");</PRE></TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcstat"></A>
  <H3><A NAME="stat ( FILEHANDLE | EXPR )">stat ( FILEHANDLE | EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, ($device, $inode, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks)<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns the file statistics of the file pointed to by the file handle (or a filename produced by evaluating expression). Note that, like the filetest operators, <TT>stat()</TT> can use the special underscore filehandle (_) which means that the test is carried out on the same filehandle as the last filetest, <TT>stat()</TT> or <TT>lstat()</TT> call.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($device, $inode, $mode, $nlink, $uid, $gid, $rdev, $size, 
      $atime, $mtime, $ctime, $blksize, $blocks) = 
        stat("/etc/passwd");

  print("stat() $device, $inode, $ctime\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcstudy"></A>
  <H3><A NAME="study ( [SCALAR] )">study ( [SCALAR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Regular Expression<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD> 	Sets up internal lookup tables based on the string studied so that pattern matching operations can use this information to process the pattern match more quickly. When many pattern match operations are being performed on the same string, the efficiency of these patterns can be improved by the use of the <TT>study()</TT> function. If no string is specified the <TT>$_</TT> is studied by default. Only one string at a time can be studied (subsequent calls effectively forget about the previously studied string). Thus is often used in a loop processing, where each line of a file is studied before being processed with various pattern matches.<P>
  </TABLE>
  <A NAME="xcsubstr"></A>
  <H3><A NAME="substr ( EXPR, OFFSET, [LEN] )">substr ( EXPR, OFFSET, [LEN] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a substring of <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets a substring from <TT>EXPR</TT>, starting from <TT>OFFSET</TT> for <TT>LEN</TT> characters or until the end of the specified string. If the offset is negative it starts from the right hand side of the string instead of the left hand side. If the length is negative, it means to trim the string by that number of characters.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$temp = substring("okay", 2);</PRE></FONT>
  </TABLE>
  <A NAME="xcsymlink"></A>
  <H3><A NAME="symlink ( OLDFILE, NEWFILE )">symlink ( OLDFILE, NEWFILE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Symbolic Link<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  Definition 	Creates a symbolic link from the existing file to the new file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>symlink("/usr/local", "/tmp/symlink_to_usr_local");</PRE></FONT>
  </TABLE>
  <A NAME="xcsyscall"></A>
  <H3><A NAME="syscall ( LIST )">syscall ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Lets Perl to call corresponding UNIX C system calls directly. It relies on the existence of the set of Perl header files <TT>syscall.ph</TT> which declare all these calls. The script h2ph which is normally executed when Perl is installed sets up the <TT>syscall.ph</TT> files. Each call has the same name as the equivalent UNIX system call with the "SYS_" prefix. As these calls actually pass control to the relevant C system, function care must be taken with passing parameters.<P>
  The first element in the list used as an argument to <TT>syscall()</TT> itself is the name corresponding to the UNIX system call (i.e. with the <TT>"SYS_"</TT> prefix). The next elements in the list are interpreted as parameters to this call. Numeric values are passed as the C type int. String values are passed as pointers to arrays. The length of these strings must be able to cope with any value assigned to that parameter in the call.<P>
  <FONT COLOR=Blue SIZE=2><PRE>require(""syscall.ph");
  syscall(&#38;SYS_getpid);</PRE></FONT>
  </TABLE>
  <A NAME="xcsysopen"></A>
  <H3><A NAME="sysopen ( FILEHANDLE, FILENAME, MODE, [PERMISSIONS] )">sysopen ( FILEHANDLE, FILENAME, MODE, [PERMISSIONS] )</A></H3>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lime SIZE=4><B> Troubleshooting</B></FONT></TD></TR><TR><TD BGCOLOR=lime>
  This was first implemented in Perl 5.002.</TD></TR></TABLE><P>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Open a file using the underlying operating system's <TT>open()</TT> function. The values for <TT>MODE</TT> and <TT>PERMISSIONS</TT> are system-dependent. You may be able to look in the <TT>Fcntl</TT> module for more information.<P>
  </TABLE>
  <A NAME="xcsysread"></A>
  <H3><A NAME="sysread ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )">sysread ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Input<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of bytes read or the undefined value if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Tries to read <TT>LENGTH</TT> bytes into <TT>BUFFER</TT>. The <TT>OFFSET</TT> parameter is used to change where in the file the data is read.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=tomato SIZE=4><B> Caution</B></FONT></TD></TR><TR><TD BGCOLOR=tomato>
  This function, along with <TT>syswrite()</TT>, bypasses the standard low-level input/output functions that other Perl functions use. Therefore, <TT>sysread()</TT> and <TT>syswrite()</TT> should be mixed with other types of input and output functions.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xcsystem"></A>
  <H3><A NAME="system ( LIST )">system ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the exit code of the system command that was executed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Executes <TT>LIST</TT> as an operating system call. The process to execute this command is forked and the script waits for the child process to return.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lightcyan SIZE=4><B> Note</B></FONT></TD></TR><TR><TD BGCOLOR=lightcyan>
  To capture the output from a system call use a back-quoted string instead than <TT>system()</TT>.</TD></TR></TABLE><P>
  <FONT COLOR=Blue SIZE=2><PRE>system("ls -F /var &gt /tmp/t.tmp");</PRE></FONT>
  </TABLE>
  <A NAME="xcsyswrite"></A>
  <H3><A NAME="syswrite ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )">syswrite ( FILEHANDLE, BUFFER, LENGTH, [OFFSET] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Output<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of bytes written or the undefined value if an error occurred.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Tries to write <TT>LENGTH</TT> bytes from <TT>BUFFER</TT>. The <TT>OFFSET</TT> parameter is used to change where in the file the data is written.<P>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=tomato SIZE=4><B> Caution</B></FONT></TD></TR><TR><TD BGCOLOR=tomato>
  This function, along with <TT>syswrite()</TT>, bypasses the standard low-level input/output functions that other Perl functions use. Therefore, <TT>sysread()</TT> and <TT>syswrite()</TT> should be mixed with other types of input and output functions.</TD></TR></TABLE><P>
  </TABLE>
  <A NAME="xctell"></A>
  <H3><A NAME="tell ( [FILEHANDLE] )">tell ( [FILEHANDLE] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the current position in the file associated with <TT>FILEHANDLE</TT> or in the last file accessed if no filehandle is specified.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the current position in a file.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$filePos = tell(FILE);</PRE></FONT>
  </TABLE>
  <H3><A NAME="telldir ( DIRHANDLE )">telldir ( DIRHANDLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Directory<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the current position in the directory associated with <TT>DIRHANDLE</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the current directory position. This value can only be used by the <TT>seekdir()</TT> function.<P>
  <FONT COLOR=Blue SIZE=2><PRE>opendir(DIR, "/tmp");
  readdir(DIR);
  print("telldir() ", telldir(DIR), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xctie"></A>
  <H3><A NAME="tie ( VARIABLE, PACKAGENAME, LIST )">tie ( VARIABLE, PACKAGENAME, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a reference to an object.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Binds a variable to a package class. The creates an instance of this class using the classes' <TT>new()</TT> method. Any parameters for the <TT>new()</TT> method may be specified in <TT>LIST</TT>.<P>
  The behavior depends on the way the package class is written, and on the type of variable. Most common are package classes written to support associative arrays. In particular, package classes exist to bind associative arrays to various databases.<P>
  The tie() mechanism has the effect of hiding all the complexities of implementation behind a simple interface. For example, the records in a database can be accessed by looking at the associative array bound to the database.<P>
  The example here uses the Configure.pm module. This module stores the information about the machine on which Perl has been installed. It is possible to bind an associateive array to this class and examine this to find out the value of any of the configuration parameters.<P>
  <FONT COLOR=Blue SIZE=2><PRE>use Configure;
  $return = tie %c, Configure;
  print("tie() returned \"$return\" and a sample 
    value is $c{installbin}\n");</PRE></FONT>
  </TABLE>
  <A NAME="xctied"></A>
  <H3><A NAME="tied ( VARIABLE )">tied ( VARIABLE )</A></H3>
  <TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0><TR><TD BGCOLOR=black><FONT COLOR=lime SIZE=4><B> Troubleshooting</B></FONT></TD></TR><TR><TD BGCOLOR=lime>
  This was first implemented in Perl 5.002.</TD></TR></TABLE><P>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a reference to an object previously bound via <TT>tie()</TT> or the undefined value if <TT>VARIABLE</TT> is not tied to a package.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Returns a reference to the object which the variable is an instance of. This is the same object as was returned by the original call to <TT>tie()</TT> when it was bound.<P>
  </TABLE>
  <A NAME="xctime"></A>
  <H3><A NAME="time ( )">time ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Time<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the time in seconds since January 1, 1970.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets the current time. You can use gmtime(time()) or localtime(time()) to access the different elements of time-day, month, etc...<P>
  $then = time();
  # time passes while code is running.
  $now = time();
  $elaspedTime = $now - $then;
  </TABLE>
  <H3><A NAME="times ( )">times ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	ARRAY, ($usertime, $systemtime, $childsystem, $childuser)<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets a list of four elements representing the amount of time used by the current and child processes.<P>
  <FONT COLOR=Blue SIZE=2><PRE>($usertime, $systemtime, $childsystem, 
    $childuser) = times();
  print("times() $usertime $systemtime $childsystem 
    $childuser\n");</PRE></FONT>
  </TABLE>
  <A NAME="xctruncate"></A>
  <H3><A NAME="truncate ( FILEHANDLE | EXPR, LENGTH )">truncate ( FILEHANDLE | EXPR, LENGTH )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if successful or false if not.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Truncates the file referenced by <TT>FILEHANDLE</TT> or named by <TT>EXPR</TT> to <TT>LENGTH</TT>.<P>
  </TABLE>
  <A NAME="xcuc"></A>
  <H3><A NAME="uc ( EXPR )">uc ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a copy of <TT>EXPR</TT> with all letters in uppercase.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a copy of <TT>EXPR</TT> with all letters in uppercase.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("uc() ", uc("abcdEF"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcucfirst"></A>
  <H3><A NAME="ucfirst ( EXPR )">ucfirst ( EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, a copy of <TT>EXPR</TT> with the first letter in uppercase.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Creates a copy of <TT>EXPR</TT> with the first letter in uppercase.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("ucfirst() ", ucfirst("abcdEF"), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcumask"></A>
  <H3><A NAME="umask ( [EXPR] )">umask ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the old process umask.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets and/or sets the process file mask. Returns the old umask so that it can be stored and restored later if required. If called without any arguments returns the current umask. This is the UNIX mechanism used to modify the permissions of any files created.<P>
  <FONT COLOR=Blue SIZE=2><PRE>print("umask() The current umask is: ", umask(), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcundef"></A>
  <H3><A NAME="undef ( [EXPR] )">undef ( [EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the undefined value.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Undefines the value of <TT>EXPR</TT>. The expression may be a scalar, an array or a subroutine (specified with a &#38; prefix).<P>
  </TABLE>
  <A NAME="xcunlink"></A>
  <H3><A NAME="unlink ( LIST )">unlink ( LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of files successfully deleted.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Deletes the files in <TT>LIST</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>unlink("/tmp/t.tst", "/tmp/t.bak");</PRE></FONT>
  </TABLE>
  <A NAME="xcunpack"></A>
  <H3><A NAME="unpack ( TEMPLATE, EXPR )">unpack ( TEMPLATE, EXPR )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, String<P>
  Return Value in Scalar Context:	The first item unpacked from <TT>EXPR</TT>.<P>
  Return Value in Array Context:	A list of element produced from <TT>EXPR</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Unpacks data using the same template mechanism as <TT>pack()</TT> to specify the format of the data in <TT>EXPR</TT>.<P>
  </TABLE>
  <A NAME="xcunshift"></A>
  <H3><A NAME="unshift ( ARRAY, LIST )">unshift ( ARRAY, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of elements in <TT>ARRAY</TT> after <TT>LIST</TT> has been prefixed to it.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Adds <TT>LIST</TT> to the front of <TT>ARRAY</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>@array = qw(a, b, c);
  print("unshift() Array has ", 
      unshift(@array, 1, 2, 3), " elements: @array\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcuntie"></A>
  <H3><A NAME="untie ( VARIABLE )">untie ( VARIABLE )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Breaks the binding between a variable and a package.<P>
  </TABLE>
  <A NAME="xcutime"></A>
  <H3><A NAME="utime ( ACCESS_TIME, MODIFICATION_TIME, LIST )">utime ( ACCESS_TIME, MODIFICATION_TIME, LIST )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Time<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the number of files successfully changed.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Sets the access and modification times of all the files in <TT>LIST</TT> to the times specified by the first two parameters. The time must be in the numeric format (for example, seconds since January 1, 1970).<P>
  <FONT COLOR=Blue SIZE=2><PRE>utime(time(), time(), "/tmp/t.tst");</PRE></FONT>
  </TABLE>
  <A NAME="xcvalues"></A>
  <H3><A NAME="values ( HASH )">values ( HASH )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Array, Hash<P>
  Return Value in Scalar Context:	The number of values and, therefore, the number of entries in <TT>HASH</TT>.<P>
  Return Value in Array Context:	All of the values in <TT>HASH</TT> in no particular order.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Gets a list of all values in <TT>HASH</TT>. The returned list is ordered by the internal storage requirements, so it is often useful to use the <TT>sort()</TT> function before processing. For example, <TT>sort(values(%hash))</TT>.<P>
  <FONT COLOR=Blue SIZE=2><PRE>%hash = ('One' =&gt 1, 'Two' =&gt 2, 
    'Three' =&gt 3, 'Four' =&gt 4);
  print("keys() ", join("-", values(%hash)), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcvec"></A>
  <H3><A NAME="vec ( EXPR, OFFSET, NUM_BITS )">vec ( EXPR, OFFSET, NUM_BITS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	String<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the value of the bit field specified by <TT>OFFSET</TT>.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Uses the string specified <TT>EXPR</TT> as a vector of unsigned integers. The <TT>NUMBITS</TT> parameter is the number of bits that are reserved for each entry in the bit vector. This must be a power of two from 1 to 32. Note that the offset is the marker for the end of the vector, and it counts back the number of bits specified to find the start. Vectors can be manipulated with the logical bitwise operators |, &#38; and ^.<P>
  <FONT COLOR=Blue SIZE=2><PRE>$vec = '';
  vec($vec,  3, 4) = 1;  # bits 0 to 3
  vec($vec,  7, 4) = 10; # bits 4 to 7
  vec($vec, 11, 4) = 3;  # bits 8 to 11
  vec($vec, 15, 4) = 15; # bits 12 to 15
  # As there are 4 bits per number this can 
  # be decoded by unpack() as a hex number
  print("vec() Has a created a string of nybbles, 
      in hex: ", unpack("h*", $vec), "\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcwait"></A>
  <H3><A NAME="wait ( )">wait ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the process id of the child process that just ended or -1 if there are no child processes.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Waits for a child process to end.<P>
  </TABLE>
  <A NAME="xcwaitpid"></A>
  <H3><A NAME="waitpid ( PID, FLAGS )">waitpid ( PID, FLAGS )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Process, UNIX<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, the process id of the child process that just ended or -1 if there are no such process.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Waits for a specified child process to end. The flags can be set to various values which are equivalent to those used by the <TT>waitpid()</TT> UNIX system call. A value of 0 for <TT>FLAGS</TT> should work on all operating systems that support processes.<P>
  </TABLE>
  <A NAME="xcwantarray"></A>
  <H3><A NAME="wantarray ( )">wantarray ( )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Miscellaneous<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	SCALAR, true if the currently executing function is looking for a list value or false if it is looking for a scalar value.<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Used to return two alternatives from a subroutine, depending on the calling context. You can use <TT>wantarray()</TT> inside functions to determine the context in which your function was called.<P>
  <FONT COLOR=Blue SIZE=2><PRE>sub foo {
      return(wantarray() ? qw(A, B, C) : '1');
  }

  $result = foo();    # scalar context
  @result = foo();    # array context

  print("foo() in a  scalar context: $result\n");
  print("foo() in an array  context: 
  @result\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcwarn"></A>
  <H3><A NAME="warn ( [LIST] )">warn ( [LIST] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	Output<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Prints <TT>LIST</TT> to STDERR, like <TT>die()</TT>, but doesn't cause the script to exit or raise an exception. If there is no newline in the list, <TT>warn()</TT> will append the text "at line &ltline number&gt\n" to the message. However, the script will continue after a warn().<P>
  <FONT COLOR=Blue SIZE=2><PRE>warn("Unable to calculate value, using defaults instead.\n");</PRE></FONT>
  </TABLE>
  <A NAME="xcwrite"></A>
  <H3><A NAME="write ( [FILEHANDLE | EXPR] )">write ( [FILEHANDLE | EXPR] )</A></H3>
  <TABLE><TR><TD VALIGN=top>Category:</TD><TD>	File, Output<P>
  <TR><TD VALIGN=top>Return Value:</TD><TD>	None<P>
  <TR><TD VALIGN=top>Definition:</TD><TD>	Writes a formatted record to the file handle (or the file handle which the expression evaluates to). If no file handle is specified, the default is STDOUT, but this can be altered using <TT>select()</TT> if necessary.<P>
  A format for use by that file handle must have been declared using a format statement. This defaults to the name of the file handle being used, but other format names can be associated with the current write() operation by using the <TT>$~</TT> special variable.
  </TABLE>
  <HR><BR>
  <BLOCKQUOTE><FONT SIZE=2>Copyright &copy;1996, Que Corporation. All rights reserved. No part of this book may be used or reproduced in any form or by any means, or stored in a database or retrieval system without prior written permission of the publisher except in the case of brief quotations embodied in critical articles and reviews. Making copies of any part of this book for any purpose other than your own personal use is a violation of United States copyright laws. For information, address Que Corporation, 201 West 103<SUP>rd</SUP> Street, Indianapolis, IN 46290.
  <HR><BR>
  <H4 ALIGN=center>Jump to <A HREF="#contents">Contents</A> or <A HREF="#index">Index</A> or <A HREF="#xc">Top of XC</H4>
</BODY>
</HTML>
